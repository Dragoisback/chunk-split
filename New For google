<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text/JSON Chunker with Dynamic Glossary Replace</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f4f7f6;
      color: #333;
    }

    h1, h3, h4 {
        color: #2c3e50;
    }

    textarea {
      width: calc(100% - 22px);
      height: 200px;
      margin-bottom: 20px;
      padding: 10px;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      overflow-y: scroll;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      background-color: #fff;
    }

    .input-group {
        border: 1px solid #e0e0e0;
        padding: 15px;
        margin-bottom: 20px;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .input-group h3 {
        margin-top: 0;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
        margin-bottom: 15px;
    }

    .input-container {
      margin-bottom: 15px;
    }
    .input-container label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        color: #555;
    }
    .input-container input[type="number"],
    .input-container input[type="text"],
    .input-container select,
    .input-container textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    .input-container textarea {
        height: 80px;
    }

    /* Styles for dynamic find/replace pairs */
    .find-replace-pair {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        padding: 5px;
        border-radius: 4px;
        /* background-color: #f9f9f9; */
    }
    .find-replace-pair input[type="text"] {
        flex-grow: 1;
        margin-right: 8px;
    }
    .find-replace-pair .arrow {
        margin-right: 8px;
        font-weight: bold;
        color: #555;
    }
    .find-replace-pair .remove-pair-button,
    #addFindReplacePairButton {
        padding: 5px 10px;
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #e9ecef;
        color: #333;
        min-width: 30px; /* For consistency */
        text-align: center;
    }
    #addFindReplacePairButton {
        background-color: #28a745;
        color: white;
        border-color: #28a745;
        font-size: 14px;
        padding: 8px 12px;
    }
     .find-replace-pair .remove-pair-button:hover {
        background-color: #dc3545;
        color: white;
        border-color: #dc3545;
     }
     #addFindReplacePairButton:hover {
        background-color: #218838;
     }


    .chunk-container {
      margin-bottom: 20px;
      display: flex;
      align-items: flex-start;
      background-color: #fff;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #e0e0e0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .chunk-title {
      font-weight: bold;
      margin-right: 10px;
      min-width: 100px; /* Adjusted for potentially longer titles */
      padding-top: 8px;
      color: #007BFF;
      flex-shrink: 0; /* Prevent title from shrinking too much */
    }

    .chunk-textarea-wrapper {
        flex-grow: 1;
        margin-right: 10px;
    }
    .chunk-textarea-wrapper textarea {
        height: 150px;
        width: 100%;
        background-color: #e9ecef;
    }

    button, .copy-button {
      padding: 10px 15px;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    button#mainSplitButton {
        background-color: #28a745;
    }
    button#mainSplitButton:hover {
        background-color: #218838;
    }

    .copy-button {
      background-color: #007BFF;
      font-size: 14px;
      padding: 8px 12px;
      margin-top: 8px;
      display: flex;
      align-items: center;
    }
    .copy-button:hover {
        background-color: #0056b3;
    }
    .copy-button.green {
      background-color: #28a745;
    }
    .copy-button.green:hover {
      background-color: #1e7e34;
    }
    .copy-button .tick {
      display: none;
      margin-left: 8px;
      font-size: 16px;
    }
    .copy-button.green .tick {
      display: inline-block;
    }

    #glossaryFindReplaceSection button#applyPairedReplacementsButton {
        background-color: #ffc107;
        color: black;
        font-size: 14px;
        padding: 8px 15px;
        margin-top: 10px; /* Add some space before the button */
    }
    #glossaryFindReplaceSection button#applyPairedReplacementsButton:hover {
        background-color: #e0a800;
    }

    #chunkedTextContainer {
      margin-top: 30px;
    }

    #loadingIndicator {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 25px;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 8px;
      z-index: 1000;
      font-size: 1.1em;
      box-shadow: 0 0 15px rgba(0,0,0,0.3);
    }
  </style>
</head>

<body>
  <h1>Text/JSON Chunker</h1>

  <div class="input-container">
    <label for="splitModeSelect">Splitting Mode:</label>
    <select id="splitModeSelect">
      <option value="json">JSON Objects (Chunk by group or individually)</option>
      <option value="text">Plain Text (Split by max characters)</option>
    </select>
  </div>

  <div id="jsonInputSection" class="input-group">
    <h3>JSON Input Mode</h3>
    <p>Paste your array of JSON objects below. Each object in the root array will become a separate chunk by default, or grouped based on the setting below.</p>
    <textarea id="jsonInputArea" placeholder="[ { ... }, { ... } ]"></textarea>

    <div class="input-container" style="margin-top: 10px; margin-bottom: 20px;">
        <label for="jsonObjectsPerChunk">Combine original JSON objects per output chunk:</label>
        <select id="jsonObjectsPerChunk">
            <option value="1">1 (Original behavior: one object per chunk)</option>
            <option value="2">2 objects</option>
            <option value="3">3 objects</option>
            <option value="4">4 objects</option>
            <option value="5">5 objects</option>
            <option value="6">6 objects</option>
            <option value="7">7 objects</option>
            <option value="10">10 objects</option>
            <option value="20">20 objects</option>
        </select>
    </div>

    <div id="glossaryFindReplaceSection" style="margin-top: 20px; padding-top:15px; border-top: 1px dashed #ccc;">
      <h4>Paired Find & Replace in Glossary Translations:</h4>
      <p style="font-size:0.9em; color:#555;">
        Define find and replace pairs below. Rules are applied sequentially for each term's translation within the JSON objects.
      </p>
      <div id="findReplacePairsContainer">
        <!-- Initial 3 pairs will be added by JavaScript -->
      </div>
      <button type="button" id="addFindReplacePairButton" onclick="addFindReplacePair()">+ Add Replacement Rule</button>
      <button type="button" id="applyPairedReplacementsButton" onclick="performPairedGlossaryReplace()" style="margin-left:10px;">Apply All Replacement Rules</button>
      <span id="glossaryReplaceStatus" style="margin-left: 10px; font-size: 0.9em; display: block; margin-top: 5px;"></span>
    </div>
  </div>

  <div id="plainTextInputSection" class="input-group" style="display:none;">
    <h3>Plain Text Input Mode</h3>
    <p>Paste your plain text below. It will be split based on 'Max characters per chunk'.</p>
    <textarea id="plainTextInputArea" placeholder="Paste plain text here..."></textarea>
    <div class="input-container">
      <label for="formatSelect">Format text (for Plain Text Mode):</label>
      <select id="formatSelect">
        <option value="as-is">Show text as is</option>
        <option value="pretty">Pretty (trim lines, join with double newlines)</option>
      </select>
    </div>
    <div class="input-container">
      <label for="maxChars">Max characters per chunk (for Plain Text Mode):</label>
      <input type="number" id="maxChars" value="1800">
    </div>
  </div>


  <div class="input-group">
    <h3>Chunk Output Settings</h3>
    <div class="input-container">
      <label for="addToTop">Add to top of each chunk:</label>
      <textarea id="addToTop"
        placeholder="Text to add to the top of each chunk (use $X for part number, $Y for total parts)..."></textarea>
    </div>
    <div class="input-container">
      <label for="addToBottom">Add to bottom of each chunk:</label>
      <textarea id="addToBottom"
        placeholder="Text to add to the bottom of each chunk (use $X for part number, $Y for total parts)..."></textarea>
    </div>
  </div>

  <button id="mainSplitButton" onclick="processAndChunk()">Split Text</button>

  <div id="chunkedTextContainer"></div>
  <div id="loadingIndicator">Loading...</div>

  <script>
    let lastClickedButton = null;
    let originalPlainTextInput = "";
    let findReplacePairCount = 0; // To give unique IDs to dynamic elements if needed

    function showLoading() {
      document.getElementById('loadingIndicator').style.display = 'block';
    }

    function hideLoading() {
      document.getElementById('loadingIndicator').style.display = 'none';
    }

    function updateButtonState(button) {
      if (lastClickedButton && lastClickedButton !== button) {
        lastClickedButton.classList.remove('green');
        if (lastClickedButton.querySelector('.tick')) {
            lastClickedButton.querySelector('.tick').style.display = 'none';
        }
      }
      button.classList.add('green');
      if (button.querySelector('.tick')) {
          button.querySelector('.tick').style.display = 'inline-block';
      }
      lastClickedButton = button;
    }

    function addFindReplacePair(findVal = "", replaceVal = "") {
        findReplacePairCount++;
        const container = document.getElementById('findReplacePairsContainer');
        if (!container) return;

        const pairDiv = document.createElement('div');
        pairDiv.classList.add('find-replace-pair');
        pairDiv.innerHTML = `
            <input type="text" class="find-text" placeholder="Find this text" value="${findVal}">
            <span class="arrow">➔</span>
            <input type="text" class="replace-text" placeholder="Replace with this" value="${replaceVal}">
            <button type="button" class="remove-pair-button" onclick="removeFindReplacePair(this)">－</button>
        `;
        container.appendChild(pairDiv);
    }

    function removeFindReplacePair(button) {
        button.parentElement.remove();
    }


    document.addEventListener('DOMContentLoaded', () => {
      const maxCharsInput = document.getElementById('maxChars');
      const addToTopInput = document.getElementById('addToTop');
      const addToBottomInput = document.getElementById('addToBottom');
      const formatSelect = document.getElementById('formatSelect');
      const splitModeSelect = document.getElementById('splitModeSelect');
      const plainTextInputArea = document.getElementById('plainTextInputArea');
      const jsonObjectsPerChunkSelect = document.getElementById('jsonObjectsPerChunk'); // New

      addToTopInput.value = localStorage.getItem('addToTop') || 'Content (Part $X of $Y):\n---';
      addToBottomInput.value = localStorage.getItem('addToBottom') || '---\nEnd of Part $X';
      maxCharsInput.value = localStorage.getItem('maxChars') || '1800';
      formatSelect.value = localStorage.getItem('formatSelect') || 'pretty';
      splitModeSelect.value = localStorage.getItem('splitModeSelect') || 'json';
      
      if (jsonObjectsPerChunkSelect) { // New
          jsonObjectsPerChunkSelect.value = localStorage.getItem('jsonObjectsPerChunk') || '1';
      }
      
      // Add initial 3 find/replace pairs
      for (let i = 0; i < 3; i++) {
          addFindReplacePair();
      }

      toggleInputSections(); 

      maxCharsInput.addEventListener('input', () => localStorage.setItem('maxChars', maxCharsInput.value));
      addToTopInput.addEventListener('input', () => localStorage.setItem('addToTop', addToTopInput.value));
      addToBottomInput.addEventListener('input', () => localStorage.setItem('addToBottom', addToBottomInput.value));
      
      if (jsonObjectsPerChunkSelect) { // New
          jsonObjectsPerChunkSelect.addEventListener('change', () => {
              localStorage.setItem('jsonObjectsPerChunk', jsonObjectsPerChunkSelect.value);
          });
      }

      formatSelect.addEventListener('change', () => {
        localStorage.setItem('formatSelect', formatSelect.value);
        formatPlainText();
      });

      splitModeSelect.addEventListener('change', () => {
        localStorage.setItem('splitModeSelect', splitModeSelect.value);
        toggleInputSections();
      });
      
      if (plainTextInputArea) {
          plainTextInputArea.addEventListener('input', () => {
              originalPlainTextInput = plainTextInputArea.value;
              if (formatSelect.value === 'pretty') {
                  formatPlainText();
              }
          });
          if (plainTextInputArea.value) { // Ensure original is set if there's pre-filled text
              originalPlainTextInput = plainTextInputArea.value;
              formatPlainText(); // Apply initial format if needed
          }
      }
    });

    function toggleInputSections() {
        const splitMode = document.getElementById('splitModeSelect').value;
        const jsonSection = document.getElementById('jsonInputSection');
        const plainTextSection = document.getElementById('plainTextInputSection');
        
        if (jsonSection) jsonSection.style.display = (splitMode === 'json' ? 'block' : 'none');
        if (plainTextSection) plainTextSection.style.display = (splitMode === 'text' ? 'block' : 'none');
    }

    function performPairedGlossaryReplace() {
        const jsonInputArea = document.getElementById('jsonInputArea');
        const statusElement = document.getElementById('glossaryReplaceStatus');
        const pairsContainer = document.getElementById('findReplacePairsContainer');

        if (!jsonInputArea || !statusElement || !pairsContainer) {
            console.error("Required UI elements for paired replace not found.");
            if(statusElement) { statusElement.textContent = "UI Error."; statusElement.style.color = "red"; }
            return;
        }
        statusElement.textContent = ''; 

        const rules = [];
        const pairElements = pairsContainer.querySelectorAll('.find-replace-pair');

        for (let i = 0; i < pairElements.length; i++) {
            const findInput = pairElements[i].querySelector('.find-text');
            const replaceInput = pairElements[i].querySelector('.replace-text');
            if (!findInput || !replaceInput) continue;

            const findText = findInput.value; // Don't trim findText to allow searching for spaces
            const replaceText = replaceInput.value; 

            if (findText) { 
                rules.push({
                    find: findText,
                    replace: replaceText,
                    findRegExp: new RegExp(findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')
                });
            } else if (replaceText && !findText) { 
                 statusElement.textContent = `Warning: Rule ${i+1} has replace text but no find text. It will be ignored.`;
                 statusElement.style.color = 'orange';
            }
        }
        
        if (rules.length === 0 && pairElements.length > 0) { // Only show if user attempted to create rules but all were invalid
            let allFindFieldsEmpty = true;
            pairElements.forEach(pairEl => {
                if(pairEl.querySelector('.find-text').value) allFindFieldsEmpty = false;
            });
            if(allFindFieldsEmpty){
                statusElement.textContent = 'No valid replacement rules entered (all "Find" fields may be empty).';
                statusElement.style.color = 'orange';
                return;
            }
        }
        if(rules.length === 0) { // If no rules and no pairs, just silently do nothing or specific message
            statusElement.textContent = 'No replacement rules to apply.';
            statusElement.style.color = 'grey';
            setTimeout(() => { if (statusElement) statusElement.textContent = ''; }, 5000);
            return;
        }


        let jsonData;
        try {
            jsonData = JSON.parse(jsonInputArea.value);
        } catch (e) {
            statusElement.textContent = 'Error: Invalid JSON in input area. Cannot perform replace.';
            statusElement.style.color = 'red';
            return;
        }

        if (!Array.isArray(jsonData)) {
            statusElement.textContent = 'Error: JSON data must be an array of objects to perform glossary replace.';
            statusElement.style.color = 'red';
            return;
        }

        let totalInstancesReplacedThisRun = 0;
        let ruleApplicationStats = rules.map(rule => ({ find: rule.find, replacedInstances: 0 }));

        jsonData.forEach(obj => {
            if (obj && Array.isArray(obj.terms)) {
                obj.terms.forEach(term => {
                    if (term && typeof term.translation === 'string') {
                        let currentTermTranslation = term.translation;
                        
                        rules.forEach((rule, ruleIndex) => {
                            let matchOccurrences = (currentTermTranslation.match(rule.findRegExp) || []).length;
                            if (matchOccurrences > 0) {
                                currentTermTranslation = currentTermTranslation.replace(rule.findRegExp, rule.replace);
                                ruleApplicationStats[ruleIndex].replacedInstances += matchOccurrences;
                                totalInstancesReplacedThisRun += matchOccurrences;
                            }
                        });
                        term.translation = currentTermTranslation;
                    }
                });
            }
        });

        jsonInputArea.value = JSON.stringify(jsonData, null, 2);

        let statsSummary = ruleApplicationStats.filter(s => s.replacedInstances > 0)
                                   .map(s => `'${s.find}': ${s.replacedInstances}`)
                                   .join(', ');
        if (totalInstancesReplacedThisRun > 0) {
            statusElement.textContent = `Replacements applied. Total instances replaced: ${totalInstancesReplacedThisRun}. ${statsSummary ? `Details: ${statsSummary}` : ''}`;
            statusElement.style.color = 'green';
        } else {
            statusElement.textContent = 'Replacements applied. No instances found matching any rule.';
            statusElement.style.color = 'orange';
        }
        
        setTimeout(() => {
            if (statusElement) statusElement.textContent = '';
        }, 10000);
    }


    function formatPlainText() {
      const formatSelect = document.getElementById('formatSelect');
      const textArea = document.getElementById('plainTextInputArea');
      if (!formatSelect || !textArea) return;
      
      // Ensure originalPlainTextInput is correctly initialized if textarea has content on load
      if (!originalPlainTextInput && textArea.value) {
          originalPlainTextInput = textArea.value;
      }

      if (formatSelect.value === 'pretty') {
        const paragraphs = originalPlainTextInput.split('\n');
        const formattedText = paragraphs.map(p => p.trim()).filter(p => p).join('\n\n');
        textArea.value = formattedText;
      } else {
        textArea.value = originalPlainTextInput;
      }
    }

    function processAndChunk() {
      showLoading();
      setTimeout(() => {
        try {
          const splitMode = document.getElementById('splitModeSelect').value;
          const addToTop = document.getElementById('addToTop').value;
          const addToBottom = document.getElementById('addToBottom').value;
          const chunkedTextContainer = document.getElementById('chunkedTextContainer');
          if (!chunkedTextContainer) {
              hideLoading(); return;
          }
          chunkedTextContainer.innerHTML = ''; // Clear previous chunks
          if (splitMode === 'json') {
            chunkJsonInput(addToTop, addToBottom, chunkedTextContainer);
          } else {
            chunkPlainTextInput(addToTop, addToBottom, chunkedTextContainer);
          }
        } catch (error) {
          console.error("Error during chunking:", error);
          alert("An error occurred during chunking: " + error.message);
        } finally {
          hideLoading();
        }
      }, 10); 
    }

    function chunkJsonInput(addToTop, addToBottom, container) {
      const jsonInputArea = document.getElementById('jsonInputArea');
      if (!jsonInputArea) {
        alert("JSON input area not found.");
        hideLoading();
        return;
      }
      const jsonString = jsonInputArea.value;
      if (!jsonString.trim()) {
        alert("JSON input is empty.");
        hideLoading();
        return;
      }

      const objectsPerChunkInput = document.getElementById('jsonObjectsPerChunk');
      const objectsToGroup = parseInt(objectsPerChunkInput ? objectsPerChunkInput.value : "1", 10) || 1;

      let jsonData;
      try {
        jsonData = JSON.parse(jsonString);
      } catch (e) {
        alert("Invalid JSON: " + e.message);
        hideLoading();
        return;
      }
      if (!Array.isArray(jsonData)) {
        alert("Root JSON must be an array of objects.");
        hideLoading();
        return;
      }

      if (jsonData.length === 0) {
        alert("JSON array is empty. Nothing to chunk.");
        hideLoading();
        return;
      }

      const totalNewChunks = Math.ceil(jsonData.length / objectsToGroup);
      const newChunkDigits = String(totalNewChunks).length > 0 ? String(totalNewChunks).length : 1;

      for (let i = 0; i < jsonData.length; i += objectsToGroup) {
        const currentGroupOfObjects = jsonData.slice(i, i + objectsToGroup);

        if (currentGroupOfObjects.length === 0) continue; 

        const newChunkNumber = Math.floor(i / objectsToGroup) + 1; // 1-based index for the new chunk
        const newChunkPartNumberForPlaceholders = String(newChunkNumber).padStart(newChunkDigits, '0');

        // Create a title for the chunk
        let chunkDisplayTitle = `Segment ${newChunkPartNumberForPlaceholders}`;
        if (currentGroupOfObjects.length > 0) {
            const firstObjOriginalId = currentGroupOfObjects[0].id !== undefined ? currentGroupOfObjects[0].id : i; // Original index 'i' as fallback
            
            if (objectsToGroup > 1 || currentGroupOfObjects.length > 1) { 
                 const lastObjOriginalId = currentGroupOfObjects[currentGroupOfObjects.length - 1].id !== undefined
                    ? currentGroupOfObjects[currentGroupOfObjects.length - 1].id
                    : (i + currentGroupOfObjects.length - 1); 
                
                if (currentGroupOfObjects.length > 1) { 
                     chunkDisplayTitle += ` (Original IDs ${firstObjOriginalId}-${lastObjOriginalId})`;
                } else { 
                     chunkDisplayTitle += ` (Original ID ${firstObjOriginalId})`;
                }
            } else { 
                chunkDisplayTitle += ` (Original ID ${firstObjOriginalId})`;
            }
        }
        
        let chunkContentString;
        if (objectsToGroup === 1 && currentGroupOfObjects.length === 1) {
            chunkContentString = JSON.stringify(currentGroupOfObjects[0], null, 2);
        } else {
            chunkContentString = JSON.stringify(currentGroupOfObjects, null, 2);
        }

        let topText = addToTop.replace(/\$X/g, newChunkPartNumberForPlaceholders).replace(/\$Y/g, totalNewChunks);
        let bottomText = addToBottom.replace(/\$X/g, newChunkPartNumberForPlaceholders).replace(/\$Y/g, totalNewChunks);

        let finalChunk = "";
        if (topText) finalChunk += topText + '\n\n';
        finalChunk += chunkContentString;
        if (bottomText) finalChunk += '\n\n' + bottomText;

        displayChunk(finalChunk.trim(), chunkDisplayTitle, container);
      }
    }

    function chunkPlainTextInput(addToTop, addToBottom, container) {
      const plainTextInputArea = document.getElementById('plainTextInputArea');
      const maxCharsInput = document.getElementById('maxChars');
      if (!plainTextInputArea || !maxCharsInput) { alert("Plain text elements not found."); hideLoading(); return; }
      
      // Use the currently displayed text in the textarea, which might have been formatted
      const text = plainTextInputArea.value; 
      const maxChars = parseInt(maxCharsInput.value);

      if (!text.trim()) { alert("Plain text input is empty."); hideLoading(); return; }
      if (isNaN(maxChars) || maxChars <= 0) { alert("Max characters must be positive."); hideLoading(); return; }

      const paragraphs = text.split('\n'); // Split by single newline, as "pretty" format uses double newlines between paragraphs
      const chunks = [];
      let currentChunk = "";

      for (const paragraph of paragraphs) {
        // Calculate length if paragraph is added. Consider current chunk might be empty.
        // A newline is added between currentChunk and paragraph IF currentChunk is not empty AND paragraph is not empty.
        // The "pretty" format already ensures paragraphs are separated by double newlines (which means a single empty string paragraph).
        // So, we mainly check currentChunk length.
        
        const lengthWithParagraph = currentChunk.length + (currentChunk.length > 0 && paragraph.length > 0 ? 1 : 0) + paragraph.length;

        if (currentChunk.length > 0 && lengthWithParagraph > maxChars && paragraph.length <= maxChars) {
          // Current chunk + new paragraph exceeds maxChars, but new paragraph itself fits.
          // So, push current chunk and start new chunk with the paragraph.
          chunks.push(currentChunk.trim());
          currentChunk = paragraph;
        } else if (lengthWithParagraph <= maxChars) {
          // Fits, or paragraph is empty (like a blank line from double newline split)
          if (currentChunk.length > 0) {
            if (paragraph.length > 0) { // Only add newline if paragraph isn't empty
                currentChunk += '\n' + paragraph;
            } else { // if paragraph is empty, means it was a double newline. Add one newline.
                currentChunk += '\n';
            }
          } else {
            currentChunk = paragraph; // Start new chunk
          }
        } else { 
          // Current chunk + new paragraph exceeds maxChars, AND new paragraph itself exceeds maxChars.
          // This means the paragraph is too long. Push current chunk (if any), then push the long paragraph as its own chunk.
          if (currentChunk.trim()) {
            chunks.push(currentChunk.trim());
          }
          chunks.push(paragraph); // The long paragraph becomes its own chunk
          currentChunk = ""; 
        }
      }
      if (currentChunk.trim()) chunks.push(currentChunk.trim());


      const totalChunks = chunks.length;
      const digits = String(totalChunks).length > 0 ? String(totalChunks).length : 1;
      chunks.forEach((chunk, index) => {
        const partNumber = String(index + 1).padStart(digits, '0');
        let topText = addToTop.replace(/\$X/g, partNumber).replace(/\$Y/g, totalChunks);
        let bottomText = addToBottom.replace(/\$X/g, partNumber).replace(/\$Y/g, totalChunks);
        let finalChunk = "";
        if (topText) finalChunk += topText + '\n\n';
        finalChunk += chunk;
        if (bottomText) finalChunk += '\n\n' + bottomText;
        displayChunk(finalChunk.trim(), `Part ${partNumber}`, container);
      });
    }

    function displayChunk(content, title, container) {
        const chunkContainerDiv = document.createElement('div');
        chunkContainerDiv.classList.add('chunk-container');
        const chunkTitleDiv = document.createElement('div');
        chunkTitleDiv.classList.add('chunk-title');
        chunkTitleDiv.textContent = title;
        const textareaWrapper = document.createElement('div');
        textareaWrapper.classList.add('chunk-textarea-wrapper');
        const chunkTextarea = document.createElement('textarea');
        chunkTextarea.value = content;
        chunkTextarea.readOnly = true;
        textareaWrapper.appendChild(chunkTextarea);
        const copyButton = document.createElement('button');
        copyButton.classList.add('copy-button');
        copyButton.innerHTML = 'Copy<span class="tick" style="display:none;"> ✔️</span>';
        copyButton.addEventListener('click', function () {
          copyToClipboard(chunkTextarea.value, copyButton);
        });
        chunkContainerDiv.appendChild(chunkTitleDiv);
        chunkContainerDiv.appendChild(textareaWrapper);
        chunkContainerDiv.appendChild(copyButton);
        container.appendChild(chunkContainerDiv);
    }

    function copyToClipboard(text, buttonElement) {
      const hiddenInput = document.createElement('textarea');
      hiddenInput.value = text;
      document.body.appendChild(hiddenInput);
      hiddenInput.select();
      hiddenInput.setSelectionRange(0, 99999); // For mobile devices
      let success = false;
      try { 
          success = document.execCommand('copy'); 
          if (success && buttonElement) {
              updateButtonState(buttonElement);
          }
      } 
      catch (err) { 
          console.warn('Fallback: execCommand copy failed:', err); 
          success = false; // Ensure success is false if execCommand fails
      }
      
      // If execCommand failed or wasn't fully supported, try navigator.clipboard
      if (!success && navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text)
            .then(() => { 
                if (buttonElement) updateButtonState(buttonElement); 
            })
            .catch(err => {
                console.error('Async copy failed:', err);
                alert('Failed to copy text. Your browser might not support this feature or there was an error.');
            });
      } else if (!success) {
          // If both methods failed
          alert('Failed to copy text. Please try manual copy.');
      }
      document.body.removeChild(hiddenInput);
    }
  </script>
</body>
</html>
