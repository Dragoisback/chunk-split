<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text/JSON Chunker Pro</title>
  <style>
    :root {
      --bg-color: #f8f9fa;
      --fg-color: #ffffff;
      --text-color: #212529;
      --text-muted-color: #6c757d;
      --border-color: #dee2e6;
      --border-color-light: #e9ecef;
      --primary-color: #0d6efd;
      --primary-hover-color: #0b5ed7;
      --success-color: #198754;
      --success-hover-color: #157347;
      --danger-color: #dc3545;
      --danger-hover-color: #bb2d3b;
      --warning-color: #ffc107;
      --info-color: #0dcaf0;
      --secondary-color: #6c757d;
      --secondary-hover-color: #5c636a;
      --font-sans-serif: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      --font-monospace: 'Courier New', Courier, monospace;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
      --border-radius: 0.375rem;
    }

    body.dark-mode {
      --bg-color: #121212;
      --fg-color: #1e1e1e;
      --text-color: #e8eaed;
      --text-muted-color: #9aa0a6;
      --border-color: #444;
      --border-color-light: #2a2a2a;
    }

    body {
      font-family: var(--font-sans-serif);
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    
    .main-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 2rem;
        padding: 1rem;
        max-width: 1600px;
        margin: 0 auto;
    }

    @media (min-width: 1024px) {
        .main-container {
            grid-template-columns: minmax(450px, 1fr) 1.5fr;
        }
        #output-column {
             max-height: calc(100vh - 5rem);
             overflow-y: auto;
             padding-right: 1rem;
        }
    }

    /* --- Header --- */
    .app-header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      background-color: var(--fg-color);
      border-bottom: 1px solid var(--border-color);
      position: sticky; top: 0; z-index: 20;
    }
    .app-header h1 { margin: 0; font-size: 1.5rem; }
    
    .header-controls { display: flex; align-items: center; gap: 1rem; }
    
    /* --- General Elements --- */
    h3 { margin-top: 0; color: var(--primary-color); }
    p { font-size:0.9em; color: var(--text-muted-color); margin-top: 5px; line-height: 1.5; }
    textarea, input, select {
        width: 100%; box-sizing: border-box; padding: 8px; border: 1px solid var(--border-color);
        border-radius: var(--border-radius); background-color: var(--bg-color); color: var(--text-color);
        font-family: var(--font-monospace);
        margin-bottom: 5px; font-size: 14px;
    }
    textarea { resize: vertical; }

    /* --- Collapsible Fieldset Styling --- */
    .collapsible-fieldset {
        border: 1px solid var(--border-color); border-radius: var(--border-radius);
        background-color: var(--fg-color); box-shadow: var(--shadow-sm);
        margin-bottom: 1.5rem;
    }
    .fieldset-header {
        display: flex; justify-content: space-between; align-items: center;
        padding: 0.75rem 1rem; cursor: pointer; user-select: none;
        border-bottom: 1px solid var(--border-color-light);
    }
    .fieldset-header h3 { margin: 0; font-size: 1.1rem; color: var(--text-color); pointer-events: none; }
    .fieldset-content { padding: 1rem; border-top: 1px solid var(--border-color); display: block; }
    .collapsible-fieldset.collapsed .fieldset-content { display: none; }
    .collapsible-fieldset.collapsed .fieldset-header { border-bottom: none; }
    .toggle-icon { transition: transform 0.2s; pointer-events: none; }
    .collapsible-fieldset.collapsed .toggle-icon { transform: rotate(-90deg); }


    /* --- Mode Switcher --- */
    .mode-switcher { display: flex; border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden; }
    .mode-switcher button { flex: 1; padding: 0.5rem; background: transparent; border: none; cursor: pointer; color: var(--text-muted-color); font-weight: bold; font-size: 0.9rem; }
    .mode-switcher button.active { background-color: var(--primary-color); color: white; }

    /* --- Inputs and Controls --- */
    .input-container { margin-bottom: 1rem; }
    .input-container label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--text-color); }
    .input-container label.inline-label { display: inline; margin-left: 5px; font-weight: normal; }

    .textarea-with-actions { position: relative; }
    .textarea-actions { position: absolute; top: 4px; right: 5px; display: flex; gap: 4px; background-color: var(--fg-color); padding: 2px; border-radius: 4px; opacity: 0.8; }
    .textarea-action-btn { background: var(--border-color-light); border: 1px solid var(--border-color); color: var(--text-muted-color); padding: 2px 6px; font-size: 11px; border-radius: 4px; cursor: pointer; }
    .textarea-action-btn:hover { background: var(--primary-color); color: white; border-color: var(--primary-hover-color); }

    /* JSON Input Specifics */
    .json-chapter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; gap: 8px; }
    .json-chapter-header label { flex-grow: 1; font-weight: normal; }
    .json-chapter-input-container { border: 1px dashed var(--border-color); padding: 10px; margin-bottom: 10px; border-radius: var(--border-radius); background-color: var(--bg-color); }

    /* Find & Replace Specifics */
    #findReplacePairsContainer { max-height: 250px; overflow-y: auto; padding-right: 5px; }
    .find-replace-pair { display: flex; align-items: center; margin-bottom: 8px; gap: 8px; }
    .find-replace-pair .arrow { flex-shrink: 0; }
    
    /* --- Buttons --- */
    button, .button {
      padding: 10px 15px; color: white; border: none; border-radius: var(--border-radius); cursor: pointer;
      font-size: 16px; transition: background-color 0.2s ease, transform 0.1s ease; white-space: nowrap;
      display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
    }
    button:active, .button:active { transform: scale(0.98); }
    .btn-primary { background-color: var(--primary-color); }
    .btn-primary:hover { background-color: var(--primary-hover-color); }
    .btn-success { background-color: var(--success-color); }
    .btn-success:hover { background-color: var(--success-hover-color); }
    .btn-secondary { background-color: var(--secondary-color); color: white; }
    .btn-secondary:hover { background-color: var(--secondary-hover-color); }
    .btn-danger { background-color: var(--danger-color); }
    .btn-danger:hover { background-color: var(--danger-hover-color); }
    .btn-warning { background-color: var(--warning-color); color: #333; }
    .btn-warning:hover { background-color: #e0a800; }
    .btn-info { background-color: var(--info-color); color: white; }
    .btn-info:hover { background-color: #0aa3bf; }
    .btn-sm { padding: 5px 10px; font-size: 12px; }
    .btn-icon { padding: 0.5rem; }
    .btn-block { width: 100%; display: block; }
    button:disabled { background-color: #ccc !important; cursor: not-allowed; }
    body.dark-mode button:disabled { background-color: #555 !important; }

    /* --- Output Section --- */
    #output-column { display: none; }
    #outputControls {
      display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
      padding: 10px; background-color: var(--fg-color); border-radius: var(--border-radius);
      border: 1px solid var(--border-color); margin-bottom: 1rem; position: sticky; top: 60px; z-index: 10;
    }
    #outputControls h4 { margin: 0; padding: 0; color: var(--primary-color); }

    .chunk-container {
      margin-bottom: 1rem; display: flex; align-items: flex-start; background-color: var(--fg-color);
      padding: 1rem; border-radius: var(--border-radius); border: 1px solid var(--border-color);
      box-shadow: var(--shadow-sm); gap: 1rem; transition: background-color 0.3s, border-color 0.3s;
    }
    .chunk-container.copied { border-color: var(--success-color); background-color: #1987541a; }
    .chunk-title {
        font-weight: bold; min-width: 90px; padding-top: 8px; color: var(--primary-color);
        flex-shrink: 0; font-size: 0.9em; text-align: right;
    }
    .chunk-textarea-wrapper textarea { background-color: var(--bg-color); }
    .button-action-wrapper { display: flex; flex-direction: column; align-items: center; gap: 5px; flex-shrink: 0; }
    .copy-count-display { font-size: 0.8em; color: var(--text-muted-color); }

    /* --- Status & Indicators --- */
     #loadingIndicator { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 25px; background-color: rgba(0, 0, 0, 0.8); color: white; border-radius: 8px; z-index: 1000; font-size: 1.1em; box-shadow: var(--shadow-md); }
     .status-message { font-size: 0.85em; margin-top: 4px; display: inline-block; padding: 5px 8px; border-radius: 4px; border: 1px solid transparent;}
     .status-success { color: #0f5132; background-color: #d1e7dd; border-color: #badbcc;}
     .status-error   { color: #842029; background-color: #f8d7da; border-color: #f5c2c7;}
     body.dark-mode .status-success { background-color: #032d18; color: #75b798; border-color: #198754; }
     body.dark-mode .status-error   { background-color: #381114; color: #f1aeb5; border-color: #842029; }
     #scrollToTopBtn { display: none; position: fixed; bottom: 20px; right: 30px; z-index: 99; opacity: 0.7; }
     #scrollToTopBtn:hover { opacity: 1; }
     .info-counter { background-color: var(--border-color-light); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size:0.9em; }
    
  </style>
</head>

<body>
  
  <header class="app-header">
    <h1>Chunker Pro</h1>
    <div class="header-controls">
      <span id="mainStatus" class="status-message" style="display:none;"></span>
      <button id="theme-toggle" class="button btn-secondary btn-sm btn-icon" title="Toggle Dark/Light Theme">🌓</button>
      <button id="resetAllButton" class="button btn-danger btn-sm" title="Clear all settings and inputs, reload page">Reset All</button>
    </div>
  </header>

  <main class="main-container">
    <div id="settings-column">
      
      <div class="collapsible-fieldset">
        <div class="fieldset-header">
          <h3>1. Input Mode & Source</h3>
          <span class="toggle-icon">▼</span>
        </div>
        <div class="fieldset-content">
          <div class="mode-switcher" id="modeSwitcher">
            <button data-mode="json" class="active">JSON Objects</button>
            <button data-mode="text">Plain Text</button>
          </div>
          <input type="hidden" id="splitModeSelect" value="json">
        </div>
      </div>
      
      <div id="jsonModeSections">
        <div class="collapsible-fieldset">
          <div class="fieldset-header"><h3>2. JSON Input Chapters</h3> <span class="toggle-icon">▼</span></div>
          <div class="fieldset-content">
            <p>Add one or more JSON array "chapters". Content from all valid inputs will be combined.</p>
            <div id="jsonInputsContainer"></div>
            <div style="display:flex; align-items:center; gap:10px; margin-top:10px;">
              <button id="addJsonChapterButton" class="button btn-primary btn-sm">+ Add Input</button>
              <button id="clearAllJsonButton" class="button btn-secondary btn-sm">Clear All</button>
              <span id="jsonObjectsCount" class="info-counter" style="margin-left: auto;">Total Objects: 0</span>
            </div>
            <div class="input-container" style="margin-top: 1rem;">
              <label for="jsonObjectsPerChunk">Combine objects per chunk:</label>
              <select id="jsonObjectsPerChunk">
                <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="10">10</option><option value="20">20</option>
              </select>
            </div>
          </div>
        </div>
        <div class="collapsible-fieldset">
          <div class="fieldset-header"><h3>3. Paired Find & Replace</h3><span class="toggle-icon">▼</span></div>
          <div class="fieldset-content">
            <p>Applied to <code>object.terms[any].translation</code> on a copy of the data during splitting.</p>
            <div style="display:flex; gap: 15px; margin-bottom: 10px;">
              <label class="inline-label"><input type="checkbox" id="applyRulesCheckbox"> Apply Rules</label>
              <label class="inline-label"><input type="checkbox" id="caseInsensitiveCheckbox"> Case-insensitive</label>
            </div>
            <div id="findReplacePairsContainer"></div>
            <div style="margin-top:10px;">
              <button id="addFindReplacePairButton" class="button btn-success btn-sm">+ Add Rule</button>
              <span id="glossaryReplaceStatus" class="status-message" style="margin-left: 10px; display: none;"></span>
            </div>
          </div>
        </div>
      </div>

      <div id="plainTextModeSections" style="display:none;">
        <div class="collapsible-fieldset">
          <div class="fieldset-header"><h3>2. Plain Text Input</h3> <span class="toggle-icon">▼</span></div>
          <div class="fieldset-content">
            <p>Text will be split by max characters, intelligently breaking at sentence or word boundaries.</p>
            <div style="text-align: right; margin-bottom: 5px;">
              <span id="plainTextInfo" class="info-counter">Chars: 0 / Approx. Chunks: 0</span>
            </div>
            <textarea id="plainTextInputArea" placeholder="Paste plain text here..." style="height: 250px;"></textarea>
            <span id="plainTextStatus" class="status-message"></span>
            <div class="input-container">
              <label for="formatSelect">Format text (before splitting):</label>
              <select id="formatSelect">
                  <option value="as-is">Show text as is</option>
                  <option value="pretty">Pretty (trim lines, join with double newlines)</option>
              </select>
            </div>
            <div class="input-container">
              <label for="maxChars">Max characters per chunk:</label>
              <input type="number" id="maxChars" value="1800" min="1">
            </div>
          </div>
        </div>
      </div>

      <div class="collapsible-fieldset">
        <div class="fieldset-header">
          <h3 id="commonSectionHeader">4. Chunk Header & Footer</h3>
          <span class="toggle-icon">▼</span>
        </div>
        <div class="fieldset-content">
          <p>Use <code>$X</code> for current part number and <code>$Y</code> for total parts.</p>
          <div class="input-container">
            <label for="addToTop">Add to top of each chunk:</label>
            <div class="textarea-with-actions">
              <div class="textarea-actions">
                <button class="textarea-action-btn" onclick="copyFromTextarea('addToTop')">Copy</button>
                <button class="textarea-action-btn" onclick="pasteIntoTextarea('addToTop')">Paste</button>
                <button class="textarea-action-btn" onclick="clearTextarea('addToTop')">Clear</button>
              </div>
              <textarea id="addToTop" placeholder="Text to add to the top..." style="height:120px;"></textarea>
            </div>
          </div>
          <div class="input-container">
            <label for="addToBottom">Add to bottom of each chunk:</label>
            <div class="textarea-with-actions">
              <div class="textarea-actions">
                <button class="textarea-action-btn" onclick="copyFromTextarea('addToBottom')">Copy</button>
                <button class="textarea-action-btn" onclick="pasteIntoTextarea('addToBottom')">Paste</button>
                <button class="textarea-action-btn" onclick="clearTextarea('addToBottom')">Clear</button>
              </div>
              <textarea id="addToBottom" placeholder="Text to add to the bottom..." style="height:80px;"></textarea>
            </div>
          </div>
        </div>
      </div>

      <button id="mainSplitButton" class="button btn-success btn-block" style="font-size: 1.2rem; padding: 12px;">⚙️ Process & Split</button>
      <span id="processStatus" class="status-message" style="display:none;"></span>

    </div>

    <div id="output-column">
      <div id="outputControls" style="display:none;">
        <h4 id="outputSummary">Output</h4>
        <button id="copyNextButton" class="button btn-warning btn-sm">⭐ Copy NEXT Uncopied</button>
        <button id="copyAllButton" class="button btn-info btn-sm">Copy ALL Chunks</button>
        <button id="clearOutputButton" class="button btn-secondary btn-sm">Clear Output</button>
      </div>
      <div id="chunkedTextContainer"></div>
    </div>
  </main>
  
  <div id="loadingIndicator">Processing...</div>
  <button id="scrollToTopBtn" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="Go to top" class="button btn-primary">⬆️</button>


  <script>
    // --- State & Config ---
    let lastClickedButton = null;
    let jsonChapterInputIdCounter = 0;
    const STATE_KEY = 'chunkerAppState_V3';
    const statusTimeouts = {};

    const newDefaultAddToTopPreset = `"Before replying YOU must think. From now onwards, in your thinking process/thought process/strategizing instead of YOU doing regular thinking, it is imperative that YOU MUST open and activate "Super-Duper-Hyper Thinking Mode". In this mode, you are obligated to: 1) engage in extreme exceptionally extreme thinking 2) engage in extreme exceptionally extreme extensivity 3) extreme exceptionally extreme extensity analysis"

1. Analyze raw Passage and Translation: 
   - FOR EACH line, summarize its meaning and compare it very thoroughly to the translation.
   - Note if the translation matches the original or deviates, explaining any ambiguities or potential errors.
   - Check if phrases are adapted naturally (e.g., idiomatic expressions retain flavor without literal awkwardness or being too formal and literal).

2. Identify Errors:
  - Spot issues related to:
     - Accuracy: Missing, Overly condensed sentences or lines, added, or incorrect glossary terms
        * Note : Only ignore glossary if certain it's wrong, if certain its not appropriately conveying the meaning or have grammatical error
  - Logic: Pronoun mistakes, wrong speaker, or mixed-up character names.
  - Language: Awkward or unnatural English or Overly condensed sentences.
  - Analyze every line thoroughly.

3. Verify Errors: 
   - Double-check all identified errors, ensuring each has clear evidence.
   - keep all the minor and major valid errors.
   - Verify if the tone matches the context (majestic for epic scenes, colloquial for dialogue).

4. Fix the Translation :
  - Correct the verified errors and use English major level proficiency to make the prose flows smoothly with Rich descriptive and faithful rendering of key dialogue
  - Don't use Only colon and bullet points in your translation and while during their removal make sure the English is natural and idiomatic.
  - "DO NOT transliterate the honorifics unless the glossary says so. For example, you should use 'Senior Brother X' instead of 'X-shixiong'."
  - Do not over condense the sentence and dialogue while making sure the English is natural and idiomatic.
  - Where necessary for comprehension, add brief, unobtrusive context or explanations for cultural terms or implied meanings. Avoid overly complex or literary phrasing if it sacrifices clarity

5. Give only the Fixed human like English translation as output and not the Whole JSON format. and Separately mention when a glossary is wrong or have variations and is fixed in the output.`;
	
    const defaultState = {
        theme: 'light',
        splitMode: 'json',
        maxChars: '1800',
        addToTop: newDefaultAddToTopPreset,
        addToBottom: '---\nEnd of Part $X of $Y',
        formatSelect: 'pretty',
        jsonObjectsPerChunk: '1',
        plainText: '',
        jsonInputs: [''],
        findReplacePairs: [{find:"", replace:""}],
        applyRules: false,
        caseInsensitive: false,
        collapsedSections: [],
    };
    let currentAppState = {...defaultState};

    // --- Helpers & Utilities ---
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), delay);
        };
    }
    const debouncedSaveState = debounce(saveState, 500);
    const debouncedUpdateTotalJsonObjectCount = debounce(updateTotalJsonObjectCount, 400);
    const debouncedUpdatePlainTextInfo = debounce(updatePlainTextInfo, 400);

    function showStatus(elementId, message, type = 'success', timeout = 4000) {
        const element = document.getElementById(elementId);
        if (!element) return;
        if(statusTimeouts[elementId]) clearTimeout(statusTimeouts[elementId]);
        element.innerHTML = message;
        element.className = `status-message status-${type}`;
        element.style.display = 'inline-block';
        if (timeout > 0) {
            statusTimeouts[elementId] = setTimeout(() => {
                if(element) element.style.display = 'none';
                delete statusTimeouts[elementId];
            }, timeout);
        }
    }
    
    function showLoading() { document.getElementById('loadingIndicator').style.display = 'block'; }
    function hideLoading() {  document.getElementById('loadingIndicator').style.display = 'none'; }
    function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    
    function copyFromTextarea(id) {
        const textarea = document.getElementById(id);
        if (textarea) navigator.clipboard.writeText(textarea.value).then(() => showStatus('mainStatus', 'Copied!', 'success', 2000));
    }

    async function pasteIntoTextarea(id) {
        const textarea = document.getElementById(id);
        if (textarea) {
            try {
                textarea.value = await navigator.clipboard.readText();
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                showStatus('mainStatus', 'Pasted!', 'success', 2000);
            } catch (err) {
                showStatus('mainStatus', 'Paste failed.', 'error', 3000);
            }
        }
    }

    function clearTextarea(id) {
        const textarea = document.getElementById(id);
        if (textarea) {
            textarea.value = '';
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    async function pasteIntoJsonInput(button) {
        const textarea = button.closest('.json-chapter-input-container')?.querySelector('.json-chapter-input');
        if (textarea) {
            try {
                textarea.value = await navigator.clipboard.readText();
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                button.textContent = 'Pasted!';
                setTimeout(() => { button.textContent = 'Paste'; }, 1500);
            } catch (err) {
                button.textContent = 'Failed!';
                setTimeout(() => { button.textContent = 'Paste'; }, 1500);
            }
        }
    }
    
    // --- Theme Management ---
    function applyTheme(theme) {
        document.body.classList.toggle('dark-mode', theme === 'dark');
        document.getElementById('theme-toggle').textContent = theme === 'dark' ? '☀️' : '🌓';
    }

    function toggleTheme() {
        currentAppState.theme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
        applyTheme(currentAppState.theme);
        saveState();
    }

    // --- State Management ---
    function saveState() {
       currentAppState.splitMode = document.getElementById('splitModeSelect').value;
       currentAppState.maxChars = document.getElementById('maxChars').value;
       currentAppState.addToTop = document.getElementById('addToTop').value;
       currentAppState.addToBottom = document.getElementById('addToBottom').value;
       currentAppState.formatSelect = document.getElementById('formatSelect').value;
       currentAppState.jsonObjectsPerChunk = document.getElementById('jsonObjectsPerChunk').value;
       currentAppState.plainText = document.getElementById('plainTextInputArea').value;
       currentAppState.applyRules = document.getElementById('applyRulesCheckbox').checked;
       currentAppState.caseInsensitive = document.getElementById('caseInsensitiveCheckbox').checked;
       currentAppState.jsonInputs = Array.from(document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input')).map(t => t.value);
       currentAppState.findReplacePairs = Array.from(document.querySelectorAll('#findReplacePairsContainer .find-replace-pair')).map(p => ({
           find: p.querySelector('.find-text')?.value || "",
           replace: p.querySelector('.replace-text')?.value || ""
       })).filter(p => p.find || p.replace);
       currentAppState.collapsedSections = Array.from(document.querySelectorAll('.collapsible-fieldset.collapsed')).map(fs => fs.querySelector('h3').textContent.trim());

       try {
           localStorage.setItem(STATE_KEY, JSON.stringify(currentAppState));
       } catch (e) {
           console.error("LocalStorage save failed:", e);
           showStatus('mainStatus', 'Error saving settings.', 'error', 10000);
       }
    }

   function loadState() {
       try {
          const savedStateJSON = localStorage.getItem(STATE_KEY);
           if (savedStateJSON) {
              const savedState = JSON.parse(savedStateJSON);
              currentAppState = { ...defaultState, ...savedState };
           } else {
              currentAppState = {...defaultState};
           }
        } catch (e) {
           console.error("LocalStorage load failed:", e);
           currentAppState = {...defaultState};
        }
        
        applyTheme(currentAppState.theme);
        document.getElementById('splitModeSelect').value = currentAppState.splitMode;
        document.getElementById('maxChars').value = currentAppState.maxChars;
        document.getElementById('addToTop').value = currentAppState.addToTop;
        document.getElementById('addToBottom').value = currentAppState.addToBottom;
        document.getElementById('formatSelect').value = currentAppState.formatSelect;
        document.getElementById('jsonObjectsPerChunk').value = currentAppState.jsonObjectsPerChunk;
        document.getElementById('plainTextInputArea').value = currentAppState.plainText;
        document.getElementById('applyRulesCheckbox').checked = !!currentAppState.applyRules;
        document.getElementById('caseInsensitiveCheckbox').checked = !!currentAppState.caseInsensitive;
        
        if (currentAppState.collapsedSections) {
             document.querySelectorAll('.collapsible-fieldset').forEach(fs => {
                const title = fs.querySelector('h3').textContent.trim();
                fs.classList.toggle('collapsed', currentAppState.collapsedSections.includes(title));
             });
        }
        
        document.getElementById('jsonInputsContainer').innerHTML = '';
        jsonChapterInputIdCounter = 0;
        if (currentAppState.jsonInputs && currentAppState.jsonInputs.length > 0) {
             currentAppState.jsonInputs.forEach(content => addJsonChapterInput(content, false));
        } else {
             addJsonChapterInput('', false);
        }
        
        document.getElementById('findReplacePairsContainer').innerHTML = '';
        if (currentAppState.findReplacePairs && currentAppState.findReplacePairs.length > 0) {
             currentAppState.findReplacePairs.forEach(pair => addFindReplacePair(pair.find, pair.replace, false));
        } else {
             addFindReplacePair("","", false);
        }
   }
   
    function resetAllToDefaults() {
         if(confirm("Are you sure you want to clear all inputs and settings? This will reload the page.")) {
            localStorage.removeItem(STATE_KEY);
            window.location.reload();
         }
     }
    
    // --- UI Element Management ---
    function toggleInputSections() {
        const splitMode = document.getElementById('splitModeSelect').value;

        document.querySelectorAll('.mode-switcher button').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === splitMode));
        document.getElementById('jsonModeSections').style.display = (splitMode === 'json' ? 'block' : 'none');
        document.getElementById('plainTextModeSections').style.display = (splitMode === 'text' ? 'block' : 'none');
        document.getElementById('commonSectionHeader').textContent = (splitMode === 'json' ? '4. Chunk Header & Footer' : '3. Chunk Header & Footer');
        
        clearOutput();
        if (splitMode === 'json') updateTotalJsonObjectCount(); else updatePlainTextInfo();
        debouncedSaveState();
    }
    
    function addJsonChapterInput(content = '', save = true) {
        jsonChapterInputIdCounter++;
        const container = document.getElementById('jsonInputsContainer');
        const chapterDiv = document.createElement('div');
        chapterDiv.className = 'json-chapter-input-container';
        chapterDiv.innerHTML = `
         <div class="json-chapter-header">
            <label>JSON Input ${jsonChapterInputIdCounter}</label>
            <span class="json-chapter-status status-message">Objects: 0</span>
            <button type="button" class="button btn-secondary btn-sm" onclick="pasteIntoJsonInput(this)">Paste</button>
            <button type="button" class="button btn-danger btn-sm" onclick="removeJsonChapterInput(this)">Remove</button>
         </div>
         <textarea class="json-chapter-input" placeholder='[ { "id":1, ... } ]'>${content}</textarea>`;
        const textarea = chapterDiv.querySelector('textarea');
        const statusSpan = chapterDiv.querySelector('.json-chapter-status');
        textarea.addEventListener('input', () => {
            updateIndividualJsonCount(textarea, statusSpan);
            debouncedUpdateTotalJsonObjectCount();
            debouncedSaveState();
        });
        container.appendChild(chapterDiv);
        updateIndividualJsonCount(textarea, statusSpan);
        if (save) {
            updateTotalJsonObjectCount();
            debouncedSaveState();
        }
    }

    function removeJsonChapterInput(buttonElement) {
        buttonElement.closest('.json-chapter-input-container')?.remove();
        updateTotalJsonObjectCount();
        if (document.querySelectorAll('#jsonInputsContainer .json-chapter-input-container').length === 0) {
            addJsonChapterInput('', false);
        }
        debouncedSaveState();
    }
    
    function clearAllJsonInputs() {
        document.getElementById('jsonInputsContainer').innerHTML = '';
        jsonChapterInputIdCounter = 0;
        addJsonChapterInput('', false);
        updateTotalJsonObjectCount();
        debouncedSaveState();
    }

    function updateIndividualJsonCount(textarea, statusSpan) {
        const jsonString = textarea.value.trim();
        statusSpan.className = 'json-chapter-status status-message';
        if (!jsonString) { statusSpan.textContent = 'Objects: 0'; return 0; }
        try {
            if (!jsonString.startsWith('[')) throw new Error("Not Array");
            const jsonData = JSON.parse(jsonString);
            if (!Array.isArray(jsonData)) throw new Error("Not Array");
            statusSpan.textContent = `Objects: ${jsonData.length}`;
            statusSpan.classList.add('status-success');
        } catch (e) {
            statusSpan.textContent = e.message === "Not Array" ? 'Error: Must be an Array []' : 'Error: Invalid JSON';
            statusSpan.classList.add('status-error');
        }
    }

    function updateTotalJsonObjectCount() {
        let totalObjects = 0;
        document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input').forEach(textarea => {
             const jsonString = textarea.value.trim();
             try {
                 if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                    const jsonData = JSON.parse(jsonString);
                    if (Array.isArray(jsonData)) totalObjects += jsonData.length;
                 }
             } catch (e) { /* ignore invalid json */ }
        });
        document.getElementById('jsonObjectsCount').textContent = `Total Objects: ${totalObjects}`;
    }

    function addFindReplacePair(findVal = "", replaceVal = "", save=true) {
        const container = document.getElementById('findReplacePairsContainer');
        const pairDiv = document.createElement('div');
        pairDiv.className = 'find-replace-pair';
        pairDiv.innerHTML = `
            <input type="text" class="find-text" placeholder="Find" value="${findVal}">
            <span class="arrow">➔</span>
            <input type="text" class="replace-text" placeholder="Replace" value="${replaceVal}">
            <button type="button" class="button btn-danger btn-sm" onclick="removeFindReplacePair(this)">－</button>`;
        pairDiv.querySelectorAll('input').forEach(input => input.addEventListener('input', debouncedSaveState));
        container.appendChild(pairDiv);
        if(save) debouncedSaveState();
    }

    function removeFindReplacePair(button) {
        button.parentElement.remove();
        if (document.querySelectorAll('#findReplacePairsContainer .find-replace-pair').length === 0) {
             addFindReplacePair("","", false);
        }
        debouncedSaveState();
    }

    function updatePlainTextInfo() {
        const text = document.getElementById('plainTextInputArea').value;
        const maxChars = parseInt(document.getElementById('maxChars').value, 10);
        const charCount = text.length;
        let chunks = (charCount > 0 && maxChars > 0) ? Math.ceil(charCount / maxChars) : (charCount > 0 ? 1 : 0);
        document.getElementById('plainTextInfo').textContent = `Chars: ${charCount} / Approx. Chunks: ${chunks}`;
        if (isNaN(maxChars) || maxChars <= 0) {
            showStatus('plainTextStatus', "Max characters must be > 0", 'error');
        } else {
            showStatus('plainTextStatus', "", 'success', 1);
        }
    }

    function formatPlainText() {
      const formatSelect = document.getElementById('formatSelect').value;
      const textArea = document.getElementById('plainTextInputArea');
      if (formatSelect === 'pretty') {
         textArea.value = currentAppState.plainText.split('\n').map(p => p.trim()).filter(p => p).join('\n\n');
      } else {
         textArea.value = currentAppState.plainText;
      }
       updatePlainTextInfo();
       debouncedSaveState();
    }
    
    // --- Core Logic ---
    function processAndChunk() {
       clearOutput();
       showLoading();
       setTimeout(() => {
        try {
          const splitMode = document.getElementById('splitModeSelect').value;
          const addToTop = document.getElementById('addToTop').value;
          const addToBottom = document.getElementById('addToBottom').value;
          const container = document.getElementById('chunkedTextContainer');
          let chunkCount = 0;
          
          if (splitMode === 'json') {
             const { data, success, allEmpty } = getAllCombinedJsonData();
             if (allEmpty) throw new Error("All JSON inputs are empty.");
             if (!success) throw new Error("Invalid JSON found. See errors on input boxes.");
             const { data: processedJsonData } = applyGlossaryRules(data);
             chunkCount = chunkJsonInput(processedJsonData, addToTop, addToBottom, container);
          } else {
             const text = document.getElementById('plainTextInputArea').value;
             const maxChars = parseInt(document.getElementById('maxChars').value);
             if (!text.trim()) throw new Error("Plain text input is empty.");
             if (isNaN(maxChars) || maxChars <= 0) throw new Error("Max characters must be > 0.");
             chunkCount = chunkPlainTextInput(text, maxChars, addToTop, addToBottom, container);
          }
           if (chunkCount > 0) {
                document.getElementById('output-column').style.display = 'block';
                document.getElementById('outputControls').style.display = 'flex';
                document.getElementById('outputSummary').textContent = `Output: ${chunkCount} Chunk${chunkCount === 1 ? '' : 's'}`;
                document.getElementById('copyNextButton').disabled = false;
                document.getElementById('copyAllButton').disabled = false;
                showStatus('processStatus', `Success: Generated ${chunkCount} chunks.`, 'success');
           } else {
                throw new Error("No chunks were generated from the input.");
           }
        } catch (error) {
           showStatus('processStatus', error.message, 'error', 8000);
        } finally {
          hideLoading();
        }
      }, 50);
    }

    function getAllCombinedJsonData() {
        let combinedData = [], allInputsValid = true, allEmpty = true;
        document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input').forEach(textarea => {
            const jsonString = textarea.value.trim();
            if (!jsonString) return;
            allEmpty = false;
            try {
                if (!jsonString.startsWith('[')) throw new Error();
                const jsonData = JSON.parse(jsonString);
                if (Array.isArray(jsonData)) {
                    combinedData = combinedData.concat(jsonData);
                } else { throw new Error(); }
            } catch (e) { allInputsValid = false; }
        });
        return { data: combinedData, success: allInputsValid, allEmpty };
    }

    function applyGlossaryRules(jsonData) {
        if (!document.getElementById('applyRulesCheckbox').checked || !jsonData || jsonData.length === 0) {
            return { data: jsonData, count: 0 };
        }
        const flags = document.getElementById('caseInsensitiveCheckbox').checked ? 'gi' : 'g';
        const rules = currentAppState.findReplacePairs.map(p => {
             if (!p.find) return null;
             try { return { findRegExp: new RegExp(escapeRegExp(p.find), flags), replace: p.replace }; }
             catch (e) { return null; }
        }).filter(Boolean);

        if (rules.length === 0) return { data: jsonData, count: 0 };
        
        const processedData = JSON.parse(JSON.stringify(jsonData));
        let totalInstancesReplaced = 0;

        processedData.forEach(obj => {
            if (obj && Array.isArray(obj.terms)) {
                obj.terms.forEach(term => {
                    if (term && typeof term.translation === 'string') {
                        rules.forEach(rule => {
                            const matches = term.translation.match(rule.findRegExp);
                            if(matches) {
                                totalInstancesReplaced += matches.length;
                                term.translation = term.translation.replace(rule.findRegExp, rule.replace);
                            }
                        });
                    }
                });
            }
        });
        if (totalInstancesReplaced > 0) {
            showStatus('glossaryReplaceStatus', `Applied ${totalInstancesReplaced} replacements.`, 'success');
        } else {
            showStatus('glossaryReplaceStatus', 'No matching terms found to replace.', 'info');
        }
        return { data: processedData, count: totalInstancesReplaced };
    }

    function chunkJsonInput(jsonData, addToTop, addToBottom, container) {
        const objectsToGroup = parseInt(document.getElementById('jsonObjectsPerChunk').value, 10) || 1;
        const totalChunks = Math.ceil(jsonData.length / objectsToGroup);
        for (let i = 0; i < jsonData.length; i += objectsToGroup) {
            const group = jsonData.slice(i, i + objectsToGroup);
            const partNum = (i / objectsToGroup) + 1;
            const title = `Seg ${partNum}/${totalChunks}\n(Items ${i + 1}-${i + group.length})`;
            const content = JSON.stringify(objectsToGroup === 1 && group.length === 1 ? group[0] : group, null, 2);
            const top = addToTop.replace(/\$X/g, partNum).replace(/\$Y/g, totalChunks);
            const bottom = addToBottom.replace(/\$X/g, partNum).replace(/\$Y/g, totalChunks);
            displayChunk([top, content, bottom].filter(Boolean).join('\n\n'), title, container);
        }
        return totalChunks;
    }
    
    function smartSplit(text, maxLength) {
        if (text.length <= maxLength) return [text];
        const chunks = []; let currentText = text;
        const breakChars = ['. ', '! ', '? ', '\n', ' ', ','];
        while (currentText.length > maxLength) {
            let breakPoint = -1;
            for(const char of breakChars) {
                const index = currentText.lastIndexOf(char, maxLength);
                if(index !== -1) { breakPoint = index + (char.trim() ? char.length : 0); break; }
            }
            if (breakPoint === -1) breakPoint = maxLength;
            chunks.push(currentText.substring(0, breakPoint).trim());
            currentText = currentText.substring(breakPoint).trim();
        }
        if (currentText) chunks.push(currentText);
        return chunks;
    }
    
    function chunkPlainTextInput(text, maxChars, addToTop, addToBottom, container) {
       let chunks = []; let currentChunk = "";
       text.split('\n').forEach(paragraph => {
           if (paragraph.length > maxChars) {
               if (currentChunk) chunks.push(currentChunk);
               chunks.push(...smartSplit(paragraph, maxChars));
               currentChunk = "";
               return;
           }
           if (currentChunk && (currentChunk.length + paragraph.length + 1 > maxChars)) {
                chunks.push(currentChunk);
                currentChunk = paragraph;
           } else {
               currentChunk = currentChunk ? `${currentChunk}\n${paragraph}` : paragraph;
           }
       });
       if (currentChunk) chunks.push(currentChunk);
       chunks = chunks.map(c => c.trim()).filter(Boolean);
       const totalChunks = chunks.length;
       chunks.forEach((chunk, index) => {
         const partNum = index + 1;
         const top = addToTop.replace(/\$X/g, partNum).replace(/\$Y/g, totalChunks);
         const bottom = addToBottom.replace(/\$X/g, partNum).replace(/\$Y/g, totalChunks);
         displayChunk([top, chunk, bottom].filter(Boolean).join('\n\n'), `Part ${partNum}/${totalChunks}`, container);
       });
       return totalChunks;
    }
    
    // --- Output & Copying ---
    function displayChunk(content, title, container) {
        const chunkDiv = document.createElement('div');
        chunkDiv.className = 'chunk-container';
        chunkDiv.dataset.copied = "false";
        chunkDiv.innerHTML = `
         <div class="chunk-title">${title.replace(/\n/g, '<br>')}</div>
         <div class="chunk-textarea-wrapper">
             <textarea readonly>${content}</textarea>
         </div>
         <div class="button-action-wrapper">
            <button class="button btn-primary copy-button" data-copy-count="0">Copy<span class="tick" style="display:none;"> ✔️</span></button>
            <span class="copy-count-display">(0)</span>
         </div>`;
        const copyButton = chunkDiv.querySelector('.copy-button');
        copyButton.addEventListener('click', function () {
            copyToClipboard(
                chunkDiv.querySelector('textarea').value, 
                this, 
                chunkDiv.querySelector('.copy-count-display')
            );
        });
        container.appendChild(chunkDiv);
    }
    
    function clearOutput() {
        document.getElementById('chunkedTextContainer').innerHTML = '';
        document.getElementById('output-column').style.display = 'none';
        document.getElementById('outputControls').style.display = 'none';
        lastClickedButton = null;
    }
    
    function updateCopyButtonState(button) {
      if (lastClickedButton && lastClickedButton !== button) {
         lastClickedButton.classList.remove('btn-success');
         lastClickedButton.classList.add('btn-primary');
         lastClickedButton.querySelector('.tick').style.display = 'none';
      }
      button.classList.remove('btn-primary');
      button.classList.add('btn-success');
      button.querySelector('.tick').style.display = 'inline-block';
      lastClickedButton = button;
    }
    
    function copyToClipboard(text, buttonEl, countEl) {
       navigator.clipboard.writeText(text).then(() => {
            updateCopyButtonState(buttonEl);
            const container = buttonEl.closest('.chunk-container');
            container.dataset.copied = "true";
            container.classList.add('copied');
            
            let count = parseInt(buttonEl.dataset.copyCount, 10) + 1;
            buttonEl.dataset.copyCount = count;
            countEl.textContent = `(${count})`;

            if (!document.querySelector('.chunk-container[data-copied="false"]')) {
                document.getElementById('copyNextButton').disabled = true;
            }
        }).catch(err => { showStatus('processStatus', 'Failed to copy text.', 'error'); });
    }
    
    function copyNextUncopied() {
        const nextContainer = document.querySelector('.chunk-container[data-copied="false"]');
        if(nextContainer) {
            nextContainer.querySelector('.copy-button').click();
            nextContainer.scrollIntoView({behavior: 'smooth', block: 'center'});
        }
    }
    
    function copyAllChunks() {
        const textareas = document.querySelectorAll('#chunkedTextContainer textarea');
        if (textareas.length === 0) return;
        const separator = "\n\n" + "-".repeat(30) + "\n\n";
        const allText = Array.from(textareas).map(ta => ta.value).join(separator);
        navigator.clipboard.writeText(allText).then(() => {
            showStatus('processStatus', `Copied all ${textareas.length} chunks!`, 'success');
            document.querySelectorAll('.chunk-container').forEach(div => {
                div.dataset.copied = "true";
                div.classList.add('copied');
            });
            document.getElementById('copyNextButton').disabled = true;
        });
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadState();
        
        // --- Event Listeners ---
        document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
        document.getElementById('resetAllButton').addEventListener('click', resetAllToDefaults);
        document.getElementById('mainSplitButton').addEventListener('click', processAndChunk);
        
        document.getElementById('modeSwitcher').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                document.getElementById('splitModeSelect').value = e.target.dataset.mode;
                toggleInputSections();
            }
        });
        
        document.querySelectorAll('.collapsible-fieldset .fieldset-header').forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('collapsed');
                debouncedSaveState();
            });
        });

        // JSON Mode Listeners
        document.getElementById('addJsonChapterButton').addEventListener('click', () => addJsonChapterInput());
        document.getElementById('clearAllJsonButton').addEventListener('click', clearAllJsonInputs);
        document.getElementById('addFindReplacePairButton').addEventListener('click', () => addFindReplacePair());
        document.getElementById('jsonObjectsPerChunk').addEventListener('change', debouncedSaveState);
        document.getElementById('applyRulesCheckbox').addEventListener('change', debouncedSaveState);
        document.getElementById('caseInsensitiveCheckbox').addEventListener('change', debouncedSaveState);

        // Plain Text Mode Listeners
        document.getElementById('plainTextInputArea').addEventListener('input', () => {
            currentAppState.plainText = document.getElementById('plainTextInputArea').value;
            debouncedUpdatePlainTextInfo();
            debouncedSaveState();
        });
        document.getElementById('maxChars').addEventListener('input', debouncedUpdatePlainTextInfo);
        document.getElementById('formatSelect').addEventListener('change', formatPlainText);

        // Common Listeners
        document.getElementById('addToTop').addEventListener('input', debouncedSaveState);
        document.getElementById('addToBottom').addEventListener('input', debouncedSaveState);
        
        // Output Listeners
        document.getElementById('clearOutputButton').addEventListener('click', clearOutput);
        document.getElementById('copyNextButton').addEventListener('click', copyNextUncopied);
        document.getElementById('copyAllButton').addEventListener('click', copyAllChunks);
        
        window.onscroll = () => {
            const btn = document.getElementById("scrollToTopBtn");
            const show = document.getElementById("output-column").style.display !== 'none' && document.documentElement.scrollTop > 200;
            btn.style.display = show ? "block" : "none";
        };

        // --- Final UI Setup ---
        toggleInputSections();
        clearOutput();
        showStatus('mainStatus', 'Ready!', 'success', 2500);
    });

  </script>
</body>
</html>
