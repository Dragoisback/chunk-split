<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text/JSON Chunker Pro</title>
  <style>
    :root {
      --bg-color: #f8f9fa;
      --fg-color: #ffffff;
      --text-color: #212529;
      --text-muted-color: #6c757d;
      --border-color: #dee2e6;
      --border-color-light: #e9ecef;
      --primary-color: #0d6efd;
      --primary-hover-color: #0b5ed7;
      --success-color: #198754;
      --success-hover-color: #157347;
      --danger-color: #dc3545;
      --danger-hover-color: #bb2d3b;
      --warning-color: #ffc107;
      --info-color: #0dcaf0;
      --secondary-color: #6c757d;
      --secondary-hover-color: #5c636a;
      --font-sans-serif: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      --font-monospace: 'Courier New', Courier, monospace;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
      --border-radius: 0.375rem;
    }

    body.dark-mode {
      --bg-color: #121212;
      --fg-color: #1e1e1e;
      --text-color: #e8eaed;
      --text-muted-color: #9aa0a6;
      --border-color: #444;
      --border-color-light: #2a2a2a;
    }

    body {
      font-family: var(--font-sans-serif);
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    
    .main-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 2rem;
        padding: 1rem;
        max-width: 1600px;
        margin: 0 auto;
    }

    @media (min-width: 1024px) {
        .main-container {
            grid-template-columns: minmax(450px, 1fr) 1.5fr;
        }
        #output-column {
             max-height: calc(100vh - 2rem);
             overflow-y: auto;
             padding-right: 1rem;
        }
    }

    /* --- Header --- */
    .app-header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      background-color: var(--fg-color);
      border-bottom: 1px solid var(--border-color);
    }
    .app-header h1 { margin: 0; font-size: 1.5rem; }
    
    .header-controls { display: flex; align-items: center; gap: 1rem; }
    
    /* --- General Elements --- */
    h3 { margin-top: 0; color: var(--primary-color); }
    p { font-size:0.9em; color: var(--text-muted-color); margin-top: 5px; line-height: 1.5; }
    textarea, input, select {
        width: 100%; box-sizing: border-box; padding: 8px; border: 1px solid var(--border-color);
        border-radius: var(--border-radius); background-color: var(--bg-color); color: var(--text-color);
        font-family: var(--font-monospace);
        margin-bottom: 5px; font-size: 14px;
    }
    textarea { resize: vertical; }

    /* --- Collapsible Fieldset Styling --- */
    .collapsible-fieldset {
        border: 1px solid var(--border-color); border-radius: var(--border-radius);
        background-color: var(--fg-color); box-shadow: var(--shadow-sm);
        margin-bottom: 1.5rem;
    }
    .fieldset-header {
        display: flex; justify-content: space-between; align-items: center;
        padding: 0.75rem 1rem; cursor: pointer; user-select: none;
        border-bottom: 1px solid var(--border-color);
    }
    .fieldset-header h3 { margin: 0; font-size: 1.1rem; color: var(--text-color); }
    .fieldset-content { padding: 1rem; border-top: 1px solid var(--border-color); display: block; }
    .collapsible-fieldset.collapsed .fieldset-content { display: none; }
    .collapsible-fieldset.collapsed .fieldset-header { border-bottom: none; }
    .toggle-icon { transition: transform 0.2s; }
    .collapsible-fieldset.collapsed .toggle-icon { transform: rotate(-90deg); }


    /* --- Mode Switcher --- */
    .mode-switcher { display: flex; border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden; }
    .mode-switcher button { flex: 1; padding: 0.5rem; background: transparent; border: none; cursor: pointer; color: var(--text-muted-color); font-weight: bold; }
    .mode-switcher button.active { background-color: var(--primary-color); color: white; }

    /* --- Inputs and Controls --- */
    .input-container { margin-bottom: 1rem; position: relative; }
    .input-container label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--text-color); }
    .input-container label.inline-label { display: inline; margin-left: 5px; font-weight: normal; }

    .textarea-actions { position: absolute; top: 0; right: 5px; display: flex; gap: 4px; }
    .textarea-action-btn { background: var(--border-color-light); border: 1px solid var(--border-color); color: var(--text-muted-color); padding: 2px 6px; font-size: 11px; border-radius: 4px; cursor: pointer; }
    .textarea-action-btn:hover { background: var(--primary-color); color: white; border-color: var(--primary-hover-color); }

    /* JSON Input Specifics */
    .json-chapter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; gap: 8px; }
    .json-chapter-header label { flex-grow: 1;}
    .json-chapter-input-container { border: 1px dashed var(--border-color); padding: 10px; margin-bottom: 10px; border-radius: var(--border-radius); background-color: var(--bg-color); }

    /* Find & Replace Specifics */
    #findReplacePairsContainer { max-height: 250px; overflow-y: auto; padding-right: 5px; }
    .find-replace-pair { display: flex; align-items: center; margin-bottom: 8px; gap: 8px; }
    
    /* --- Buttons --- */
    button, .button {
      padding: 10px 15px; color: white; border: none; border-radius: var(--border-radius); cursor: pointer;
      font-size: 16px; transition: background-color 0.2s ease, transform 0.1s ease; white-space: nowrap;
      display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
    }
    button:active, .button:active { transform: scale(0.98); }
    .btn-primary { background-color: var(--primary-color); }
    .btn-primary:hover { background-color: var(--primary-hover-color); }
    .btn-success { background-color: var(--success-color); }
    .btn-success:hover { background-color: var(--success-hover-color); }
    .btn-secondary { background-color: var(--secondary-color); color: white; }
    .btn-secondary:hover { background-color: var(--secondary-hover-color); }
    .btn-danger { background-color: var(--danger-color); }
    .btn-danger:hover { background-color: var(--danger-hover-color); }
    .btn-warning { background-color: var(--warning-color); color: #333; }
    .btn-warning:hover { background-color: #e0a800; }
    .btn-info { background-color: var(--info-color); color: white; }
    .btn-info:hover { background-color: #0aa3bf; }
    .btn-sm { padding: 5px 10px; font-size: 12px; }
    .btn-icon { padding: 0.5rem; }
    .btn-block { width: 100%; display: block; }

    /* --- Output Section --- */
    #output-column { display: none; }
    #outputControls {
      display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
      padding: 10px; background-color: var(--fg-color); border-radius: var(--border-radius);
      border: 1px solid var(--border-color); margin-bottom: 1rem; position: sticky; top: 0; z-index: 10;
    }
    #outputControls h4 { margin: 0; padding: 0; color: var(--primary-color); }

    .chunk-container {
      margin-bottom: 1rem; display: flex; align-items: flex-start; background-color: var(--fg-color);
      padding: 1rem; border-radius: var(--border-radius); border: 1px solid var(--border-color);
      box-shadow: var(--shadow-sm); gap: 1rem; transition: background-color 0.3s, border-color 0.3s;
    }
    .chunk-container.copied { border-color: var(--success-color); background-color: #1987541a; }
    .chunk-title {
        font-weight: bold; min-width: 90px; padding-top: 8px; color: var(--primary-color);
        flex-shrink: 0; font-size: 0.9em; text-align: right;
    }
    .chunk-textarea-wrapper textarea { background-color: var(--bg-color); }
    .button-action-wrapper { display: flex; flex-direction: column; align-items: center; gap: 5px; flex-shrink: 0; }
    .copy-count-display { font-size: 0.8em; color: var(--text-muted-color); }

    /* --- Status & Indicators --- */
     #loadingIndicator {
        display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 25px;
        background-color: rgba(0, 0, 0, 0.8); color: white; border-radius: 8px; z-index: 1000; font-size: 1.1em; box-shadow: var(--shadow-md);
     }
     .status-message { font-size: 0.85em; margin-top: 4px; display: block; padding: 5px 8px; border-radius: 4px; border: 1px solid transparent;}
     .status-success { color: #0f5132; background-color: #d1e7dd; border-color: #badbcc;}
     .status-error   { color: #842029; background-color: #f8d7da; border-color: #f5c2c7;}
     body.dark-mode .status-success { background-color: #032d18; color: #75b798; border-color: #198754; }
     body.dark-mode .status-error   { background-color: #381114; color: #f1aeb5; border-color: #842029; }
     
    #scrollToTopBtn {
        display: none; position: fixed; bottom: 20px; right: 30px; z-index: 99; opacity: 0.7;
    }
    #scrollToTopBtn:hover { opacity: 1; }

    /* For brevity, other status and info counter styles are minimally adjusted but will inherit theme colors */
    .info-counter { background-color: var(--border-color-light); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size:0.9em; }
    
  </style>
</head>

<body>
  
  <header class="app-header">
    <h1>Chunker Pro</h1>
    <div class="header-controls">
      <span id="mainStatus" class="status-message" style="display:none;"></span>
      <button id="theme-toggle" class="button btn-secondary btn-sm btn-icon" title="Toggle Dark/Light Theme">🌓</button>
      <button id="resetAllButton" class="button btn-danger btn-sm" title="Clear all settings and inputs, reload page">Reset All</button>
    </div>
  </header>

  <main class="main-container">
    <div id="settings-column">
      
      <div class="collapsible-fieldset">
        <div class="fieldset-header">
          <h3>1. Input Mode & Source</h3>
          <span class="toggle-icon">▼</span>
        </div>
        <div class="fieldset-content">
          <div class="mode-switcher" id="modeSwitcher">
            <button data-mode="json" class="active">JSON Objects</button>
            <button data-mode="text">Plain Text</button>
          </div>
          <input type="hidden" id="splitModeSelect" value="json">
        </div>
      </div>
      
      <!-- JSON SECTION -->
      <div id="jsonModeSections">
        <div class="collapsible-fieldset">
          <div class="fieldset-header"><h3>2. JSON Input Chapters</h3> <span class="toggle-icon">▼</span></div>
          <div class="fieldset-content">
            <p>Add one or more JSON array "chapters". Content from all valid inputs will be combined.</p>
            <div id="jsonInputsContainer"></div>
            <div style="display:flex; align-items:center; gap:10px; margin-top:10px;">
              <button id="addJsonChapterButton" class="button btn-primary btn-sm">+ Add Input</button>
              <button id="clearAllJsonButton" class="button btn-secondary btn-sm">Clear All</button>
              <span id="jsonObjectsCount" class="info-counter" style="margin-left: auto;">Total Objects: 0</span>
            </div>
            <div class="input-container" style="margin-top: 1rem;">
              <label for="jsonObjectsPerChunk">Combine objects per chunk:</label>
              <select id="jsonObjectsPerChunk">
                <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="10">10</option><option value="20">20</option>
              </select>
            </div>
          </div>
        </div>

        <div class="collapsible-fieldset">
          <div class="fieldset-header"><h3>3. Paired Find & Replace</h3><span class="toggle-icon">▼</span></div>
          <div class="fieldset-content">
            <p>Applied to <code>object.terms[any].translation</code> on a copy of the data during splitting.</p>
            <div style="display:flex; gap: 15px; margin-bottom: 10px;">
              <label class="inline-label"><input type="checkbox" id="applyRulesCheckbox"> Apply Rules</label>
              <label class="inline-label"><input type="checkbox" id="caseInsensitiveCheckbox"> Case-insensitive</label>
            </div>
            <div id="findReplacePairsContainer"></div>
            <div style="margin-top:10px;">
              <button id="addFindReplacePairButton" class="button btn-success btn-sm">+ Add Rule</button>
              <span id="glossaryReplaceStatus" class="status-message" style="margin-left: 10px; display: inline-block;"></span>
            </div>
          </div>
        </div>
      </div>

      <!-- PLAIN TEXT SECTION -->
      <div id="plainTextModeSections" style="display:none;">
        <div class="collapsible-fieldset">
          <div class="fieldset-header"><h3>2. Plain Text Input</h3> <span class="toggle-icon">▼</span></div>
          <div class="fieldset-content">
            <p>Text will be split by max characters, intelligently breaking at sentence or word boundaries.</p>
            <div style="text-align: right; margin-bottom: 5px;">
              <span id="plainTextInfo" class="info-counter">Chars: 0 / Approx. Chunks: 0</span>
            </div>
            <textarea id="plainTextInputArea" placeholder="Paste plain text here..." style="height: 250px;"></textarea>
            <span id="plainTextStatus" class="status-message"></span>
            <div class="input-container">
              <label for="formatSelect">Format text (before splitting):</label>
              <select id="formatSelect">
                  <option value="as-is">Show text as is</option>
                  <option value="pretty">Pretty (trim lines, join with double newlines)</option>
              </select>
            </div>
            <div class="input-container">
              <label for="maxChars">Max characters per chunk:</label>
              <input type="number" id="maxChars" value="1800" min="1">
            </div>
          </div>
        </div>
      </div>

      <!-- COMMON SECTIONS -->
      <div class="collapsible-fieldset">
        <div class="fieldset-header">
          <h3 id="commonSectionHeader">4. Chunk Header & Footer</h3>
          <span class="toggle-icon">▼</span>
        </div>
        <div class="fieldset-content">
          <p>Use <code>$X</code> for current part number and <code>$Y</code> for total parts.</p>
          <div class="input-container">
            <label for="addToTop">Add to top of each chunk:</label>
            <div class="textarea-actions">
              <button class="textarea-action-btn" onclick="copyFromTextarea('addToTop')">Copy</button>
              <button class="textarea-action-btn" onclick="pasteIntoTextarea('addToTop')">Paste</button>
              <button class="textarea-action-btn" onclick="clearTextarea('addToTop')">Clear</button>
            </div>
            <textarea id="addToTop" placeholder="Text to add to the top..." style="height:120px;"></textarea>
          </div>
          <div class="input-container">
            <label for="addToBottom">Add to bottom of each chunk:</label>
             <div class="textarea-actions">
              <button class="textarea-action-btn" onclick="copyFromTextarea('addToBottom')">Copy</button>
              <button class="textarea-action-btn" onclick="pasteIntoTextarea('addToBottom')">Paste</button>
              <button class="textarea-action-btn" onclick="clearTextarea('addToBottom')">Clear</button>
            </div>
            <textarea id="addToBottom" placeholder="Text to add to the bottom..." style="height:80px;"></textarea>
          </div>
        </div>
      </div>

      <button id="mainSplitButton" class="button btn-success btn-block" style="font-size: 1.2rem; padding: 12px;">⚙️ Process & Split</button>
      <span id="processStatus" class="status-message"></span>

    </div>

    <div id="output-column">
      <div id="outputControls">
        <h4 id="outputSummary">Output</h4>
        <button id="copyNextButton" class="button btn-warning btn-sm">⭐ Copy NEXT Uncopied</button>
        <button id="copyAllButton" class="button btn-info btn-sm">Copy ALL Chunks</button>
        <button id="clearOutputButton" class="button btn-secondary btn-sm">Clear Output</button>
      </div>
      <div id="chunkedTextContainer"></div>
    </div>
  </main>
  
  <div id="loadingIndicator">Processing...</div>
  <button id="scrollToTopBtn" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="Go to top" class="button btn-primary">⬆️</button>


  <script>
    // The JavaScript code remains largely the same in its core logic (chunking, state, etc.)
    // but has been adapted for the new UI elements (mode switcher, collapsible sections, new buttons).
    // The following is a summary of key JS changes and additions.
    // The full original JS code will be adapted to fit this new structure.

    // --- State & Config (with Theme added) ---
    let lastClickedButton = null;
    let findReplacePairCount = 0;
    let jsonChapterInputIdCounter = 0;
    const STATE_KEY = 'chunkerAppState_V3'; // Incremented version for new state structure
    const statusTimeouts = {};

    const newDefaultAddToTopPreset = `"Before replying YOU must think. From now onwards, in your thinking process/thought process/strategizing instead of YOU doing regular thinking, it is imperative that YOU MUST open and activate "Super-Duper-Hyper Thinking Mode". In this mode, you are obligated to: 1) engage in extreme exceptionally extreme thinking 2) engage in extreme exceptionally extreme extensivity 3) extreme exceptionally extreme extensity analysis"

1. Analyze raw Passage and Translation: 
   - FOR EACH line, summarize its meaning and compare it very thoroughly to the translation.
   - Note if the translation matches the original or deviates, explaining any ambiguities or potential errors.
   - Check if phrases are adapted naturally (e.g., idiomatic expressions retain flavor without literal awkwardness or being too formal and literal).

2. Identify Errors:
  - Spot issues related to:
     - Accuracy: Missing, Overly condensed sentences or lines, added, or incorrect glossary terms
        * Note : Only ignore glossary if certain it's wrong, if certain its not appropriately conveying the meaning or have grammatical error
  - Logic: Pronoun mistakes, wrong speaker, or mixed-up character names.
  - Language: Awkward or unnatural English or Overly condensed sentences.
  - Analyze every line thoroughly.

3. Verify Errors: 
   - Double-check all identified errors, ensuring each has clear evidence.
   - keep all the minor and major valid errors.
   - Verify if the tone matches the context (majestic for epic scenes, colloquial for dialogue).

4. Fix the Translation :
  - Correct the verified errors and use English major level proficiency to make the prose flows smoothly with Rich descriptive and faithful rendering of key dialogue
  - Don't use Only colon and bullet points in your translation and while during their removal make sure the English is natural and idiomatic.
  - "DO NOT transliterate the honorifics unless the glossary says so. For example, you should use 'Senior Brother X' instead of 'X-shixiong'."
  - Do not over condense the sentence and dialogue while making sure the English is natural and idiomatic.
  - Where necessary for comprehension, add brief, unobtrusive context or explanations for cultural terms or implied meanings. Avoid overly complex or literary phrasing if it sacrifices clarity

5. Give only the Fixed human like English translation as output and not the Whole JSON format. and Separately mention when a glossary is wrong or have variations and is fixed in the output.`;
	
    const defaultState = {
        theme: 'light',
        splitMode: 'json',
        maxChars: '1800',
        addToTop: newDefaultAddToTopPreset,
        addToBottom: '---\nEnd of Part $X of $Y',
        formatSelect: 'pretty',
        jsonObjectsPerChunk: '1',
        plainText: '',
        jsonInputs: [''],
        findReplacePairs: [{find:"", replace:""}, {find:"", replace:""}, {find:"", replace:""}],
        applyRules: false,
        caseInsensitive: false,
        collapsedSections: [], // To remember which sections are collapsed
    };
     let currentAppState = {...defaultState};

    // --- QoL Functions for New Buttons ---
    function copyFromTextarea(id) {
        const textarea = document.getElementById(id);
        if (textarea) navigator.clipboard.writeText(textarea.value).then(() => showStatus('mainStatus', 'Copied to clipboard!', 'success', 2000));
    }

    async function pasteIntoTextarea(id) {
        const textarea = document.getElementById(id);
        if (textarea) {
            try {
                const text = await navigator.clipboard.readText();
                textarea.value = text;
                textarea.dispatchEvent(new Event('input', { bubbles: true })); // Trigger updates
                showStatus('mainStatus', 'Pasted from clipboard!', 'success', 2000);
            } catch (err) {
                showStatus('mainStatus', 'Failed to paste.', 'error', 3000);
                console.error('Paste failed:', err);
            }
        }
    }

    function clearTextarea(id) {
        const textarea = document.getElementById(id);
        if (textarea) {
            textarea.value = '';
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    async function pasteIntoJsonInput(button) {
        const container = button.closest('.json-chapter-input-container');
        const textarea = container?.querySelector('.json-chapter-input');
        if (textarea) {
            try {
                const text = await navigator.clipboard.readText();
                textarea.value = text;
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                button.textContent = 'Pasted!';
                setTimeout(() => { button.textContent = 'Paste'; }, 1500);
            } catch (err) {
                console.error('Paste failed:', err);
                button.textContent = 'Failed!';
                setTimeout(() => { button.textContent = 'Paste'; }, 1500);
            }
        }
    }
    
    // --- Theme Management ---
    function applyTheme(theme) {
        if (theme === 'dark') {
            document.body.classList.add('dark-mode');
            document.getElementById('theme-toggle').textContent = '☀️';
        } else {
            document.body.classList.remove('dark-mode');
            document.getElementById('theme-toggle').textContent = '🌓';
        }
    }

    function toggleTheme() {
        currentAppState.theme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
        applyTheme(currentAppState.theme);
        saveState();
    }
    
    // --- State Management (Adapted for new UI) ---
    function saveState() {
       currentAppState.splitMode = document.getElementById('splitModeSelect').value;
       // ... (rest of the state saving is identical to original, e.g., maxChars, addToTop, etc.)
       currentAppState.maxChars = document.getElementById('maxChars').value;
       currentAppState.addToTop = document.getElementById('addToTop').value;
       currentAppState.addToBottom = document.getElementById('addToBottom').value;
       currentAppState.formatSelect = document.getElementById('formatSelect').value;
       currentAppState.jsonObjectsPerChunk = document.getElementById('jsonObjectsPerChunk').value;
       currentAppState.plainText = document.getElementById('plainTextInputArea').value;
       currentAppState.applyRules = document.getElementById('applyRulesCheckbox').checked;
       currentAppState.caseInsensitive = document.getElementById('caseInsensitiveCheckbox').checked;
        const chapterTextareas = document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input');
        currentAppState.jsonInputs = Array.from(chapterTextareas).map(textarea => textarea.value);
         const pairElements = document.querySelectorAll('#findReplacePairsContainer .find-replace-pair');
         currentAppState.findReplacePairs = Array.from(pairElements).map(pair => ({
             find: pair.querySelector('.find-text')?.value || "",
             replace: pair.querySelector('.replace-text')?.value || ""
         })).filter(p => p.find || p.replace);

        // Save collapsed state
        currentAppState.collapsedSections = [];
        document.querySelectorAll('.collapsible-fieldset.collapsed').forEach(fs => {
            // Create a simple ID from the h3 text
            const id = fs.querySelector('h3').textContent.trim().replace(/\s+/g, '-');
            currentAppState.collapsedSections.push(id);
        });

       try {
           localStorage.setItem(STATE_KEY, JSON.stringify(currentAppState));
       } catch (e) {
           console.error("LocalStorage save failed:", e);
           showStatus('mainStatus', 'Error: Could not save settings.', 'error', 10000);
       }
    }

   function loadState() {
       try {
          const savedStateJSON = localStorage.getItem(STATE_KEY);
           if (!savedStateJSON) {
               currentAppState = {...defaultState};
               showStatus('mainStatus', 'Loaded default settings.', 'success', 3000);
           } else {
              const savedState = JSON.parse(savedStateJSON);
              currentAppState = { ...defaultState, ...savedState };
              showStatus('mainStatus', 'Loaded saved settings.', 'success', 3000);
           }
        } catch (e) {
           console.error("LocalStorage load failed:", e);
           currentAppState = {...defaultState};
           showStatus('mainStatus', 'Error loading settings, using defaults.', 'error', 5000);
        }
        
        // Apply state to UI
        applyTheme(currentAppState.theme);
        document.getElementById('splitModeSelect').value = currentAppState.splitMode;
        // ... (rest of state loading is identical, maps state to element values)
        document.getElementById('maxChars').value = currentAppState.maxChars;
        document.getElementById('addToTop').value = currentAppState.addToTop;
        document.getElementById('addToBottom').value = currentAppState.addToBottom;
        document.getElementById('formatSelect').value = currentAppState.formatSelect;
        document.getElementById('jsonObjectsPerChunk').value = currentAppState.jsonObjectsPerChunk;
        document.getElementById('plainTextInputArea').value = currentAppState.plainText;
        document.getElementById('applyRulesCheckbox').checked = !!currentAppState.applyRules;
        document.getElementById('caseInsensitiveCheckbox').checked = !!currentAppState.caseInsensitive;
        
        // Restore collapsed sections
        if (currentAppState.collapsedSections) {
             document.querySelectorAll('.collapsible-fieldset').forEach(fs => {
                const id = fs.querySelector('h3').textContent.trim().replace(/\s+/g, '-');
                if (currentAppState.collapsedSections.includes(id)) {
                    fs.classList.add('collapsed');
                }
             });
        }

        // Load JSON inputs
        document.getElementById('jsonInputsContainer').innerHTML = '';
        jsonChapterInputIdCounter = 0;
        if (currentAppState.jsonInputs && currentAppState.jsonInputs.length > 0) {
             currentAppState.jsonInputs.forEach(content => addJsonChapterInput(content, false));
        } else {
             addJsonChapterInput('', false);
        }

        // Load Find/Replace
         document.getElementById('findReplacePairsContainer').innerHTML = '';
         findReplacePairCount = 0;
          if (currentAppState.findReplacePairs && currentAppState.findReplacePairs.length > 0) {
             currentAppState.findReplacePairs.forEach(pair => addFindReplacePair(pair.find, pair.replace, false));
          } else {
             addFindReplacePair("","", false);
          }
   }

    // --- UI Element Management (Adapted) ---
    function toggleInputSections() {
        const splitMode = document.getElementById('splitModeSelect').value;

        // Update mode switcher buttons
        document.querySelectorAll('.mode-switcher button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === splitMode);
        });

        // Show/hide sections
        document.getElementById('jsonModeSections').style.display = (splitMode === 'json' ? 'block' : 'none');
        document.getElementById('plainTextModeSections').style.display = (splitMode === 'text' ? 'block' : 'none');
        
        // Adjust common section header number
        const commonHeader = document.getElementById('commonSectionHeader');
        commonHeader.textContent = (splitMode === 'json' ? '4. Chunk Header & Footer' : '3. Chunk Header & Footer');
        
        clearOutput();
         if (splitMode === 'json') updateTotalJsonObjectCount();
         else updatePlainTextInfo();
         saveState();
     }

    function addJsonChapterInput(content = '', save = true) {
        jsonChapterInputIdCounter++;
        const container = document.getElementById('jsonInputsContainer');
        const chapterDiv = document.createElement('div');
        chapterDiv.classList.add('json-chapter-input-container');
        chapterDiv.innerHTML = `
         <div class="json-chapter-header">
            <label>JSON Input ${jsonChapterInputIdCounter}:</label>
            <span class="json-chapter-status status-message">Objects: 0</span>
            <button type="button" class="button btn-secondary btn-sm" onclick="pasteIntoJsonInput(this)">Paste</button>
            <button type="button" class="button btn-danger btn-sm" onclick="removeJsonChapterInput(this)">Remove</button>
         </div>
         <textarea class="json-chapter-input" placeholder='[ { "id":1, ... } ]'>${content}</textarea>
        `;
        // Attach listeners and perform updates as in original code...
        const textarea = chapterDiv.querySelector('textarea');
        const statusSpan = chapterDiv.querySelector('.json-chapter-status');
        textarea.addEventListener('input', () => {
            updateIndividualJsonCount(textarea, statusSpan);
            debouncedUpdateTotalJsonObjectCount();
            debouncedSaveState();
        });
        container.appendChild(chapterDiv);
        updateIndividualJsonCount(textarea, statusSpan);
        updateTotalJsonObjectCount();
        if (save) debouncedSaveState();
    }
    
    function addFindReplacePair(findVal = "", replaceVal = "", save=true) {
        const container = document.getElementById('findReplacePairsContainer');
        const pairDiv = document.createElement('div');
        pairDiv.classList.add('find-replace-pair');
        pairDiv.innerHTML = `
            <input type="text" class="find-text" placeholder="Find" value="${findVal}" >
            <span class="arrow">➔</span>
            <input type="text" class="replace-text" placeholder="Replace" value="${replaceVal}">
            <button type="button" class="button btn-danger btn-sm" onclick="removeFindReplacePair(this)">－</button>
        `;
         pairDiv.querySelectorAll('input').forEach(input => input.addEventListener('input', debouncedSaveState));
        container.appendChild(pairDiv);
        if(save) debouncedSaveState();
    }
    
    function displayChunk(content, title, container) {
        const chunkContainerDiv = document.createElement('div');
        chunkContainerDiv.classList.add('chunk-container');
        chunkContainerDiv.dataset.copied = "false";
        chunkContainerDiv.innerHTML = `
         <div class="chunk-title">${title.replace(/\n/g, '<br>')}</div>
         <div class="chunk-textarea-wrapper">
             <textarea readonly>${content}</textarea>
         </div>
         <div class="button-action-wrapper">
            <button class="button btn-primary copy-button" data-copy-count="0">Copy<span class="tick" style="display:none;"> ✔️</span></button>
            <span class="copy-count-display">(0)</span>
         </div>
        `;
         const copyButton = chunkContainerDiv.querySelector('.copy-button');
         const countDisplay = chunkContainerDiv.querySelector('.copy-count-display');
         const textarea = chunkContainerDiv.querySelector('textarea');
         copyButton.addEventListener('click', function () { copyToClipboard(textarea.value, this, countDisplay); });
       container.appendChild(chunkContainerDiv);
    }

    // --- Process & Chunk (Adapted) ---
    function processAndChunk() {
       clearOutput();
       showLoading();
       setTimeout(() => {
        try {
          const splitMode = document.getElementById('splitModeSelect').value;
          // ... (rest of the logic is identical to original)
          // It now displays in the right-hand column when successful.
          const addToTop = document.getElementById('addToTop').value;
          const addToBottom = document.getElementById('addToBottom').value;
          const container = document.getElementById('chunkedTextContainer');
          let chunkCount = 0;
          
          if (splitMode === 'json') {
             showStatus('glossaryReplaceStatus', "", 'info', 1); // clear previous
             const { data: rawJsonData, success, allEmpty, errorMessages } = getAllCombinedJsonData();
             if (allEmpty) {
                showStatus('processStatus', "All JSON inputs are empty.", 'warning');
             } else if (success && rawJsonData.length > 0) {
                 const { data: processedJsonData } = applyGlossaryRules(rawJsonData); 
                 chunkCount = chunkJsonInput(processedJsonData, addToTop, addToBottom, container);
                 showStatus('processStatus', `Success: Generated ${chunkCount} JSON chunks.`, 'success');
             } else if (!success) {
                  showStatus('processStatus', `Chunking aborted due to JSON error(s): ${errorMessages.join('. ')}`, 'error', 15000);
             } else {
                 showStatus('processStatus', "No valid JSON objects found.", 'warning');
             }
          } else { // text mode
             chunkCount = chunkPlainTextInput(addToTop, addToBottom, container);
              if(chunkCount > 0)
                 showStatus('processStatus', `Success: Generated ${chunkCount} text chunks.`, 'success');
          }

           if(chunkCount > 0) {
               document.getElementById('output-column').style.display = 'block';
           }
           document.getElementById('outputSummary').textContent = `Output: ${chunkCount} Chunk${chunkCount===1?'':'s'}`;
           document.getElementById('copyNextButton').disabled = chunkCount === 0;
           document.getElementById('copyAllButton').disabled = chunkCount === 0;

        } catch (error) {
          console.error("Error during chunking:", error);
           showStatus('processStatus', "An unexpected error occurred: " + error.message, 'error', 15000);
        } finally {
          hideLoading();
        }
      }, 50); 
    }

    // --- Init & Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
      // Load state first
      loadState();
      
      // NEW UI Listeners
      document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
      document.getElementById('resetAllButton').addEventListener('click', resetAllToDefaults);
      document.getElementById('modeSwitcher').addEventListener('click', (e) => {
          if (e.target.tagName === 'BUTTON') {
              document.getElementById('splitModeSelect').value = e.target.dataset.mode;
              toggleInputSections();
          }
      });
      document.querySelectorAll('.collapsible-fieldset .fieldset-header').forEach(header => {
          header.addEventListener('click', () => {
              header.parentElement.classList.toggle('collapsed');
              saveState(); // Save the collapsed state
          });
      });
      document.getElementById('mainSplitButton').addEventListener('click', processAndChunk);
      document.getElementById('clearOutputButton').addEventListener('click', clearOutput);
      document.getElementById('addJsonChapterButton').addEventListener('click', () => addJsonChapterInput());
      document.getElementById('clearAllJsonButton').addEventListener('click', clearAllJsonInputs);
      document.getElementById('addFindReplacePairButton').addEventListener('click', () => addFindReplacePair());
      document.getElementById('copyNextButton').addEventListener('click', copyNextUncopied);
      document.getElementById('copyAllButton').addEventListener('click', copyAllChunks);

      // Original Listeners (debounced)
      const debouncedSaveState = debounce(saveState, 600);
      const debouncedUpdateTotalJsonObjectCount = debounce(updateTotalJsonObjectCount, 400);
      const debouncedUpdatePlainTextInfo = debounce(updatePlainTextInfo, 400);

      document.getElementById('maxChars').addEventListener('input', debouncedUpdatePlainTextInfo);
      document.getElementById('addToTop').addEventListener('input', debouncedSaveState);
      document.getElementById('addToBottom').addEventListener('input', debouncedSaveState);
      document.getElementById('jsonObjectsPerChunk').addEventListener('change', debouncedSaveState);
      document.getElementById('plainTextInputArea').addEventListener('input', debouncedUpdatePlainTextInfo);
      document.getElementById('applyRulesCheckbox').addEventListener('change', debouncedSaveState);
      document.getElementById('caseInsensitiveCheckbox').addEventListener('change', debouncedSaveState);
      
      document.getElementById('formatSelect').addEventListener('change', () => {
         currentAppState.plainText = document.getElementById('plainTextInputArea').value;
         formatPlainText();
      });
      
      // Initialize UI based on loaded state
      toggleInputSections();
       if (currentAppState.splitMode === 'json') {
         updateTotalJsonObjectCount(); 
       } else {
         updatePlainTextInfo();
       }
        clearOutput();
    });

    // --- ALL OTHER ORIGINAL HELPER AND CORE LOGIC FUNCTIONS ---
    // (debounce, showStatus, hideLoading, saveState, loadState, etc. are assumed to be here,
    // with minor adaptations as shown in the snippets above. The core chunking logic is unchanged.)
    // For brevity, the full, unchanged JS is not repeated. The functions below are the original ones.
    
    function debounce(func, delay) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; }
    function showStatus(elementId, message, type = 'info', timeout = 4000) {
        const element = document.getElementById(elementId); if (!element) return;
        if(statusTimeouts[elementId]) clearTimeout(statusTimeouts[elementId]);
        element.innerHTML = message;
        element.className = `status-message status-${type}`;
        element.style.display = 'inline-block';
        if (timeout > 0) {
            statusTimeouts[elementId] = setTimeout(() => { if(element) element.style.display = 'none'; delete statusTimeouts[elementId]; }, timeout);
        }
    }
    function showLoading() { document.getElementById('loadingIndicator').style.display = 'block'; }
    function hideLoading() {  document.getElementById('loadingIndicator').style.display = 'none'; }
    function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    window.onscroll = function() {
       const btn = document.getElementById("scrollToTopBtn");
       if (document.getElementById("output-column").style.display !== 'none' && (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200)) {
            btn.style.display = "block";
        } else {
            btn.style.display = "none";
        }
    };
    function resetAllToDefaults() {
         if(confirm("Are you sure you want to clear all inputs, settings and reload defaults?")) {
            localStorage.removeItem(STATE_KEY);
            window.location.reload();
         }
     }
    function updateButtonState(button) {
      if (lastClickedButton && lastClickedButton !== button && lastClickedButton.classList.contains('copy-button')) {
         lastClickedButton.classList.remove('btn-success'); lastClickedButton.classList.add('btn-primary');
         const tick = lastClickedButton.querySelector('.tick'); if (tick) tick.style.display = 'none';
      }
       if(button.classList.contains('copy-button')) {
           button.classList.remove('btn-primary'); button.classList.add('btn-success');
           const tick = button.querySelector('.tick'); if (tick) tick.style.display = 'inline-block';
            lastClickedButton = button;
       }
    }
    function removeFindReplacePair(button) {
        button.parentElement.remove();
        if (document.querySelectorAll('#findReplacePairsContainer .find-replace-pair').length === 0) { addFindReplacePair("","", false); }
        saveState();
    }
    function removeJsonChapterInput(buttonElement) {
        buttonElement.closest('.json-chapter-input-container')?.remove();
        updateTotalJsonObjectCount();
        if (document.querySelectorAll('#jsonInputsContainer .json-chapter-input-container').length === 0) { addJsonChapterInput('', false); }
        saveState();
    }
    function clearAllJsonInputs() {
        document.getElementById('jsonInputsContainer').innerHTML = '';
        jsonChapterInputIdCounter = 0; addJsonChapterInput('', false);
        updateTotalJsonObjectCount(); saveState();
    }
    function updateIndividualJsonCount(textarea, statusSpan) {
        const jsonString = textarea.value.trim(); statusSpan.className = 'json-chapter-status status-message';
        if (!jsonString) { statusSpan.textContent = 'Objects: 0'; return 0; }
        try {
             if (!jsonString.startsWith('[')) throw new Error("Not Array");
            const jsonData = JSON.parse(jsonString);
            if (Array.isArray(jsonData)) {
                statusSpan.textContent = `Objects: ${jsonData.length}`; statusSpan.classList.add('status-success'); return jsonData.length;
            } else { throw new Error("Not Array"); }
        } catch (e) {
             if (e.message === "Not Array") { statusSpan.textContent = 'Error: Must be an Array []'; }
             else { statusSpan.textContent = 'Error: Invalid JSON'; }
             statusSpan.classList.add('status-error'); return 0;
        }
    }
    function updateTotalJsonObjectCount() {
        let totalObjects = 0;
        document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input').forEach( textarea => {
             const jsonString = textarea.value.trim();
             try {
                 if (jsonString && jsonString.startsWith('[') && jsonString.endsWith(']')) {
                    const jsonData = JSON.parse(jsonString);
                    if (Array.isArray(jsonData)) totalObjects += jsonData.length;
                 }
             } catch (e) { /* ignore */ }
        });
        document.getElementById('jsonObjectsCount').textContent = `Total Objects: ${totalObjects}`;
    }
    function updatePlainTextInfo() {
        const charCount = document.getElementById('plainTextInputArea').value.length;
        const maxChars = parseInt(document.getElementById('maxChars').value, 10);
        let chunks = (charCount > 0 && maxChars > 0) ? Math.ceil(charCount / maxChars) : (charCount > 0 ? 1 : 0);
        document.getElementById('plainTextInfo').textContent = `Chars: ${charCount} / Approx. Chunks: ${chunks}`;
        if (isNaN(maxChars) || maxChars <= 0) { showStatus('plainTextStatus', "Max characters must be > 0", 'error'); }
        else { showStatus('plainTextStatus', "", 'info', 1); }
        saveState();
    }
    function formatPlainText() {
      const formatSelect = document.getElementById('formatSelect');
      const textArea = document.getElementById('plainTextInputArea');
      const originalText = currentAppState.plainText || textArea.value; 
      if (formatSelect.value === 'pretty') {
         textArea.value = originalText.split('\n').map(p => p.trim()).filter(p => p).join('\n\n');
      } else { textArea.value = originalText; }
       updatePlainTextInfo();
    }
    function getAllCombinedJsonData() {
        let combinedData = [], allInputsValid = true, allEmpty = true, errorMessages = [];
        document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input').forEach((textarea, index) => {
            const jsonString = textarea.value.trim(); if (!jsonString) return; allEmpty = false;
            try {
                if (!jsonString.startsWith('[') || !jsonString.endsWith(']')) throw new Error(`Input ${index + 1} is not a JSON array`);
                const jsonData = JSON.parse(jsonString);
                if (Array.isArray(jsonData)) { combinedData = combinedData.concat(jsonData); }
                else { throw new Error(`Input ${index + 1} is not an array`); }
            } catch (e) { errorMessages.push(e.message); allInputsValid = false; }
        });
        if(!allInputsValid) { showStatus('processStatus', "JSON Error(s): " + errorMessages.join('; '), 'error', 15000); }
        return { data: combinedData, success: allInputsValid, allEmpty, errorMessages };
    }
    function applyGlossaryRules(jsonData) {
         const applyRules = document.getElementById('applyRulesCheckbox').checked;
         if (!applyRules || !jsonData || jsonData.length === 0) return { data: jsonData, count: 0};
         const flags = document.getElementById('caseInsensitiveCheckbox').checked ? 'gi' : 'g';
         const rules = [];
         document.querySelectorAll('#findReplacePairsContainer .find-replace-pair').forEach(el => {
             const findText = el.querySelector('.find-text')?.value;
             if (findText) { rules.push({ findRegExp: new RegExp(escapeRegExp(findText), flags), replace: el.querySelector('.replace-text')?.value ?? '' }); }
         });
        if (rules.length === 0) return { data: jsonData, count: 0};
        const processedData = JSON.parse(JSON.stringify(jsonData)); let totalInstancesReplaced = 0;
        processedData.forEach(obj => {
            (Array.isArray(obj) ? obj : [obj]).forEach(item => {
                if (item && Array.isArray(item.terms)) {
                    item.terms.forEach(term => {
                        if (term && typeof term.translation === 'string') {
                            let current = term.translation;
                             rules.forEach(rule => {
                                 const matches = current.match(rule.findRegExp);
                                 if(matches) { totalInstancesReplaced += matches.length; current = current.replace(rule.findRegExp, rule.replace); }
                             });
                             term.translation = current;
                        }
                    });
                }
            });
         });
        showStatus('glossaryReplaceStatus', `Applied ${totalInstancesReplaced} replacements.`, 'success');
        return { data: processedData, count: totalInstancesReplaced} ;
     }
    function chunkJsonInput(jsonData, addToTop, addToBottom, container) {
      if (!jsonData || jsonData.length === 0) return 0;
      const objectsToGroup = parseInt(document.getElementById('jsonObjectsPerChunk').value, 10) || 1;
      const totalNewChunks = Math.ceil(jsonData.length / objectsToGroup);
      let displayCount = 0;
      for (let i = 0; i < jsonData.length; i += objectsToGroup) {
        const group = jsonData.slice(i, i + objectsToGroup); if (group.length === 0) continue;
        displayCount++; const partNum = displayCount;
        let title = `Seg ${partNum}/${totalNewChunks}\n(Items ${i + 1}-${i + group.length})`;
        const content = JSON.stringify(objectsToGroup === 1 && group.length === 1 ? group[0] : group, null, 2);
        const top = addToTop.replace(/\$X/g, partNum).replace(/\$Y/g, totalNewChunks);
        const bottom = addToBottom.replace(/\$X/g, partNum).replace(/\$Y/g, totalNewChunks);
        displayChunk([top, content, bottom].filter(Boolean).join('\n\n').trim(), title, container);
      }
       return displayCount;
    }
    function smartSplit(text, maxLength) {
        if (text.length <= maxLength) return [text];
        const chunks = []; let currentText = text;
        while (currentText.length > maxLength) {
            let breakPoint = -1;
            for(const char of ['. ', '! ', '? ', '\n', ' ', ',']) {
                 const index = currentText.lastIndexOf(char, maxLength);
                 if(index > 0 && index <= maxLength) { breakPoint = (char === ' ') ? index : index + char.length; break; }
            }
            if (breakPoint <= 0) { breakPoint = maxLength; }
            chunks.push(currentText.substring(0, breakPoint).trim());
            currentText = currentText.substring(breakPoint).trim();
        }
        if (currentText.length > 0) chunks.push(currentText);
        return chunks;
    }
    function chunkPlainTextInput(addToTop, addToBottom, container) {
       const text = document.getElementById('plainTextInputArea').value; const maxChars = parseInt(document.getElementById('maxChars').value);
       if (!text.trim()) { showStatus('processStatus', "Input is empty.", 'warning'); return 0; }
       if (isNaN(maxChars) || maxChars <= 0) { showStatus('processStatus', "Max characters must be > 0.", 'error'); return 0; }
       let chunks = []; let currentChunk = "";
       text.split('\n').forEach(p => {
           if (p.length > maxChars) { if (currentChunk) chunks.push(currentChunk); chunks = chunks.concat(smartSplit(p, maxChars)); currentChunk = ""; return; }
           const potentialLength = currentChunk.length + (currentChunk && p ? 1: 0) + p.length;
           if (currentChunk && potentialLength > maxChars) { chunks.push(currentChunk); currentChunk = p; }
           else { currentChunk += (currentChunk && p ? '\n' : '') + p; if (!p && currentChunk) currentChunk += '\n'; }
       });
       if (currentChunk) chunks.push(currentChunk);
       chunks = chunks.map(c => c.trim()).filter(Boolean); const totalChunks = chunks.length;
       if(totalChunks === 0) return 0;
       chunks.forEach((chunk, index) => {
         const partNum = index + 1; const top = addToTop.replace(/\$X/g, partNum).replace(/\$Y/g, totalChunks);
         const bottom = addToBottom.replace(/\$X/g, partNum).replace(/\$Y/g, totalChunks);
         displayChunk([top, chunk, bottom].filter(Boolean).join('\n\n').trim(), `Part ${partNum}/${totalChunks}`, container);
       });
       return chunks.length;
    }
     function clearOutput() {
         document.getElementById('chunkedTextContainer').innerHTML = '';
         document.getElementById('output-column').style.display = 'none';
         lastClickedButton = null;
         showStatus('processStatus', 'Output cleared', 'success', 2000);
         document.getElementById('scrollToTopBtn').style.display = 'none';
     }
     function copyAllChunks() {
        const textareas = document.querySelectorAll('#chunkedTextContainer textarea'); if (textareas.length === 0) return;
        const allText = Array.from(textareas).map(ta => ta.value).join("\n\n" + "-".repeat(20) + "\n\n");
        navigator.clipboard.writeText(allText).then(() => {
            showStatus('processStatus', `Copied all ${textareas.length} chunks!`, 'success');
            document.querySelectorAll('.chunk-container').forEach(div => {
               div.dataset.copied = "true"; div.classList.add('copied');
            });
            document.getElementById('copyNextButton').disabled = true;
        });
     }
     function copyNextUncopied() {
          const nextContainer = document.querySelector('.chunk-container[data-copied="false"]');
          if(nextContainer) {
              const textarea = nextContainer.querySelector('textarea'); const button = nextContainer.querySelector('.copy-button');
              copyToClipboard(textarea.value, button, nextContainer.querySelector('.copy-count-display'));
              nextContainer.scrollIntoView({behavior: 'smooth', block: 'center'});
              showStatus('processStatus', `Copied next chunk.`, 'success', 2000);
          } else {
               showStatus('processStatus', `All chunks have been copied.`, 'info');
               document.getElementById('copyNextButton').disabled = true;
          }
     }
    function copyToClipboard(text, buttonElement, countDisplayElement) {
       navigator.clipboard.writeText(text).then(() => {
            if (buttonElement) {
                 updateButtonState(buttonElement);
                 const container = buttonElement.closest('.chunk-container');
                 if(container) {
                     container.dataset.copied = "true"; container.classList.add('copied');
                     if (!document.querySelector('.chunk-container[data-copied="false"]')) { document.getElementById('copyNextButton').disabled = true; }
                 }
                 if (countDisplayElement) {
                    let count = parseInt(buttonElement.dataset.copyCount, 10) + 1;
                    buttonElement.dataset.copyCount = count.toString();
                    countDisplayElement.textContent = `(${count})`;
                 }
            }
        }).catch(err => { console.error('Copy failed:', err); showStatus('processStatus', 'Failed to copy.', 'error'); });
    }

  </script>
</body>
</html>
