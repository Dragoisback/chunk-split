<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB Splitter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }
        .container { background-color: #f9f9f9; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #333; }
        label { display: block; margin-top: 10px; font-weight: bold; }
        input[type="file"], input[type="number"], input[type="text"], select {
            width: calc(100% - 22px); padding: 10px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 20px;
        }
        button:hover { background-color: #0056b3; }
        .options-group { margin-top: 15px; padding: 10px; border: 1px solid #eee; border-radius: 4px; }
        .hidden { display: none; }
        #status, #downloadLinks { margin-top: 20px; }
        #downloadLinks a { display: block; margin-bottom: 5px; }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; }

        /* Styles for custom volume definitions */
        .volume-definition-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px dashed #ccc;
            border-radius: 4px;
        }
        .volume-definition-row input[type="text"] {
            flex-grow: 1;
            margin-top: 0; /* Override general input margin-top */
        }
        .volume-definition-row .remove-volume-btn {
            background-color: #dc3545;
            padding: 5px 10px;
            font-size: 14px;
            margin-top: 0;
        }
        .volume-definition-row .remove-volume-btn:hover {
            background-color: #c82333;
        }
        #addVolumeButton {
            background-color: #28a745;
            font-size: 14px;
            padding: 8px 12px;
        }
        #addVolumeButton:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EPUB Splitter</h1>

        <label for="epubFile">Upload EPUB File:</label>
        <input type="file" id="epubFile" accept=".epub" required>

        <label for="splitType">Split By:</label>
        <select id="splitType">
            <option value="chaptersPerPart">Number of Chapters per Part</option>
            <option value="numberOfParts">Fixed Number of Parts</option>
            <option value="approxSize">Approximate Size per Part (MB)</option>
            <option value="customRanges">Custom Chapter Ranges (Volumes)</option>
        </select>

        <div id="chaptersPerPartOptions" class="options-group">
            <label for="numChapters">Chapters per Part:</label>
            <input type="number" id="numChapters" value="5" min="1">
        </div>

        <div id="numberOfPartsOptions" class="options-group hidden">
            <label for="numParts">Number of Parts:</label>
            <input type="number" id="numParts" value="2" min="2">
        </div>

        <div id="approxSizeOptions" class="options-group hidden">
            <label for="partSize">Approx. Size per Part (MB):</label>
            <input type="number" id="partSize" value="1" min="0.1" step="0.1">
            <small>Note: This is based on uncompressed content file sizes and is an approximation.</small>
        </div>

        <div id="customRangesOptions" class="options-group hidden">
            <label>Define Volumes:</label>
            <div id="volumeDefinitionsContainer">
                <!-- Volume definition rows will be added here by JavaScript -->
            </div>
            <button type="button" id="addVolumeButton" style="margin-top: 10px;">+ Add Volume</button>
            <small style="display:block; margin-top:5px;">Chapter ranges are 1-indexed (e.g., "1-5", "6-10", "11-end").</small>
        </div>

        <button id="splitButton">Split EPUB</button>

        <div id="status"></div>
        <div id="downloadLinks"></div>
    </div>

    <script>
        // --- UI Logic ---
        const splitTypeSelect = document.getElementById('splitType');
        const allOptionsDivs = document.querySelectorAll('.options-group');
        const epubFileInput = document.getElementById('epubFile');
        const splitButton = document.getElementById('splitButton');
        const statusDiv = document.getElementById('status');
        const downloadLinksDiv = document.getElementById('downloadLinks');
        const volumeDefinitionsContainer = document.getElementById('volumeDefinitionsContainer');
        const addVolumeButton = document.getElementById('addVolumeButton');

        const optionsMap = {
            'chaptersPerPart': document.getElementById('chaptersPerPartOptions'),
            'numberOfParts': document.getElementById('numberOfPartsOptions'),
            'approxSize': document.getElementById('approxSizeOptions'),
            'customRanges': document.getElementById('customRangesOptions')
        };

        function addVolumeDefinitionRow(name = "", range = "") {
            const row = document.createElement('div');
            row.className = 'volume-definition-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.placeholder = 'Volume Name (e.g., Volume 1)';
            nameInput.value = name;
            nameInput.className = 'volume-name-input';

            const rangeInput = document.createElement('input');
            rangeInput.type = 'text';
            rangeInput.placeholder = 'Chapter Range (e.g., 1-5)';
            rangeInput.value = range;
            rangeInput.className = 'volume-range-input';

            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.textContent = 'Remove';
            removeButton.className = 'remove-volume-btn';
            removeButton.onclick = () => row.remove();

            row.appendChild(nameInput);
            row.appendChild(rangeInput);
            row.appendChild(removeButton);
            volumeDefinitionsContainer.appendChild(row);
        }

        addVolumeButton.addEventListener('click', () => addVolumeDefinitionRow());

        splitTypeSelect.addEventListener('change', function() {
            allOptionsDivs.forEach(div => div.classList.add('hidden'));
            if (optionsMap[this.value]) {
                optionsMap[this.value].classList.remove('hidden');
            }
            if (this.value === 'customRanges' && volumeDefinitionsContainer.children.length === 0) {
                addVolumeDefinitionRow(); // Add one default row if container is empty
            }
        });
        // Initialize visibility and add default volume row if needed
        optionsMap[splitTypeSelect.value].classList.remove('hidden');
        if (splitTypeSelect.value === 'customRanges' && volumeDefinitionsContainer.children.length === 0) {
             addVolumeDefinitionRow();
        }


        // --- Core EPUB Logic ---
        splitButton.addEventListener('click', async () => {
            const file = epubFileInput.files[0];
            if (!file) {
                statusDiv.textContent = 'Please select an EPUB file.';
                return;
            }

            statusDiv.textContent = 'Processing... please wait.';
            downloadLinksDiv.innerHTML = '';

            try {
                const originalZip = await JSZip.loadAsync(file);
                const { opfPath, opfContent, opfDir } = await getOpfData(originalZip);
                const parser = new DOMParser();
                const opfDoc = parser.parseFromString(opfContent, "application/xml");

                const manifestItems = parseManifest(opfDoc);
                const spineItemRefs = parseSpine(opfDoc);
                
                const chapterFiles = spineItemRefs
                    .map(idref => manifestItems.find(item => item.id === idref))
                    .filter(item => item && (item.mediaType === 'application/xhtml+xml' || item.mediaType === 'application/html'));

                if (chapterFiles.length === 0) {
                    statusDiv.textContent = 'Error: No chapters found in the EPUB spine.';
                    return;
                }
                
                const tocInfo = await getTocInfo(originalZip, opfDoc, opfDir, manifestItems);

                let partsToCreate = []; // Will store objects: {name: "Volume Name", chapters: [...], isCustom: true/false} or {partNum: 1, chapters: [...]}
                const splitType = splitTypeSelect.value;
                const originalTitle = getMetadataField(opfDoc, "dc:title") || "Untitled";
                const originalIdentifier = getMetadataField(opfDoc, "dc:identifier") || crypto.randomUUID();

                if (splitType === 'chaptersPerPart') {
                    const numChapters = parseInt(document.getElementById('numChapters').value) || 1;
                    let partNum = 1;
                    for (let i = 0; i < chapterFiles.length; i += numChapters) {
                        partsToCreate.push({
                            partNum: partNum++,
                            chapters: chapterFiles.slice(i, i + numChapters),
                            isCustomName: false
                        });
                    }
                } else if (splitType === 'numberOfParts') {
                    const numParts = parseInt(document.getElementById('numParts').value) || 2;
                    const chaptersPerPartRaw = chapterFiles.length / numParts;
                    let currentIndex = 0;
                    for (let i = 0; i < numParts; i++) {
                         const chaptersInThisPart = (i === numParts -1) ? 
                            chapterFiles.length - currentIndex :
                            Math.round(chaptersPerPartRaw * (i+1)) - Math.round(chaptersPerPartRaw * i);
                        
                        if (chaptersInThisPart > 0) {
                            partsToCreate.push({
                                partNum: i + 1,
                                chapters: chapterFiles.slice(currentIndex, currentIndex + chaptersInThisPart),
                                isCustomName: false
                            });
                        }
                        currentIndex += chaptersInThisPart;
                    }
                } else if (splitType === 'approxSize') {
                    const targetSizeMB = parseFloat(document.getElementById('partSize').value) || 1;
                    const targetSizeBytes = targetSizeMB * 1024 * 1024;
                    let currentGroup = [];
                    let currentGroupSize = 0;
                    let partNum = 1;
                    for (const chapter of chapterFiles) {
                        const fileData = await originalZip.file(opfDir + chapter.href)?.async("uint8array");
                        const fileSize = fileData ? fileData.byteLength : 0;
                        if (currentGroup.length > 0 && currentGroupSize + fileSize > targetSizeBytes && currentGroup.length > 0) {
                            partsToCreate.push({ partNum: partNum++, chapters: currentGroup, isCustomName: false });
                            currentGroup = [];
                            currentGroupSize = 0;
                        }
                        currentGroup.push(chapter);
                        currentGroupSize += fileSize;
                    }
                    if (currentGroup.length > 0) {
                        partsToCreate.push({ partNum: partNum++, chapters: currentGroup, isCustomName: false });
                    }
                } else if (splitType === 'customRanges') {
                    const volumeRows = volumeDefinitionsContainer.querySelectorAll('.volume-definition-row');
                    if (volumeRows.length === 0) {
                        statusDiv.textContent = 'Error: Please define at least one volume for custom ranges.';
                        return;
                    }
                    let errorInRanges = false;
                    volumeRows.forEach((row, index) => {
                        if (errorInRanges) return;
                        const nameInput = row.querySelector('.volume-name-input');
                        const rangeInput = row.querySelector('.volume-range-input');
                        
                        const volumeName = nameInput.value.trim() || `Volume ${index + 1}`;
                        const rangeStr = rangeInput.value.trim();

                        if (!rangeStr) {
                            statusDiv.textContent = `Error: Chapter range for "${volumeName}" is empty.`;
                            errorInRanges = true;
                            return;
                        }

                        let [startStr, endStr] = rangeStr.split('-').map(n => n.trim());
                        let start = parseInt(startStr);
                        let end;

                        if (endStr && endStr.toLowerCase() === 'end') {
                            end = chapterFiles.length;
                        } else if (endStr) {
                            end = parseInt(endStr);
                        } else { // Single chapter number like "5"
                            end = start;
                        }

                        if (isNaN(start) || isNaN(end) || start < 1 || start > end || end > chapterFiles.length) {
                            statusDiv.textContent = `Invalid range: "${rangeStr}" for ${volumeName}. Max chapter is ${chapterFiles.length}. Chapter numbers are 1-indexed.`;
                            errorInRanges = true;
                            return;
                        }
                        partsToCreate.push({
                            name: volumeName,
                            chapters: chapterFiles.slice(start - 1, end),
                            isCustomName: true
                        });
                    });
                    if (errorInRanges) return;
                }

                if (partsToCreate.length === 0 || partsToCreate.every(p => p.chapters.length === 0)) {
                    statusDiv.textContent = 'Error: Splitting resulted in no valid parts with chapters. Check your settings.';
                    return;
                }
                
                partsToCreate = partsToCreate.filter(p => p.chapters.length > 0); // Ensure no empty parts proceed

                for (let i = 0; i < partsToCreate.length; i++) {
                    const partData = partsToCreate[i];
                    
                    const partIdentifier = partData.isCustomName ? partData.name : partData.partNum;
                    const totalPartsInSet = partData.isCustomName ? partsToCreate.length : (partsToCreate.findLast(p => !p.isCustomName)?.partNum || partsToCreate.length);


                    const newEpubZip = await createNewEpubPart(
                        originalZip,
                        opfDoc,
                        opfPath,
                        opfDir,
                        manifestItems,
                        partData.chapters,
                        tocInfo,
                        partIdentifier, // This is either volume name (string) or part number (number)
                        totalPartsInSet,    // Total parts in this logical set
                        originalTitle,
                        originalIdentifier,
                        partData.isCustomName // Pass boolean to indicate if name is custom
                    );
                    const blob = await newEpubZip.generateAsync({ type: "blob", mimeType: "application/epub+zip" });
                    const downloadUrl = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    
                    let filename;
                    let linkText;
                    if (partData.isCustomName) {
                        filename = `${sanitizeFilename(partData.name)}.epub`;
                        linkText = `Download ${partData.name}`;
                    } else {
                        filename = `${sanitizeFilename(originalTitle)}_Part_${partData.partNum}.epub`;
                        linkText = `Download Part ${partData.partNum}`;
                    }
                    link.download = filename;
                    link.textContent = linkText;
                    downloadLinksDiv.appendChild(link);
                }
                statusDiv.textContent = 'Splitting complete. Download links below.';

            } catch (error) {
                console.error("EPUB Splitting Error:", error);
                statusDiv.textContent = `Error: ${error.message}. Check console for details.`;
            }
        });

        async function getOpfData(zip) {
            const containerFile = zip.file("META-INF/container.xml");
            if (!containerFile) throw new Error("META-INF/container.xml not found.");
            const containerContent = await containerFile.async("string");
            const parser = new DOMParser();
            const containerDoc = parser.parseFromString(containerContent, "application/xml");
            const rootfilePath = containerDoc.getElementsByTagName("rootfile")[0]?.getAttribute("full-path");
            if (!rootfilePath) throw new Error("Rootfile path not found in container.xml.");

            const opfFile = zip.file(rootfilePath);
            if (!opfFile) throw new Error(`OPF file (${rootfilePath}) not found.`);
            const opfContent = await opfFile.async("string");
            const opfDir = rootfilePath.substring(0, rootfilePath.lastIndexOf('/') + 1);
            return { opfPath: rootfilePath, opfContent, opfDir };
        }

        function parseManifest(opfDoc) {
            const items = [];
            const manifestNode = opfDoc.getElementsByTagName("manifest")[0];
            if (manifestNode) {
                for (const itemNode of manifestNode.getElementsByTagName("item")) {
                    items.push({
                        id: itemNode.getAttribute("id"),
                        href: itemNode.getAttribute("href"),
                        mediaType: itemNode.getAttribute("media-type"),
                        properties: itemNode.getAttribute("properties") // For NAV
                    });
                }
            }
            return items;
        }

        function parseSpine(opfDoc) {
            const itemRefs = [];
            const spineNode = opfDoc.getElementsByTagName("spine")[0];
            if (spineNode) {
                for (const itemrefNode of spineNode.getElementsByTagName("itemref")) {
                    itemRefs.push(itemrefNode.getAttribute("idref"));
                }
            }
            return itemRefs;
        }
        
        async function getTocInfo(zip, opfDoc, opfDir, manifestItems) {
            let tocPath, tocContent, tocType;
            const spineNode = opfDoc.getElementsByTagName("spine")[0];
            const ncxId = spineNode?.getAttribute("toc"); // EPUB 2 NCX
            
            if (ncxId) {
                const ncxItem = manifestItems.find(item => item.id === ncxId);
                if (ncxItem) {
                    tocPath = opfDir + ncxItem.href;
                    tocType = 'ncx';
                }
            } else { // Check for EPUB 3 NAV
                const navItem = manifestItems.find(item => item.properties && item.properties.includes("nav"));
                if (navItem) {
                    tocPath = opfDir + navItem.href;
                    tocType = 'nav';
                }
            }

            if (tocPath) {
                const tocFile = zip.file(tocPath);
                if (tocFile) tocContent = await tocFile.async("string");
                else console.warn(`ToC file ${tocPath} not found in zip.`);
            } else {
                 console.warn("No ToC (NCX or NAV) found in OPF.");
            }
            // Ensure tocDir ends with a slash if it's not empty
            let tocDir = "";
            if (tocPath) {
                const lastSlash = tocPath.lastIndexOf('/');
                if (lastSlash !== -1) {
                    tocDir = tocPath.substring(0, lastSlash + 1);
                }
            }
            if (!tocDir && opfDir) tocDir = opfDir; // Fallback to opfDir if toc is in root or no specific dir

            return { path: tocPath, content: tocContent, type: tocType, dir: tocDir };
        }


        function getMetadataField(opfDoc, fieldName) {
            const metadataNode = opfDoc.getElementsByTagName("metadata")[0];
            if (metadataNode) {
                const elements = metadataNode.getElementsByTagName(fieldName); // dc:title
                if (elements.length > 0) return elements[0].textContent;
                
                // Try without dc: prefix for flexibility (though dc is standard)
                const nonDcElements = metadataNode.getElementsByTagName(fieldName.replace('dc:',''));
                if (nonDcElements.length > 0) return nonDcElements[0].textContent;
            }
            return null;
        }
        
        function generateUUID() { 
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function createNewEpubPart(
            originalZip,
            opfDoc,
            originalOpfPath,
            opfDir,
            allManifestItems,
            chapterItemsForPart,
            tocInfo,
            partIdentifier, // Can be a string (volume name) or number (part number)
            totalPartsInSet,  // Total parts in this logical grouping
            originalTitle,
            originalIdentifier,
            isCustomName      // Boolean: true if partIdentifier is a custom name
        ) {
            const newZip = new JSZip();
            const serializer = new XMLSerializer();
            const parser = new DOMParser();

            newZip.file("mimetype", "application/epub+zip", { compression: "STORE" });
            const containerContent = await originalZip.file("META-INF/container.xml").async("string");
            newZip.file("META-INF/container.xml", containerContent);

            const newOpfDoc = opfDoc.cloneNode(true);
            const metadataNode = newOpfDoc.getElementsByTagName("metadata")[0];
            if (metadataNode) {
                let titleNode = metadataNode.querySelector("dc\\:title, title");
                if (!titleNode) { // Create title if not exists
                    titleNode = newOpfDoc.createElementNS("http://purl.org/dc/elements/1.1/", "dc:title");
                    metadataNode.appendChild(titleNode);
                }
                if (isCustomName) {
                    titleNode.textContent = `${originalTitle} - ${partIdentifier}`; // e.g., "Book Name - Volume One"
                } else {
                    titleNode.textContent = `${originalTitle} - Part ${partIdentifier}/${totalPartsInSet}`;
                }
                
                let identifierNode = metadataNode.querySelector("dc\\:identifier, identifier");
                const newUuid = generateUUID();
                const newBookIdAttr = "BookIdPart" + (isCustomName ? sanitizeFilename(String(partIdentifier)).replace(/[^a-zA-Z0-9]/g,"") : partIdentifier) + Date.now();


                if (identifierNode) {
                    identifierNode.textContent = `urn:uuid:${newUuid}`;
                     // Update id attribute if present and it was the unique-identifier
                    const mainIdAttr = newOpfDoc.documentElement.getAttribute('unique-identifier');
                    if(mainIdAttr && identifierNode.getAttribute('id') === mainIdAttr) {
                        identifierNode.setAttribute('id', newBookIdAttr);
                        newOpfDoc.documentElement.setAttribute('unique-identifier', newBookIdAttr);
                    } else if (identifierNode.getAttribute('id')) {
                        // If it has an ID but wasn't the unique-identifier, still make it unique to this part
                         identifierNode.setAttribute('id', newBookIdAttr);
                    }
                } else { 
                    const newIdElement = newOpfDoc.createElementNS("http://purl.org/dc/elements/1.1/", "dc:identifier");
                    newIdElement.setAttribute("id", newBookIdAttr);
                    newIdElement.textContent = `urn:uuid:${newUuid}`;
                    metadataNode.appendChild(newIdElement);
                    newOpfDoc.documentElement.setAttribute('unique-identifier', newBookIdAttr);
                }
            }

            const manifestNode = newOpfDoc.getElementsByTagName("manifest")[0];
            const chapterItemIds = new Set(chapterItemsForPart.map(item => item.id));
            const itemsToKeep = new Set();
            chapterItemsForPart.forEach(item => itemsToKeep.add(item.id));
            allManifestItems.forEach(item => {
                if (!item.mediaType.includes('xhtml') && !item.mediaType.includes('html')) {
                    itemsToKeep.add(item.id);
                }
                if (tocInfo.path && (opfDir + item.href === tocInfo.path || item.href === tocInfo.path)) {
                    itemsToKeep.add(item.id);
                }
            });
            Array.from(manifestNode.getElementsByTagName("item")).forEach(itemNode => {
                if (!itemsToKeep.has(itemNode.getAttribute("id"))) itemNode.remove();
            });

            const spineNode = newOpfDoc.getElementsByTagName("spine")[0];
            Array.from(spineNode.getElementsByTagName("itemref")).forEach(itemrefNode => {
                if (!chapterItemIds.has(itemrefNode.getAttribute("idref"))) itemrefNode.remove();
            });
            
            let newTocPath = tocInfo.path;
            let newTocContent = tocInfo.content;
            const chapterHrefsInPart = new Set(chapterItemsForPart.map(item => item.href)); // Relative to OPF

            if (tocInfo.content && tocInfo.path) {
                if (tocInfo.type === 'ncx' && newTocContent) {
                    const tocDoc = parser.parseFromString(newTocContent, "application/xml");
                    const navMapNode = tocDoc.getElementsByTagName("navMap")[0];
                    if (navMapNode) {
                        const filterNavPoints = (parentElement) => {
                            Array.from(parentElement.children).forEach(navPointNode => {
                                if (navPointNode.tagName.toLowerCase() !== 'navpoint') return;

                                const contentNode = navPointNode.getElementsByTagName("content")[0];
                                const src = contentNode?.getAttribute("src");
                                let srcPathOnly = src ? src.split('#')[0] : null;
                                
                                // Potentially adjust srcPathOnly if it's relative to ToC dir vs OPF dir
                                // This assumes NCX <content src="..."> paths are relative to the NCX file itself.
                                const absoluteSrcPath = new URL(srcPathOnly, new URL(tocInfo.path, "file:///" + opfDir )).pathname.substring(1); // Make absolute then relative to root
                                const opfRelativeSrcPath = absoluteSrcPath.startsWith(opfDir) ? absoluteSrcPath.substring(opfDir.length) : absoluteSrcPath;

                                if (srcPathOnly && !chapterHrefsInPart.has(opfRelativeSrcPath) && !chapterHrefsInPart.has(srcPathOnly) /* check both just in case */ ) {
                                    navPointNode.remove();
                                } else {
                                    filterNavPoints(navPointNode); // Recurse for nested navPoints
                                }
                            });
                        };
                        filterNavPoints(navMapNode);
                        
                        let playOrder = 1;
                        Array.from(tocDoc.getElementsByTagName("navPoint")).forEach(navPoint => {
                             navPoint.setAttribute("playOrder", String(playOrder++));
                        });
                        newTocContent = serializer.serializeToString(tocDoc);
                    }
                }
                else if (tocInfo.type === 'nav' && newTocContent) {
                    const tocDoc = parser.parseFromString(newTocContent, "application/xhtml+xml"); // or "text/html"
                    const tocNavElement = tocDoc.querySelector("nav[epub\\:type='toc'], nav[role='doc-toc']");
                    if (tocNavElement) {
                         const filterNavLis = (parentElement) => {
                            Array.from(parentElement.children).forEach(liNode => {
                                if (liNode.tagName.toLowerCase() !== 'li') return;
                                const anchor = liNode.getElementsByTagName("a")[0];
                                const href = anchor?.getAttribute("href");
                                let hrefPathOnly = href ? href.split('#')[0] : null;

                                // Similar path adjustment as NCX if NAV paths are relative to NAV file.
                                const absoluteHrefPath = new URL(hrefPathOnly, new URL(tocInfo.path, "file:///" + opfDir)).pathname.substring(1);
                                const opfRelativeHrefPath = absoluteHrefPath.startsWith(opfDir) ? absoluteHrefPath.substring(opfDir.length) : absoluteHrefPath;

                                if (hrefPathOnly && !chapterHrefsInPart.has(opfRelativeHrefPath) && !chapterHrefsInPart.has(hrefPathOnly)) {
                                    liNode.remove();
                                } else {
                                    const nestedOl = liNode.querySelector("ol");
                                    if (nestedOl) filterNavLis(nestedOl); // Recurse
                                }
                            });
                        };
                        const mainOl = tocNavElement.querySelector("ol");
                        if (mainOl) filterNavLis(mainOl);
                        newTocContent = serializer.serializeToString(tocDoc);
                    }
                }
                if (newTocPath && newTocContent) {
                     newZip.file(newTocPath, newTocContent); 
                }
            }
            newZip.file(originalOpfPath, serializer.serializeToString(newOpfDoc));

            const finalManifestItems = parseManifest(newOpfDoc);
            for (const item of finalManifestItems) {
                const filePathInEpub = opfDir + item.href;
                if (filePathInEpub === newTocPath && newTocContent) continue;

                const fileInOriginalZip = originalZip.file(filePathInEpub);
                if (fileInOriginalZip) {
                    const data = await fileInOriginalZip.async("uint8array");
                    newZip.file(filePathInEpub, data);
                } else {
                    console.warn(`File ${filePathInEpub} from manifest not found in original EPUB for part ${partIdentifier}. This might be an image or CSS referenced by a removed chapter's ToC entry if ToC filtering is imperfect.`);
                }
            }
            return newZip;
        }

        function sanitizeFilename(name) {
            // Allow spaces initially, then replace sequences of non-alphanumeric (excluding . - _) with single underscore
            let sane = name.replace(/[^\w\s.-]/g, ''); // Remove most special chars, keep whitespace, word chars, dot, hyphen
            sane = sane.replace(/\s+/g, '_'); // Replace whitespace sequences with single underscore
            return sane;
        }

        // Initial UI setup
        splitTypeSelect.dispatchEvent(new Event('change'));

    </script>
</body>
</html>
