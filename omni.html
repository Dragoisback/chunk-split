<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text/JSON Chunker Pro</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      background-color: #f4f7f6;
      color: #333;
      padding-bottom: 40px;
    }

    h1, h3, h4, legend {
        color: #2c3e50;
    }
     p {
       font-size:0.9em; color:#555; margin-top: 5px;
     }

    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
      padding: 10px;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      background-color: #fff;
       font-family: monospace, sans-serif;
    }
     /* Style adjustments for consistency */
     .input-container input[type="number"],
     .input-container input[type="text"],
     .input-container select,
     .input-container textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
         margin-bottom: 5px;
    }

    fieldset {
         border: 1px solid #e0e0e0;
        padding: 10px 15px 15px 15px;
        margin-bottom: 20px;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    legend {
        font-weight: bold;
        padding: 0 10px;
        font-size: 1.1em;
         background-color: #fff; /* For cleaner look on some browsers */
    }

    .input-container {
      margin-bottom: 15px;
    }
    .input-container label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        color: #555;
    }
     .input-container label.inline-label {
        display: inline; margin-left: 5px; font-weight: normal; color: #333;
     }

    .input-container textarea {
        height: 80px;
    }

    /* Styles for JSON Chapter Inputs */
    .json-chapter-input-container {
        border: 1px dashed #b0bec5;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        background-color: #f8f9fa;
    }
    .json-chapter-input-container label {
        font-weight: bold;
        font-size: 0.95em;
    }
    .json-chapter-input-container textarea { /* Target specific textareas */
        height: 120px;
         margin-bottom: 0;
    }
    .json-chapter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
        gap: 8px;
    }
     .json-chapter-header label { flex-grow: 1;}

    .remove-json-chapter-button, #addJsonChapterButton, #clearAllJsonButton {
        padding: 5px 10px;
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #e9ecef;
        color: #333;
        flex-shrink: 0;
    }
    .remove-json-chapter-button { background-color: #f8d7da; border-color: #f5c6cb; }
    .remove-json-chapter-button:hover { background-color: #f1b0b7; }
    #addJsonChapterButton { background-color: #cfe2ff; border-color: #b6d4fe;}
    #addJsonChapterButton:hover { background-color: #a3c6f8;}
    #clearAllJsonButton { background-color: #fff3cd; border-color: #ffeeba;}
    #clearAllJsonButton:hover { background-color: #fce8b2;}


    /* Styles for dynamic find/replace pairs */
     #findReplacePairsContainer {
         max-height: 250px;
         overflow-y: auto;
         padding-right: 5px;
         margin-bottom: 10px;
         border-bottom: 1px solid #eee;
         padding-bottom: 10px;
     }
    .find-replace-pair {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        padding: 5px;
        border-radius: 4px;
        gap: 8px;
    }
    .find-replace-pair input[type="text"] {
        flex-grow: 1;
        width: auto; /* allow flex grow */
    }
    .find-replace-pair .arrow {
        font-weight: bold;
        color: #555;
        flex-shrink: 0;
    }
    .find-replace-pair .remove-pair-button,
    #addFindReplacePairButton {
        padding: 6px 10px;
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #e9ecef;
        color: #333;
        min-width: 30px;
        text-align: center;
         flex-shrink: 0;
    }
    #addFindReplacePairButton {
        background-color: #28a745;
        color: white;
        border-color: #28a745;
        font-size: 14px;
        padding: 8px 12px;
    }
     .find-replace-pair .remove-pair-button:hover {
        background-color: #dc3545;
        color: white;
        border-color: #dc3545;
     }
     #addFindReplacePairButton:hover {
        background-color: #218838;
     }
     .checkbox-container { display: flex; align-items: center; gap: 15px; margin-top: 10px; margin-bottom: 10px;}


    .chunk-container {
      margin-bottom: 15px;
      display: flex;
      align-items: flex-start;
      background-color: #fff;
      padding: 12px;
      border-radius: 5px;
      border: 1px solid #b0d6ff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
       gap: 10px;
    }
     .chunk-container.copied {
        background-color: #e8f5e9; /* Light green tint for copied chunks */
        border-color: #a5d6a7;
     }

    .chunk-title {
      font-weight: bold;
      min-width: 90px;
      padding-top: 8px;
      color: #007BFF;
      flex-shrink: 0;
       font-size: 0.9em;
       text-align: right;
    }

    .chunk-textarea-wrapper {
        flex-grow: 1;
    }
    .chunk-textarea-wrapper textarea {
        height: 150px;
        width: 100%;
        background-color: #f8f9fa; /* Slightly off-white */
        margin-bottom: 0;
    }
    .chunk-container.copied .chunk-textarea-wrapper textarea {
         background-color: #f1f8e9;
    }


    button, .copy-button {
      padding: 10px 15px;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
      white-space: nowrap;
    }
    button#mainSplitButton {
        background-color: #28a745; margin-right: 10px;
    }
    button#mainSplitButton:hover {
        background-color: #218838;
    }
     button#clearOutputButton {
        background-color: #6c757d;
    }
     button#clearOutputButton:hover {
         background-color: #5a6268;
     }
      button#copyAllButton {
        background-color: #17a2b8;
     }
      button#copyAllButton:hover {
         background-color: #138496;
     }
     button#copyNextButton {
        background-color: #ffc107; color: #333; border: 1px solid #e0a800;
     }
      button#copyNextButton:hover {
         background-color: #e0a800;
     }
     button#resetAllButton {
         background-color: #dc3545; margin-left: auto; font-size: 0.8em; padding: 6px 10px;
     }
      button#resetAllButton:hover {
          background-color: #c82333;
      }


    .button-action-wrapper { /* Wrapper for copy button and its count */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
         flex-shrink: 0; /* Prevent button from shrinking */
    }

    .copy-button {
      background-color: #007BFF;
      font-size: 14px;
      padding: 8px 12px;
      display: flex;
      align-items: center;
       width: 100%;
       justify-content: center;
    }
    .copy-button:hover {
        background-color: #0056b3;
    }
    .copy-button.green {
      background-color: #28a745;
    }
     .copy-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
     }
    .copy-button.green:hover {
      background-color: #1e7e34;
    }
    .copy-button .tick {
      display: none;
      margin-left: 8px;
      font-size: 16px;
    }
    .copy-button.green .tick {
      display: inline-block;
    }
    .copy-count-display {
        font-size: 0.8em;
        color: #666;
        white-space: nowrap;
    }

    #chunkedTextContainer {
      margin-top: 20px;
    }
     #outputControls {
         margin-top: 30px; margin-bottom: 15px; display: none; align-items: center; gap: 10px;
         padding: 10px; background-color: #e9ecef; border-radius: 5px; border: 1px solid #ced4da;
     }
     #outputControls h4 { margin: 0; padding: 0; color: #007BFF;}

    #loadingIndicator {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 25px;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 8px;
      z-index: 1000;
      font-size: 1.1em;
      box-shadow: 0 0 15px rgba(0,0,0,0.3);
    }
    .info-counter {
        font-size: 0.9em;
        padding: 4px 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        color: #333;
        border: 1px solid #ced4da;
        display: inline-block;
         flex-shrink: 0;
    }
     /* Status Messages */
     .status-message { font-size: 0.85em; margin-top: 4px; display: block; padding: 3px 6px; border-radius: 3px;}
     .status-info    { color: #007BFF; background-color: #e0f2ff; }
     .status-success { color: #155724; background-color: #d4edda; }
     .status-warning { color: #856404; background-color: #fff3cd; }
     .status-error   { color: #721c24; background-color: #f8d7da; }
     .json-chapter-status { font-size: 0.85em; color: #555; flex-shrink: 0;}
     .controls-bar { display: flex; gap: 10px; align-items: center; margin-bottom: 15px;}
    
     #scrollToTopBtn {
        display: none; position: fixed; bottom: 20px; right: 30px; z-index: 99;
        font-size: 18px; padding: 10px 15px; background-color: #007bff; opacity: 0.7;
     }
      #scrollToTopBtn:hover { opacity: 1; background-color: #0056b3;}

  </style>
</head>

<body>
   <div style="display:flex; justify-content:space-between; align-items: center;">
     <h1>Text/JSON Chunker Pro</h1>
     <button type="button" id="resetAllButton" title="Clear all settings and inputs, reload page" onclick="resetAllToDefaults()">Reset All</button>
    </div>
   <span id="mainStatus" class="status-message" style="margin-bottom: 10px;"></span>


 <fieldset>
    <legend>Input Mode & Source</legend>
    <div class="input-container">
        <label for="splitModeSelect">Select Splitting Mode:</label>
        <select id="splitModeSelect" title="Choose between processing JSON arrays or Plain Text">
        <option value="json">JSON Objects (Chunk by group or individually)</option>
        <option value="text">Plain Text (Split by max characters)</option>
        </select>
    </div>

    <div id="jsonInputSection">
        <p>Add one or more JSON "chapters". Content from all valid JSON inputs will be combined. The total object count updates automatically.</p>
        
        <div id="jsonInputsContainer">
        <!-- JSON input boxes will be dynamically added here -->
        </div>

        <div class="controls-bar" style="margin-top:10px;">
            <button type="button" id="addJsonChapterButton" onclick="addJsonChapterInput()">+ Add JSON Input</button>
            <button type="button" id="clearAllJsonButton" onclick="clearAllJsonInputs()">Clear All JSON Inputs</button>
            <span id="jsonObjectsCount" class="info-counter" style="margin-left: auto;">Total Objects: 0</span>
        </div>
        
        <div class="input-container" style="margin-top: 10px;">
            <label for="jsonObjectsPerChunk">Combine original JSON objects per output chunk:</label>
            <select id="jsonObjectsPerChunk" title="How many original objects from the combined list should be put into each output chunk.">
                 <option value="1">1 (One object per chunk)</option>
                 <option value="2">2 objects</option>
                 <option value="3">3 objects</option>
                 <option value="4">4 objects</option>
                 <option value="5">5 objects</option>
                 <option value="6">6 objects</option>
                 <option value="7">7 objects</option>
                 <option value="10">10 objects</option>
                 <option value="20">20 objects</option>
            </select>
        </div>
     </div><!-- /jsonInputSection -->

     <div id="plainTextInputSection" style="display:none;">
        <p>Paste your plain text below. It will be split based on 'Max characters per chunk'. Character count and approximate chunk estimate update automatically.</p>
        <div style="text-align: right; margin-bottom: 5px;">
            <span id="plainTextInfo" class="info-counter">Chars: 0 / Approx. Chunks: 0</span>
        </div>
        <textarea id="plainTextInputArea" placeholder="Paste plain text here..." style="height: 250px;"></textarea>
         <span id="plainTextStatus" class="status-message"></span>
        <div class="input-container">
        <label for="formatSelect">Format text (before splitting):</label>
        <select id="formatSelect" title="Apply formatting to the text in the box above BEFORE splitting. 'Pretty' trims lines and joins with double newlines.">
            <option value="as-is">Show text as is</option>
            <option value="pretty">Pretty (trim lines, join with double newlines)</option>
        </select>
        </div>
        <div class="input-container">
        <label for="maxChars">Max characters per chunk:</label>
        <input type="number" id="maxChars" value="1800" min="1" title="Maximum characters of YOUR content per chunk. Long paragraphs will be split intelligently. Headers/Footers are added afterwards.">
        </div>
    </div><!-- /plainTextInputSection -->
 </fieldset>


 <fieldset id="glossaryFindReplaceSection">
      <legend>Paired Find & Replace (JSON Mode Only)</legend>
      <p>Define rules applied sequentially ONLY to: <code>object.terms[any].translation</code> within the JSON data.
         <br><b>NOTE:</b> Replacements are applied to a COPY during splitting, your input boxes are NOT modified.
      </p>
       <div class="checkbox-container">
           <div>
             <input type="checkbox" id="applyRulesCheckbox" onchange="debouncedSaveState()"><label for="applyRulesCheckbox" class="inline-label">Apply these rules during split</label>
           </div>
            <div>
              <input type="checkbox" id="caseInsensitiveCheckbox" onchange="debouncedSaveState()"><label for="caseInsensitiveCheckbox" class="inline-label">Case-insensitive matching</label>
           </div>
        </div>
      <div id="findReplacePairsContainer">
         <!-- pairs added here -->
      </div>
      <div class="controls-bar">
        <button type="button" id="addFindReplacePairButton" onclick="addFindReplacePair()">+ Add Rule</button>
        <span id="glossaryReplaceStatus" class="status-message" style="margin-left: 10px; display: inline-block;"></span>
      </div>
  </fieldset>


  <fieldset>
    <legend>Chunk Header & Footer</legend>
    <div class="input-container">
      <label for="addToTop">Add to top of each chunk:</label>
      <textarea id="addToTop"
        placeholder="Text to add to the top of each chunk..." title="Use $X for current part number, $Y for total parts."></textarea>
    </div>
    <div class="input-container">
      <label for="addToBottom">Add to bottom of each chunk:</label>
      <textarea id="addToBottom"
        placeholder="Text to add to the bottom of each chunk..."  title="Use $X for current part number, $Y for total parts."></textarea>
    </div>
  </fieldset>

 <div class="controls-bar">
  <button id="mainSplitButton" onclick="processAndChunk()">⚙️ Process & Split Text</button>
   <span id="processStatus" class="status-message"></span>
 </div>

  <div id="outputControls">
      <h4 id="outputSummary">Output</h4>
       <button id="copyNextButton" title="Copy the next chunk that hasn't been copied yet" onclick="copyNextUncopied()">⭐ Copy NEXT Uncopied</button>
       <button id="copyAllButton" title="Copy all generated chunks to clipboard" onclick="copyAllChunks()">Copy ALL Chunks</button>
       <button id="clearOutputButton" title="Clear all generated chunks" onclick="clearOutput()">Clear Output</button>
  </div>
  <div id="chunkedTextContainer"></div>
  
  <div id="loadingIndicator">Processing... Please wait.</div>
  <button id="scrollToTopBtn" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="Go to top">⬆️</button>


  <script>
    // --- State & Config ---
    let lastClickedButton = null;
    let findReplacePairCount = 0; // just for tracking
    let jsonChapterInputIdCounter = 0;
    const STATE_KEY = 'chunkerAppState_V2';
    const statusTimeouts = {}; // Store timeouts for clearing status messages

    // Default Top Text
     const newDefaultAddToTopPreset = `"Before replying YOU must think. From now onwards, in your thinking process/thought process/strategizing instead of YOU doing regular thinking, it is imperative that YOU MUST open and activate "Super-Duper-Hyper Thinking Mode". In this mode, you are obligated to: 1) engage in extreme exceptionally extreme thinking 2) engage in extreme exceptionally extreme extensivity 3) extreme exceptionally extreme extensity analysis"

1. Analyze raw Passage and Translation: 
   - FOR EACH line, summarize its meaning and compare it very thoroughly to the translation.
   - Note if the translation matches the original or deviates, explaining any ambiguities or potential errors.
   - Check if phrases are adapted naturally (e.g., idiomatic expressions retain flavor without literal awkwardness or being too formal and literal).

2. Identify Errors:
  - Spot issues related to:
     - Accuracy: Missing, Overly condensed sentences or lines, added, or incorrect glossary terms
        * Note : Only ignore glossary if certain it's wrong, if certain its not appropriately conveying the meaning or have grammatical error
  - Logic: Pronoun mistakes, wrong speaker, or mixed-up character names.
  - Language: Awkward or unnatural English or Overly condensed sentences.
  - Analyze every line thoroughly.

3. Verify Errors: 
   - Double-check all identified errors, ensuring each has clear evidence.
   - keep all the minor and major valid errors.
   - Verify if the tone matches the context (majestic for epic scenes, colloquial for dialogue).

4. Fix the Translation :
  - Correct the verified errors and use English major level proficiency to make the prose flows smoothly with Rich descriptive and faithful rendering of key dialogue
  - Don't use Only colon and bullet points in your translation and while during their removal make sure the English is natural and idiomatic.
  - "DO NOT transliterate the honorifics unless the glossary says so. For example, you should use 'Senior Brother X' instead of 'X-shixiong'."
  - Do not over condense the sentence and dialogue while making sure the English is natural and idiomatic.
  - Where necessary for comprehension, add brief, unobtrusive context or explanations for cultural terms or implied meanings. Avoid overly complex or literary phrasing if it sacrifices clarity

5. Give only the Fixed human like English translation as output and not the Whole JSON format. and Separately mention when a glossary is wrong or have variations and is fixed in the output.`;
	const defaultState = {
        splitMode: 'json',
        maxChars: '1800',
        addToTop: newDefaultAddToTopPreset,
        addToBottom: '---\nEnd of Part $X of $Y',
        formatSelect: 'pretty',
        jsonObjectsPerChunk: '1',
        plainText: '',
        jsonInputs: [''], // Array of strings
        findReplacePairs: [{find:"", replace:""}, {find:"", replace:""}, {find:"", replace:""}], // Array of objects
        applyRules: false,
        caseInsensitive: false,
    };
     let currentAppState = {...defaultState}; // Working copy

    // --- Helpers ---
     function debounce(func, delay) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), delay);
        };
     }
      // Create debounced versions
     const debouncedSaveState = debounce(saveState, 600);
     const debouncedUpdateTotalJsonObjectCount = debounce(updateTotalJsonObjectCount, 400);
     const debouncedUpdatePlainTextInfo = debounce(updatePlainTextInfo, 400);

     function showStatus(elementId, message, type = 'info', timeout = 6000) {
        const element = document.getElementById(elementId);
         if (!element) return;
         // Clear any existing timeout for this element
         if(statusTimeouts[elementId]) clearTimeout(statusTimeouts[elementId]);

         element.innerHTML = message;
         element.className = `status-message status-${type}`; // Reset and set class
         element.style.display = 'inline-block';
         if (timeout > 0) {
            statusTimeouts[elementId] = setTimeout(() => {
                 if(element) element.style.display = 'none';
                 delete statusTimeouts[elementId];
             }, timeout);
         }
     }

    function showLoading() { document.getElementById('loadingIndicator').style.display = 'block'; }
    function hideLoading() {  document.getElementById('loadingIndicator').style.display = 'none'; }

    function escapeRegExp(string) {
       // $& means the whole matched string
       return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
    }

   window.onscroll = function() {
       const btn = document.getElementById("scrollToTopBtn");
        // Show button only if output exists and user has scrolled down
       if (document.getElementById("outputControls").style.display !== 'none' && (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200)) {
            btn.style.display = "block";
        } else {
            btn.style.display = "none";
        }
   };


    // --- State Management ---
    function saveState() {
       // console.log("Saving state...");
       currentAppState.splitMode = document.getElementById('splitModeSelect').value;
       currentAppState.maxChars = document.getElementById('maxChars').value;
       currentAppState.addToTop = document.getElementById('addToTop').value;
       currentAppState.addToBottom = document.getElementById('addToBottom').value;
       currentAppState.formatSelect = document.getElementById('formatSelect').value;
       currentAppState.jsonObjectsPerChunk = document.getElementById('jsonObjectsPerChunk').value;
       currentAppState.plainText = document.getElementById('plainTextInputArea').value;
       currentAppState.applyRules = document.getElementById('applyRulesCheckbox').checked;
       currentAppState.caseInsensitive = document.getElementById('caseInsensitiveCheckbox').checked;

        // JSON Inputs
        const chapterTextareas = document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input');
        currentAppState.jsonInputs = Array.from(chapterTextareas).map(textarea => textarea.value);
       
        // Find/Replace Pairs
         const pairElements = document.querySelectorAll('#findReplacePairsContainer .find-replace-pair');
         currentAppState.findReplacePairs = Array.from(pairElements).map(pair => ({
             find: pair.querySelector('.find-text')?.value || "",
             replace: pair.querySelector('.replace-text')?.value || ""
         })).filter(p => p.find || p.replace); // save only pairs with some content

        try {
           localStorage.setItem(STATE_KEY, JSON.stringify(currentAppState));
           // showStatus('mainStatus', 'Settings Saved', 'info', 1500);
        } catch (e) {
           console.error("LocalStorage save failed:", e);
            showStatus('mainStatus', 'Error: Could not save settings (LocalStorage full or disabled?)', 'error', 10000);
        }
    }

   function loadState() {
       try {
          // Clear legacy items if they exist
          localStorage.removeItem('allJsonInputValues');
          localStorage.removeItem('addToTop');
           //... remove other old keys if necessary

          const savedStateJSON = localStorage.getItem(STATE_KEY);
           if (!savedStateJSON) {
               currentAppState = {...defaultState}; // Use defaults
                showStatus('mainStatus', 'Loaded default settings.', 'info', 3000);
           } else {
              const savedState = JSON.parse(savedStateJSON);
               // Merge defaults with saved state to handle new properties added in updates
               currentAppState = { ...defaultState, ...savedState };
                showStatus('mainStatus', 'Loaded saved settings.', 'success', 3000);
           }
        } catch (e) {
           console.error("LocalStorage load failed:", e);
           currentAppState = {...defaultState}; // Fallback to defaults
           showStatus('mainStatus', 'Error loading settings, using defaults.', 'warning', 5000);
        }
        // Apply state to UI
        document.getElementById('splitModeSelect').value = currentAppState.splitMode;
        document.getElementById('maxChars').value = currentAppState.maxChars;
        document.getElementById('addToTop').value = currentAppState.addToTop;
        document.getElementById('addToBottom').value = currentAppState.addToBottom;
        document.getElementById('formatSelect').value = currentAppState.formatSelect;
        document.getElementById('jsonObjectsPerChunk').value = currentAppState.jsonObjectsPerChunk;
        document.getElementById('plainTextInputArea').value = currentAppState.plainText;
        document.getElementById('applyRulesCheckbox').checked = !!currentAppState.applyRules; // ensure boolean
        document.getElementById('caseInsensitiveCheckbox').checked = !!currentAppState.caseInsensitive;

         // Load JSON inputs
        document.getElementById('jsonInputsContainer').innerHTML = '';
        jsonChapterInputIdCounter = 0;
        if (currentAppState.jsonInputs && currentAppState.jsonInputs.length > 0) {
             currentAppState.jsonInputs.forEach(content => addJsonChapterInput(content, false)); // false = dont save again
        } else {
             addJsonChapterInput('', false); // Add one empty 
        }
         if (document.querySelectorAll('#jsonInputsContainer .json-chapter-input-container').length === 0) {
           addJsonChapterInput('', false); 
         }

        // Load Find/Replace
         document.getElementById('findReplacePairsContainer').innerHTML = '';
         findReplacePairCount = 0;
          if (currentAppState.findReplacePairs && currentAppState.findReplacePairs.length > 0) {
             currentAppState.findReplacePairs.forEach(pair => addFindReplacePair(pair.find, pair.replace, false));
          } 
          // Ensure at least one empty row exists
           if (document.querySelectorAll('#findReplacePairsContainer .find-replace-pair').length === 0) {
              addFindReplacePair("","", false);
           }
   }

    function resetAllToDefaults() {
         if(confirm("Are you sure you want to clear all inputs, settings and reload defaults?")) {
            try {
                 localStorage.removeItem(STATE_KEY);
                 showStatus('mainStatus', 'All settings and inputs cleared. Reloading...', 'success', 2000);
                 setTimeout(() => window.location.reload(), 1000);
            } catch(e) {
                 console.error("Error clearing localStorage", e);
                  showStatus('mainStatus', 'Error clearing settings.', 'error');
            }
         }
     }


    // --- UI Element Management ---

    function updateButtonState(button) {
      // Remove green ONLY from the last *copy* button
      if (lastClickedButton && lastClickedButton !== button && lastClickedButton.classList.contains('copy-button')) {
         lastClickedButton.classList.remove('green');
         const tick = lastClickedButton.querySelector('.tick');
         if (tick) tick.style.display = 'none';
      }
       if(button.classList.contains('copy-button')) {
           button.classList.add('green');
            const tick = button.querySelector('.tick');
           if (tick) tick.style.display = 'inline-block';
            lastClickedButton = button;
       }
    }

    function addFindReplacePair(findVal = "", replaceVal = "", save=true) {
        findReplacePairCount++; 
        const container = document.getElementById('findReplacePairsContainer');
        const pairDiv = document.createElement('div');
        pairDiv.classList.add('find-replace-pair');
        pairDiv.innerHTML = `
            <input type="text" class="find-text" placeholder="Find this text" value="${findVal}" title="Text to find. Can include simple regex characters, but special characters are escaped unless you know regex." >
            <span class="arrow">➔</span>
            <input type="text" class="replace-text" placeholder="Replace with this" value="${replaceVal}" title="Text to replace with.">
            <button type="button" class="remove-pair-button" onclick="removeFindReplacePair(this)" title="Remove this rule">－</button>
        `;
         // Add listener to save on change
        pairDiv.querySelectorAll('input').forEach(input => input.addEventListener('input', debouncedSaveState));
        container.appendChild(pairDiv);
        if(save) debouncedSaveState();
    }

    function removeFindReplacePair(button) {
        button.parentElement.remove();
         // Ensure at least one empty row exists
         if (document.querySelectorAll('#findReplacePairsContainer .find-replace-pair').length === 0) {
             addFindReplacePair("","", false); // add but don't save yet
          }
        debouncedSaveState(); // save the removal
    }

    function addJsonChapterInput(content = '', save = true) {
        jsonChapterInputIdCounter++;
        const container = document.getElementById('jsonInputsContainer');
        const chapterDiv = document.createElement('div');
        chapterDiv.classList.add('json-chapter-input-container');
        chapterDiv.dataset.inputId = `json-chapter-${jsonChapterInputIdCounter}`;
        chapterDiv.innerHTML = `
         <div class="json-chapter-header">
            <label>JSON Input ${jsonChapterInputIdCounter}:</label>
            <span class="json-chapter-status status-message">Objects: 0</span>
            <button type="button" class="remove-json-chapter-button" onclick="removeJsonChapterInput(this)" title="Remove this input box">Remove</button>
         </div>
         <textarea class="json-chapter-input" placeholder='[ { "id":1, "terms": [ {"translation": "hello"} ] }, { ... } ]'>${content}</textarea>
        `;
        const textarea = chapterDiv.querySelector('textarea');
        const statusSpan = chapterDiv.querySelector('.json-chapter-status');
        
        textarea.addEventListener('input', () => {
            updateIndividualJsonCount(textarea, statusSpan);
            debouncedUpdateTotalJsonObjectCount();
            debouncedSaveState();
        });
        container.appendChild(chapterDiv);

        updateIndividualJsonCount(textarea, statusSpan); // Initial count 
        updateTotalJsonObjectCount(); // Update global count immediately on add/remove
        if (save) { debouncedSaveState(); }
        return chapterDiv;
    }

    function removeJsonChapterInput(buttonElement) {
        buttonElement.closest('.json-chapter-input-container')?.remove();
        updateTotalJsonObjectCount(); // immediate
         // Ensure at least one input box remains
        if (document.querySelectorAll('#jsonInputsContainer .json-chapter-input-container').length === 0) {
            addJsonChapterInput('', false); // add but don't save yet
        }
         debouncedSaveState(); // save the removal
    }
    
    function clearAllJsonInputs() {
        document.getElementById('jsonInputsContainer').innerHTML = '';
        jsonChapterInputIdCounter = 0; 
        addJsonChapterInput('', false); // Add one fresh input, don't save yet
        updateTotalJsonObjectCount(); // immediate
        debouncedSaveState(); // Save the cleared state 
    }

    function updateIndividualJsonCount(textarea, statusSpan) {
        const jsonString = textarea.value.trim();
        statusSpan.className = 'json-chapter-status status-message'; // reset

        if (!jsonString) {
            statusSpan.textContent = 'Objects: 0';
            return 0;
        }
        try {
             if (!jsonString.startsWith('[')) throw new Error("Not Array");
            const jsonData = JSON.parse(jsonString);
            if (Array.isArray(jsonData)) {
                statusSpan.textContent = `Objects: ${jsonData.length}`;
                 statusSpan.classList.add('status-success');
                return jsonData.length;
            } else {
                 throw new Error("Not Array");
            }
        } catch (e) {
             if (e.message === "Not Array") {
                statusSpan.textContent = 'Error: Must be an Array []';
                 statusSpan.classList.add('status-warning');
             } else {
                 statusSpan.textContent = 'Error: Invalid JSON';
                 statusSpan.classList.add('status-error');
             }
            return 0;
        }
    }

    function updateTotalJsonObjectCount() {
        const totalCountElement = document.getElementById('jsonObjectsCount');
         let totalObjects = 0;
        document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input').forEach( textarea => {
             const jsonString = textarea.value.trim();
             try { // only count valid json arrays
                 if (jsonString && jsonString.startsWith('[') && jsonString.endsWith(']')) {
                    const jsonData = JSON.parse(jsonString);
                    if (Array.isArray(jsonData)) totalObjects += jsonData.length;
                 }
             } catch (e) { /* ignore invalid json */ }
        });
        totalCountElement.textContent = `Total Objects: ${totalObjects}`;
    }
    
    function updatePlainTextInfo() {
        const plainTextInputArea = document.getElementById('plainTextInputArea');
        const infoElement = document.getElementById('plainTextInfo');
        const maxChars = parseInt(document.getElementById('maxChars').value, 10);
        const text = plainTextInputArea.value;
        const charCount = text.length;
        
        let potentialChunks = 0;
        if (charCount > 0 && maxChars > 0) {
            // This is a rough estimate, actual count depends on smart splitting
            potentialChunks = Math.ceil(charCount / maxChars); 
        } else if (charCount > 0) {
             potentialChunks = 1;
        }
         infoElement.textContent = `Chars: ${charCount} / Approx. Chunks: ${potentialChunks}`;
         if (isNaN(maxChars) || maxChars <= 0) {
             showStatus('plainTextStatus', "Max characters must be > 0", 'warning');
         } else {
             showStatus('plainTextStatus', "", 'info', 1); // clear status
         }
          debouncedSaveState();
    }

     function toggleInputSections() {
        const splitMode = document.getElementById('splitModeSelect').value;
        document.getElementById('jsonInputSection').style.display = (splitMode === 'json' ? 'block' : 'none');
        document.getElementById('plainTextInputSection').style.display = (splitMode === 'text' ? 'block' : 'none');
        document.getElementById('glossaryFindReplaceSection').style.display = (splitMode === 'json' ? 'block' : 'none');
         clearOutput(); // Clear output when switching modes
         if (splitMode === 'json') {
             updateTotalJsonObjectCount();
         } else {
             updatePlainTextInfo();
         }
          debouncedSaveState();
     }
    
     // Apply formatting to text box - keep this behaviour
     function formatPlainText() {
      const formatSelect = document.getElementById('formatSelect');
      const textArea = document.getElementById('plainTextInputArea');
       // Use the saved state as the 'original' when switching back from pretty
       const originalText = currentAppState.plainText || textArea.value; 
       
      if (formatSelect.value === 'pretty') {
         const paragraphs = originalText.split('\n');
         textArea.value = paragraphs.map(p => p.trim()).filter(p => p).join('\n\n');
      } else {
         // Restore the last saved version before 'pretty' was applied
         textArea.value = originalText; 
      }
       updatePlainTextInfo(); // Update count after formatting, triggers save
     }

    // --- Core Logic ---

    function getAllCombinedJsonData() {
        let combinedData = [];
        let allInputsValid = true;
        let allEmpty = true;
        let errorMessages = [];

        document.querySelectorAll('#jsonInputsContainer textarea.json-chapter-input').forEach((textarea, index) => {
            const jsonString = textarea.value.trim();
            if (!jsonString) return;

            allEmpty = false;
            try {
                if (!jsonString.startsWith('[') || !jsonString.endsWith(']')) {
                    throw new Error(`Input ${index + 1} is not a JSON array [ ]`);
                }
                const jsonData = JSON.parse(jsonString);
                if (Array.isArray(jsonData)) {
                    combinedData = combinedData.concat(jsonData);
                } else {
                     throw new Error(`Input ${index + 1} is not a JSON array`);
                }
            } catch (e) {
                 errorMessages.push(e.message);
                 allInputsValid = false;
            }
        });
        
        if(!allInputsValid) {
             showStatus('processStatus', "JSON Error(s): " + errorMessages.join('; '), 'error', 15000);
        }
        return { data: combinedData, success: allInputsValid, allEmpty, errorMessages };
    }

    // NON-DESTRUCTIVE: Applies rules to a copy of the data 
    function applyGlossaryRules(jsonData) {
         const applyRules = document.getElementById('applyRulesCheckbox').checked;
         if (!applyRules || !Array.isArray(jsonData) || jsonData.length === 0) return { data: jsonData, count: 0};

         const caseInsensitive = document.getElementById('caseInsensitiveCheckbox').checked;
         const flags = caseInsensitive ? 'gi' : 'g';
         const rules = [];
         document.querySelectorAll('#findReplacePairsContainer .find-replace-pair').forEach(pairEl => {
             const findText = pairEl.querySelector('.find-text')?.value;
             const replaceText = pairEl.querySelector('.replace-text')?.value ?? ''; // default to empty string
             if (findText) { // Only add rule if find text exists
                 try {
                    rules.push({
                         // Create RegExp safely
                         findRegExp: new RegExp(escapeRegExp(findText), flags), 
                         replace: replaceText
                    });
                 } catch(e) { console.warn("Invalid regex pattern skipped:", findText, e); }
             }
         });

        if (rules.length === 0) return { data: jsonData, count: 0};

        // Create a DEEP COPY to avoid modifying original data reference
        const processedData = JSON.parse(JSON.stringify(jsonData)); 
        let totalInstancesReplaced = 0;

        processedData.forEach(obj => {
            const itemsToProcess = Array.isArray(obj) ? obj : [obj]; // handle potential pre-grouping
            itemsToProcess.forEach(actualItem => {
                 // Specific path: object.terms[].translation
                if (actualItem && Array.isArray(actualItem.terms)) {
                    actualItem.terms.forEach(term => {
                        if (term && typeof term.translation === 'string') {
                            let currentTranslation = term.translation;
                             rules.forEach(rule => {
                                 // Count matches before replacement
                                 const matches = currentTranslation.match(rule.findRegExp);
                                 if(matches) {
                                     totalInstancesReplaced += matches.length;
                                     currentTranslation = currentTranslation.replace(rule.findRegExp, rule.replace);
                                 }
                             });
                             term.translation = currentTranslation; // Apply all changes
                        }
                    });
                }
            });
         });
          showStatus('glossaryReplaceStatus', `Applied ${totalInstancesReplaced} replacements during split.`, 'success');
         return { data: processedData, count: totalInstancesReplaced} ;
     }


    function processAndChunk() {
       clearOutput();
       showLoading();
       // Use timeout to allow loading indicator to render
       setTimeout(() => {
        try {
          const splitMode = document.getElementById('splitModeSelect').value;
          const addToTop = document.getElementById('addToTop').value;
          const addToBottom = document.getElementById('addToBottom').value;
          const container = document.getElementById('chunkedTextContainer');
          let chunkCount = 0;
          
          if (splitMode === 'json') {
             showStatus('glossaryReplaceStatus', "", 'info', 1); // clear previous
             const { data: rawJsonData, success, allEmpty, errorMessages } = getAllCombinedJsonData();
             if (allEmpty) {
                showStatus('processStatus', "All JSON inputs are empty.", 'warning');
             } else if (success && rawJsonData.length > 0) {
                 // *** Apply rules NON-DESTRUCTIVELY here ***
                 const { data: processedJsonData } = applyGlossaryRules(rawJsonData); 
                 chunkCount = chunkJsonInput(processedJsonData, addToTop, addToBottom, container);
                 showStatus('processStatus', `Success: Generated ${chunkCount} JSON chunks.`, 'success');
             } else if (!success) {
                 // Error message already shown by getAllCombinedJsonData
                  showStatus('processStatus', `Chunking aborted due to JSON error(s): ${errorMessages.join('. ')}`, 'error', 15000);
             } else {
                 showStatus('processStatus', "No valid JSON objects found.", 'warning');
             }
          } else { // text mode
             chunkCount = chunkPlainTextInput(addToTop, addToBottom, container);
              if(chunkCount > 0)
                 showStatus('processStatus', `Success: Generated ${chunkCount} text chunks.`, 'success');
          }
           // Show output controls if chunks were generated
           document.getElementById('outputControls').style.display = chunkCount > 0 ? 'flex': 'none';
           document.getElementById('outputSummary').textContent = `Output: ${chunkCount} Chunk${chunkCount===1?'':'s'} Generated`;
           document.getElementById('copyNextButton').disabled = chunkCount === 0;
           document.getElementById('copyAllButton').disabled = chunkCount === 0;


        } catch (error) {
          console.error("Error during chunking:", error);
           showStatus('processStatus', "An unexpected error occurred: " + error.message, 'error', 15000);
        } finally {
          hideLoading();
        }
      }, 50); 
    }

    // returns number of chunks
    function chunkJsonInput(jsonData, addToTop, addToBottom, container) { 
      if (!jsonData || jsonData.length === 0) return 0;
      const objectsToGroup = parseInt(document.getElementById('jsonObjectsPerChunk').value, 10) || 1;
      const totalNewChunks = Math.ceil(jsonData.length / objectsToGroup);
      const newChunkDigits = String(totalNewChunks).length || 1;
      let displayCount = 0;

      for (let i = 0; i < jsonData.length; i += objectsToGroup) {
        const currentGroupOfObjects = jsonData.slice(i, i + objectsToGroup);
        if (currentGroupOfObjects.length === 0) continue; 

        displayCount++;
        const newChunkPartNumber = String(Math.floor(i / objectsToGroup) + 1).padStart(newChunkDigits, '0');
        const firstOriginalGlobalIndex = i + 1; 
        const lastOriginalGlobalIndex = i + currentGroupOfObjects.length;
        let chunkDisplayTitle = `Seg ${newChunkPartNumber}/${totalNewChunks}`;
         if (objectsToGroup > 1 || jsonData.length > 1) {
             chunkDisplayTitle += `\n(Items ${firstOriginalGlobalIndex}-${lastOriginalGlobalIndex})`;
         }
       
        // Stringify single object or array of objects
        const chunkContentString = JSON.stringify(
             objectsToGroup === 1 && currentGroupOfObjects.length === 1 ? currentGroupOfObjects[0] : currentGroupOfObjects,
             null, 2
        );

        const topText = addToTop.replace(/\$X/g, newChunkPartNumber).replace(/\$Y/g, totalNewChunks);
        const bottomText = addToBottom.replace(/\$X/g, newChunkPartNumber).replace(/\$Y/g, totalNewChunks);
        const finalChunk = [topText, chunkContentString, bottomText].filter(Boolean).join('\n\n');
       
        displayChunk(finalChunk.trim(), chunkDisplayTitle, container);
      }
       return displayCount;
    }

    // NEW: Smart Split Logic
    function smartSplit(text, maxLength) {
        if (text.length <= maxLength) return [text];
        const chunks = [];
        let currentText = text;
         const breakChars = ['. ', '! ', '? ', '\n', ' ', ',']; // Priority order

        while (currentText.length > maxLength) {
            let breakPoint = -1;
             for(const char of breakChars) {
                 const index = currentText.lastIndexOf(char, maxLength);
                  // ensure we don't find a break point *after* the limit
                 if(index > 0 && index <= maxLength) { 
                     // include the break char itself if it's punctuation/newline, but not space
                      breakPoint = (char === ' ') ? index : index + char.length;
                      break;
                 }
             }
           
            // If no good break point found, force break at maxLength (mid-word)
            if (breakPoint <= 0 || breakPoint > maxLength) {
                 breakPoint = maxLength;
            }
            chunks.push(currentText.substring(0, breakPoint).trim());
            currentText = currentText.substring(breakPoint).trim(); // start next chunk with remainder
        }
        if (currentText.length > 0) {
            chunks.push(currentText);
        }
        return chunks;
     }

    // returns number of chunks
    function chunkPlainTextInput(addToTop, addToBottom, container) {
       const text = document.getElementById('plainTextInputArea').value; 
       const maxChars = parseInt(document.getElementById('maxChars').value);

       if (!text.trim()) { showStatus('processStatus', "Plain text input is empty.", 'warning'); return 0; }
       if (isNaN(maxChars) || maxChars <= 0) { showStatus('processStatus', "Max characters must be > 0.", 'error'); return 0; }

       const paragraphs = text.split('\n');
       let chunks = [];
       let currentChunk = "";

       paragraphs.forEach(paragraph => {
           // If paragraph itself is too long, smart-split it first
           if (paragraph.length > maxChars) {
               if (currentChunk) chunks.push(currentChunk); // push whatever we had
               chunks = chunks.concat(smartSplit(paragraph, maxChars)); // add all sub-chunks
               currentChunk = ""; // reset
               return; // next paragraph
           }
            // Check if adding the next paragraph exceeds limit
           const potentialLength = currentChunk.length + (currentChunk && paragraph ? 1: 0) + paragraph.length;
           if (currentChunk && potentialLength > maxChars) {
                chunks.push(currentChunk);
                currentChunk = paragraph; // Start new chunk with this paragraph
           } else {
               // Add to current chunk
                currentChunk += (currentChunk && paragraph ? '\n' : '') + paragraph;
                 // preserve empty lines if they don't exceed maxchars
                 if (!paragraph && currentChunk) currentChunk += '\n';
           }
       });

        // Push any remaining content
       if (currentChunk) {
            chunks.push(currentChunk);
       }
       
       // Filter out empty chunks and trim
        chunks = chunks.map(c => c.trim()).filter(Boolean);

       const totalChunks = chunks.length;
        if(totalChunks === 0) return 0;
       const digits = String(totalChunks).length || 1;
        let displayCount = 0;
       chunks.forEach((chunk, index) => {
         displayCount++;
         const partNumber = String(index + 1).padStart(digits, '0');
         const topText = addToTop.replace(/\$X/g, partNumber).replace(/\$Y/g, totalChunks);
         const bottomText = addToBottom.replace(/\$X/g, partNumber).replace(/\$Y/g, totalChunks);
         const finalChunk = [topText, chunk, bottomText].filter(Boolean).join('\n\n');
         displayChunk(finalChunk.trim(), `Part ${partNumber}/${totalChunks}`, container);
       });
        return displayCount;
     }

    // --- Output & Copying ---

     function clearOutput() {
         document.getElementById('chunkedTextContainer').innerHTML = '';
         document.getElementById('outputControls').style.display = 'none';
         lastClickedButton = null; // reset copy state
         showStatus('processStatus', 'Output cleared', 'info', 2000);
         document.getElementById('scrollToTopBtn').style.display = 'none';
     }

     function copyAllChunks() {
        const textareas = document.querySelectorAll('#chunkedTextContainer textarea');
         if (textareas.length === 0) return;
         const separator = "\n\n" + "-".repeat(30) + " END OF CHUNK " + "-".repeat(30) + "\n\n";
         const allText = Array.from(textareas).map(ta => ta.value).join(separator);
         
         // Use a dummy button for state update
          const dummyBtn = document.createElement('button');
          dummyBtn.className = 'copy-button';
         copyToClipboard(allText, dummyBtn, null); 
         showStatus('processStatus', `Copied all ${textareas.length} chunks!`, 'success');
          // Mark all as copied visually
          document.querySelectorAll('.chunk-container').forEach(div => {
               div.dataset.copied = "true";
               div.classList.add('copied');
          });
          document.getElementById('copyNextButton').disabled = true; // all are copied
     }

     function copyNextUncopied() {
          const nextContainer = document.querySelector('.chunk-container[data-copied="false"]');
          if(nextContainer) {
              const textarea = nextContainer.querySelector('textarea');
              const button = nextContainer.querySelector('.copy-button');
              const countDisplay = nextContainer.querySelector('.copy-count-display');
              if(textarea && button) {
                 copyToClipboard(textarea.value, button, countDisplay);
                  // Scroll it roughly to the center
                  nextContainer.scrollIntoView({behavior: 'smooth', block: 'center'});
                   showStatus('processStatus', `Copied next chunk.`, 'success', 2000);
              }
          } else {
               showStatus('processStatus', `All chunks have been copied at least once.`, 'info');
                document.getElementById('copyNextButton').disabled = true;
          }
     }

    function displayChunk(content, title, container) {
        const chunkId = `chunk-${container.children.length + 1}`;
        const chunkContainerDiv = document.createElement('div');
        chunkContainerDiv.classList.add('chunk-container');
        chunkContainerDiv.dataset.copied = "false"; // For "Copy Next"
        chunkContainerDiv.id = chunkId;
        
        chunkContainerDiv.innerHTML = `
         <div class="chunk-title">${title.replace(/\n/g, '<br>')}</div>
         <div class="chunk-textarea-wrapper">
             <textarea readonly>${content}</textarea>
         </div>
         <div class="button-action-wrapper">
            <button class="copy-button" data-copy-count="0">Copy<span class="tick"> ✔️</span></button>
            <span class="copy-count-display">(0)</span>
         </div>
        `;
         const copyButton = chunkContainerDiv.querySelector('.copy-button');
         const countDisplay = chunkContainerDiv.querySelector('.copy-count-display');
         const textarea = chunkContainerDiv.querySelector('textarea');

        copyButton.addEventListener('click', function () {
          copyToClipboard(textarea.value, this, countDisplay); 
        });
       container.appendChild(chunkContainerDiv);
    }

    // Uses modern Clipboard API with fallback
    function copyToClipboard(text, buttonElement, countDisplayElement) {
       navigator.clipboard.writeText(text).then(() => {
           // Success
            if (buttonElement) {
                 updateButtonState(buttonElement);
                 const container = buttonElement.closest('.chunk-container');
                 if(container) {
                     container.dataset.copied = "true"; // Mark as copied
                     container.classList.add('copied'); // Add visual class
                      // Check if ALL are now copied
                     if (!document.querySelector('.chunk-container[data-copied="false"]')) {
                          document.getElementById('copyNextButton').disabled = true;
                     }
                 }
                 if (countDisplayElement) {
                    let count = parseInt(buttonElement.dataset.copyCount, 10) + 1;
                    buttonElement.dataset.copyCount = count.toString();
                    countDisplayElement.textContent = `(${count})`;
                 }
            }
        })
        .catch(err => {
             console.error('Async copy failed:', err);
             // Fallback using older method
             const hiddenInput = document.createElement('textarea');
             hiddenInput.value = text;
             document.body.appendChild(hiddenInput);
             hiddenInput.select();
             try {
                 document.execCommand('copy');
                  // Assume success and update state like above...
                   if (buttonElement) updateButtonState(buttonElement); 
                   showStatus('processStatus', 'Copied (fallback method).', 'info');
              } catch(e) {
                   showStatus('processStatus', 'Failed to copy text.', 'error');
              }
             document.body.removeChild(hiddenInput);
        });
    }

    // --- Initialization ---
     document.addEventListener('DOMContentLoaded', () => {
      
      loadState(); // Load everything first

      // Add listeners that trigger saves or updates
      document.getElementById('maxChars').addEventListener('input', debouncedUpdatePlainTextInfo); // includes save
      document.getElementById('addToTop').addEventListener('input', debouncedSaveState);
      document.getElementById('addToBottom').addEventListener('input', debouncedSaveState);
      document.getElementById('jsonObjectsPerChunk').addEventListener('change', debouncedSaveState);
      document.getElementById('plainTextInputArea').addEventListener('input', debouncedUpdatePlainTextInfo); // includes save
      
      document.getElementById('formatSelect').addEventListener('change', () => {
         // Save the *current* text area content as the 'original' before formatting
         currentAppState.plainText = document.getElementById('plainTextInputArea').value;
         formatPlainText(); // formatPlainText calls updatePlainTextInfo which calls save
      });

      document.getElementById('splitModeSelect').addEventListener('change', toggleInputSections); // includes save

      toggleInputSections(); // Initial display based on loaded state
      // Initial counts based on loaded state
       if (currentAppState.splitMode === 'json') {
         updateTotalJsonObjectCount(); 
       } else {
         updatePlainTextInfo();
       }
        clearOutput(); // Ensure output is clear on load
    });

  </script>
</body>
</html>
