<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenith Term Processor v5.4</title> <!-- Version Bump -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --bg-main: #f0f4f8; 
            --bg-panel: #ffffff;
            --primary-500: #3b82f6; 
            --primary-600: #2563eb; 
            --primary-700: #1d4ed8; 
            --secondary-500: #8b5cf6; 
            --secondary-600: #7c3aed; 
            --success-500: #10b981; 
            --danger-500: #ef4444;  
            --danger-600: #dc2626;  
            --warning-500: #f59e0b; 
            --warning-700: #b45309; 
            --neutral-800: #1f2937; 
            --neutral-700: #374151; 
            --neutral-500: #6b7280; 
            --neutral-300: #d1d5db; 
            --neutral-200: #e5e7eb; 
            --neutral-100: #f3f4f6; 
            --font-sans: 'Inter', sans-serif;
            --radius-md: 0.375rem; 
            --radius-lg: 0.5rem;   
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --transition-base: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: var(--neutral-300); }
        html { font-family: var(--font-sans); font-size: 16px; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;}
        body { margin: 0; background-color: var(--bg-main); color: var(--neutral-700); padding: 1.5rem; }

        .app-container { max-width: 1400px; margin-left: auto; margin-right: auto; }

        .app-title-bar {
            margin-bottom: 2rem; text-align: center; padding: 1.5rem 1rem;
            background: linear-gradient(135deg, var(--primary-600), var(--secondary-600));
            color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
        }
        .app-title-bar h1 { font-size: 2rem; font-weight: 700; letter-spacing: -0.025em;}
        .app-title-bar p { font-size: 0.9rem; opacity: 0.9; margin-top: 0.25rem; }

        .grid-layout { display: grid; gap: 1.5rem; }
        @media (min-width: 1024px) { 
            .grid-layout { grid-template-columns: repeat(3, 1fr); }
            .grid-layout .col-span-1 { grid-column: span 1 / span 1; }
            .grid-layout .col-span-2 { grid-column: span 2 / span 2; }
            .grid-layout .col-span-3 { grid-column: span 3 / span 3; }
        }
         @media (min-width: 768px) and (max-width: 1023px) { 
            .grid-layout { grid-template-columns: repeat(2, 1fr); }
            .grid-layout .md-col-span-1 { grid-column: span 1 / span 1; }
            .grid-layout .md-col-span-2 { grid-column: span 2 / span 2; }
        }

        .panel { background-color: var(--bg-panel); border-radius: var(--radius-lg); box-shadow: var(--shadow-md); padding: 1.5rem; }
        .panel-title { display: flex; align-items: center; font-size: 1.25rem; font-weight: 600; margin-bottom: 1.25rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--neutral-200); color: var(--neutral-800); }
        .panel-title i { margin-right: 0.75rem; color: var(--primary-500); font-size:1.2em; }
        
        .form-group { margin-bottom: 1.25rem; }
        .form-label { display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.375rem; color: var(--neutral-500); }
        
        input[type="text"], textarea, .file-input-wrapper {
            width: 100%; padding: 0.625rem 0.875rem; border-radius: var(--radius-md);
            font-size: 0.875rem; background-color: white; border: 1px solid var(--neutral-300);
            transition: var(--transition-base); color: var(--neutral-700);
        }
        input[type="text"]:focus, textarea:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59,130,246,0.3); 
        }
        textarea { resize: vertical; min-height: 80px; }
        #pastedDedupeList { min-height: 120px; } /* Specific height for dedupe list */


        .file-input-wrapper { position: relative; display: block; }
        .file-input-wrapper input[type="file"] { position: absolute; inset: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .file-input-wrapper .file-display-text { color: var(--neutral-500); }
        .file-input-wrapper .file-display-text.has-file { color: var(--neutral-700); font-weight: 500; }
        .file-input-wrapper i { color: var(--secondary-500); margin-right: 0.5rem; }
        
        .btn-group { display: flex; flex-wrap: wrap; gap: 0.625rem; margin-top: 0.75rem; }
        .btn {
            padding: 0.6rem 1.1rem; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500;
            transition: var(--transition-base); display: inline-flex; align-items: center; justify-content: center;
            gap: 0.4rem; cursor: pointer; line-height: 1.25rem; text-decoration: none;
            box-shadow: var(--shadow-sm); border: 1px solid transparent;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
        .btn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px rgba(59,130,246,0.4); }
        .btn i { font-size:0.9em; }

        .btn-primary { background-color: var(--primary-500); color: white; }
        .btn-primary:hover { background-color: var(--primary-600); }
        .btn-secondary { background-color: var(--secondary-500); color: white; }
        .btn-secondary:hover { background-color: var(--secondary-600); }
        .btn-success { background-color: var(--success-500); color: white; }
        .btn-success:hover { background-color: #059669; /* Emerald 600 */ }
        .btn-danger { background-color: var(--danger-500); color: white; }
        .btn-danger:hover { background-color: var(--danger-600); }
        .btn-outline { background-color: transparent; border-color: var(--neutral-300); color: var(--neutral-500); }
        .btn-outline:hover { background-color: var(--neutral-100); border-color: var(--neutral-500); color:var(--neutral-700); }
        .btn-outline.btn-danger { color: var(--danger-500); border-color: var(--danger-500); }
        .btn-outline.btn-danger:hover { background-color: var(--danger-500); color:white; }


        .btn-icon { padding: 0.5rem; }
        .btn-main-action { 
            padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 600;
            background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
        }
        .btn-main-action:hover {
             background: linear-gradient(135deg, var(--primary-600), var(--primary-700));
        }
        .btn-main-action .spinner { display: none; width: 1.125rem; height: 1.125rem; border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; border-top-color: white; animation: spin 0.7s linear infinite; margin-right: 0.5rem;}
        .btn-main-action.loading .spinner { display: inline-block; }

        @keyframes spin { to { transform: rotate(360deg); } }

        #chapterInputsContainer {
            scrollbar-width: thin; 
            scrollbar-color: var(--neutral-300) var(--neutral-100); 
        }
        #chapterInputsContainer::-webkit-scrollbar { width: 8px; }
        #chapterInputsContainer::-webkit-scrollbar-track { background: var(--neutral-100); border-radius: 4px;}
        #chapterInputsContainer::-webkit-scrollbar-thumb { background-color: var(--neutral-300); border-radius: 4px; border: 2px solid var(--neutral-100); }
        #chapterInputsContainer::-webkit-scrollbar-thumb:hover { background-color: var(--neutral-500); }


        .chapter-input-group { margin-bottom: 1rem; padding: 1rem; border: 1px dashed var(--neutral-300); border-radius: var(--radius-md); background-color: rgba(243,244,246,0.5); } 
        .chapter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .chapter-label { font-weight: 500; font-size:0.9rem; color: var(--secondary-500);}

        .status-message {
            margin-top: 0.75rem; padding: 0.85rem 1.1rem; border-radius: var(--radius-md); font-size: 0.875rem;
            display: flex; align-items: center; gap: 0.6rem; border: 1px solid;
        }
        .status-message i { font-size: 1.2em; }
        .status-success { background-color: #e0f2f1; color: #00796b; border-color: #a7d8c8; } 
        .status-warning { background-color: #fff8e1; color: var(--warning-700); border-color: #ffecb3; } 
        .status-danger  { background-color: #ffebee; color: #c62828; border-color: #ffcdd2; } 
        .status-info    { background-color: #e3f2fd; color: #1565c0; border-color: #bbdefb; } 

        .storage-actions-group {
            margin-top:1rem; padding-top: 1rem; border-top: 1px solid var(--neutral-200);
        }
        .storage-actions-group .form-label { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--neutral-500); margin-bottom: 0.5rem;}

        #processingLog { border: 1px solid var(--neutral-200); background-color: var(--neutral-100); }
        #processingLog strong { color: var(--neutral-700); }
        #processingLog ul { list-style: none; padding: 0; margin:0.5rem 0 0 0; max-height: 150px; overflow-y: auto; font-size: 0.8rem; color:var(--neutral-500);}
        #processingLog li { padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--neutral-200);}
        #processingLog li:last-child { border-bottom: none;}
        #processingLog li i { font-size: 0.9em; margin-right: 0.5rem; opacity: 0.8;}

        .output-actions { display: flex; justify-content: flex-end; gap: 0.75rem; margin-bottom: 0.75rem; }

        .modal-overlay { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.7); display: none; align-items: center; justify-content: center; z-index: 50; backdrop-filter: blur(5px); }
        .modal-overlay.active { display: flex; }
        .modal-content { background-color: var(--bg-panel); padding: 2rem; border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); width: 90%; max-width: 500px; text-align: center; }
        .modal-title { font-size: 1.375rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--neutral-800);}
        .modal-body { font-size: 0.9rem; color: var(--neutral-500); margin-bottom: 1.75rem; line-height: 1.6;}
        .modal-actions { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.75rem; }

        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltip-text {
            visibility: hidden; background-color: var(--neutral-800); color: white; text-align: center;
            border-radius: var(--radius-md); padding: 0.375rem 0.75rem; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.2s;
            font-size: 0.75rem; white-space: nowrap; box-shadow: var(--shadow-md);
        }
        .tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }

        .session-config-grid-internal {
            display: grid;
            gap: 1rem;
            grid-template-columns: 1fr; 
        }
        @media (min-width: 500px) { 
            .session-config-grid-internal {
                grid-template-columns: 1fr 1fr;
            }
        }
        .dedupe-list-actions .btn { flex-grow: 1; } /* Make buttons in dedupe list actions take full width in group */

    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-title-bar">
            <h1><i class="fas fa-microchip"></i> Zenith Term Processor v5.4</h1>
            <p>Intelligent Term Extraction with Centralized Project Deduplication</p>
        </header>

        <div class="grid-layout">
            <!-- Project Setup Panel -->
            <div class="panel col-span-1 md-col-span-1">
                <h2 class="panel-title"><i class="fas fa-folder-tree"></i>Project Control</h2>
                <div class="form-group">
                    <label for="novelNameInput" class="form-label">Novel/Project Name:</label>
                    <input type="text" id="novelNameInput" placeholder="E.g., My Awesome Novel">
                    <small class="form-label" style="margin-top:4px;font-size:0.75rem;">Used for loading/saving the deduplication list below.</small>
                </div>
                <div id="storedTermsInfo" class="status-message status-info" style="display:none; font-size:0.8rem; flex-direction: column; align-items: flex-start;">
                    <!-- Info about stored terms count and size warning appears here -->
                </div>
                
                <div class="storage-actions-group">
                    <h3 class="form-label">External Storage Actions</h3>
                     <div class="btn-group" style="flex-direction: column; gap: 0.5rem;">
                        <button id="exportStoredBtn" onclick="exportPersistentDedupe()" class="btn btn-outline" style="width:100%;">
                            <i class="fas fa-file-export"></i>Export Dedupe List for Project
                        </button>
                        <div class="file-input-wrapper" style="width:100%;">
                            <input type="file" id="importDedupeFile" accept=".json,.txt,.csv" onchange="handleImportDedupeFile(this)">
                            <div class="btn btn-outline file-display-text" id="fileDisplayText_importDedupe" style="width:100%; text-align:left; justify-content: flex-start;">
                                <i class="fas fa-file-import"></i>Import Dedupe List to Textbox...
                            </div>
                        </div>
                        <button id="clearStoredBtn" onclick="confirmClearStorage()" class="btn btn-outline btn-danger" style="width:100%; margin-top: 0.25rem;">
                            <i class="fas fa-trash-alt"></i>Clear Project's Stored Dedupe List
                        </button>
                    </div>
                </div>
            </div>

            <!-- Chapter Input Panel -->
            <div class="panel col-span-1 md-col-span-1">
                <h2 class="panel-title"><i class="fas fa-book-reader"></i>Chapter JSON Input</h2>
                <div id="chapterInputsContainer" style="max-height: 300px; overflow-y: auto; padding-right: 5px;">
                    <!-- Chapter input boxes dynamically added here -->
                </div>
                <div class="btn-group" style="margin-top:1rem;">
                    <button onclick="addChapterInputUI()" class="btn btn-secondary">
                        <i class="fas fa-plus"></i>Add Chapter Box
                    </button>
                </div>
                <div id="jsonStatus" class="status-message" style="display:none; margin-top: 1rem;"></div>
            </div>

            <!-- Deduplication List & Header Panel -->
            <div class="panel col-span-1 md-col-span-2"> 
                <h2 class="panel-title"><i class="fas fa-filter"></i>Deduplication List & Output Header</h2>
                <div class="session-config-grid-internal">
                    <div> <!-- Dedupe Column -->
                        <div class="form-group">
                            <label for="pastedDedupeList" class="form-label">Project Deduplication List (Active & Editable):</label>
                            <textarea id="pastedDedupeList" rows="7" placeholder="Load or paste: term_translation (one per line) OR raw,term_translation[,gender]..."></textarea>
                            <div id="dedupeListStatus" class="status-message" style="display:none; margin-top: 0.5rem;"></div>
                            <div class="btn-group dedupe-list-actions" style="margin-top:0.75rem; gap:0.5rem;">
                                <button id="loadStoredBtn" onclick="loadPersistentDedupeToList()" class="btn btn-outline">
                                    <i class="fas fa-cloud-download-alt"></i>Load from Project Storage
                                </button>
                                <button id="saveListToStoredBtn" onclick="saveDedupeListToPersistentStorage()" class="btn btn-success">
                                    <i class="fas fa-save"></i>Save List to Project Storage
                                </button>
                            </div>
                             <div class="btn-group" style="margin-top:0.5rem;">
                                <div class="tooltip" style="flex-grow:1;">
                                    <button onclick="copyToClipboard('pastedDedupeList', 'dedupeTooltip')" class="btn btn-outline btn-icon" style="width:100%;">
                                        <i class="fas fa-copy"></i> Copy Full List
                                    </button>
                                    <span class="tooltip-text" id="dedupeTooltip">Copy List</span>
                                </div>
                                 <button onclick="clearDedupeListTextarea()" class="btn btn-outline btn-danger" style="flex-grow:1;"><i class="fas fa-times"></i>Clear Textbox</button>
                            </div>
                        </div>
                    </div>
                    <div> <!-- Header Column -->
                        <div class="form-group">
                            <div style="display:flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <input type="checkbox" id="includeCustomHeaderCheckbox" onchange="toggleCustomHeaderInputUI(this.checked)" style="width:auto; height:auto; accent-color: var(--primary-500); transform: scale(1.1);">
                                <label for="includeCustomHeaderCheckbox" class="form-label" style="margin-bottom:0;">Include Custom Output Header</label>
                            </div>
                            <div id="customHeaderInputArea" style="display:none;">
                                <textarea id="editablePresetTextarea" rows="5" placeholder="Enter custom header text..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Extraction Actions & Results Panel -->
            <div class="panel col-span-3 md-col-span-2">
                <h2 class="panel-title"><i class="fas fa-magic-wand-sparkles"></i>Extraction Actions & Results</h2>
                <div style="text-align:center; margin-bottom: 1.5rem;">
                    <button id="mainExtractBtn" onclick="processAllData()" class="btn btn-primary btn-main-action">
                        <span class="spinner"></span>
                        <i class="fas fa-cogs"></i>Extract Terms
                    </button>
                </div>
                <div id="processingLog" class="status-message status-info" style="display:none; margin-bottom:1rem; flex-direction:column; align-items: flex-start;">
                    <strong>Processing Log:</strong>
                    <ul style="width:100%;"></ul>
                </div>

                <hr style="margin: 1.5rem 0; border-color: var(--neutral-200);">
                
                <div class="output-actions">
                     <div class="tooltip">
                        <button id="moveExtractedBtn" onclick="moveExtractedToDedupeList()" class="btn btn-secondary"> <!-- Changed behavior -->
                            <i class="fas fa-share-square"></i>Move Extracted to Dedupe List
                        </button>
                        <span class="tooltip-text" id="moveExtractedTooltip">Add to list above</span>
                    </div>
                    <div class="tooltip">
                         <button onclick="copyOutput('withHeader')" class="btn btn-outline">
                            <i class="fas fa-file-alt"></i>Copy Output with Header
                        </button>
                        <span class="tooltip-text" id="copyHeaderTooltip">Copy with header</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="outputTextarea" class="form-label">Extracted Terms (New & Unique for this session):</label>
                    <textarea id="outputTextarea" rows="8" readonly placeholder="Extracted terms will appear here..."></textarea>
                </div>
                <div id="outputSummary" class="status-message" style="display:none;"></div>
                <!-- saveToStorageBtnContainer is removed as per new workflow -->
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="confirmationModal">
        <div class="modal-content">
            <h3 class="modal-title" id="modalTitle">Confirm Action</h3>
            <p class="modal-body" id="modalMessageText">Are you sure you want to proceed?</p>
            <div class="modal-actions">
                 <button class="btn btn-outline" id="modalCancelBtnGeneric">Cancel</button>
                 <button class="btn btn-danger" id="modalConfirmBtnGeneric">Confirm</button>
            </div>
        </div>
    </div>

    <footer style="text-align:center; padding: 2rem; color: var(--neutral-500); font-size: 0.875rem; margin-top:1.5rem;">
        <p>Â© 2024 Zenith Term Processor. Elevating Your Lexical Workflow.</p>
    </footer>

    <script>
    (function() { // IIFE Start
        // --- Global State & Constants ---
        // persistentDedupeTranslations is no longer used as a global set.
        // The pastedDedupeList textarea becomes the primary source for current dedupe data.
        let chapterInputCounter = 0;
        let lastExtractedPureTerms = []; 
        const LS_NOVEL_NAME_KEY = 'zenithTermExtractor_lastNovelName';
        const LS_DEDUPE_PREFIX = 'zenithTermExtractor_dedupe_'; // Stores array of full lines
        const LS_SIZE_WARNING_PREFIX = 'zenithTermExtractor_sizeWarning_';
        const STORAGE_WARNING_THRESHOLD_BYTES = 3.5 * 1024 * 1024; 

        const DEFAULT_HEADER_TEXT = `"Before replying YOU must think. From now onwards, in your thinking process/thought process/strategizing instead of YOU doing regular thinking, it is imperative that YOU MUST open and activate "Super-Duper-Hyper Thinking Mode". In this mode, you are obligated to: 1) engage in extreme exceptionally extreme thinking 2) engage in extreme exceptionally extreme extensivity 3) extreme exceptionally extreme extensity analysis."\n Go through the whole chat and check what have you translated these in your translation. add pinyin, where and its description and gender about it too. Mention if the  term is not present or cut in half. compare to my translation and let me know the difference reason.`;

        // --- DOM Elements ---
        const novelNameInput = document.getElementById('novelNameInput');
        const editablePresetTextarea = document.getElementById('editablePresetTextarea');
        const outputTextarea = document.getElementById('outputTextarea');
        const pastedDedupeListTextarea = document.getElementById('pastedDedupeList');
        const modalOverlay = document.getElementById('confirmationModal');
        const modalTitleEl = document.getElementById('modalTitle');
        const modalMessageEl = document.getElementById('modalMessageText');
        const modalActionsContainer = modalOverlay.querySelector('.modal-actions');
        let generalConfirmCallback = null;
        let generalCancelCallback = null;


        // --- Utility Functions ---
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            addChapterInputUI(); 
            editablePresetTextarea.value = DEFAULT_HEADER_TEXT;
            const lastNovel = localStorage.getItem(LS_NOVEL_NAME_KEY);
            if (lastNovel) {
                novelNameInput.value = lastNovel;
            }
            updateDynamicButtonLabelsAndInfo(); 

            // Set "Include Custom Output Header" to be ON by default
            const includeCustomHeaderCheckbox = document.getElementById('includeCustomHeaderCheckbox');
            if (includeCustomHeaderCheckbox) {
                includeCustomHeaderCheckbox.checked = true;
                // Ensure the UI (textarea visibility) matches the checkbox state
                toggleCustomHeaderInputUI(includeCustomHeaderCheckbox.checked);
            }

            novelNameInput.addEventListener('keyup', debounce(updateDynamicButtonLabelsAndInfo, 350));

            document.getElementById('modalCancelBtnGeneric').addEventListener('click', () => {
                if(typeof generalCancelCallback === 'function') generalCancelCallback();
                hideGenericModal();
            });
            document.getElementById('modalConfirmBtnGeneric').addEventListener('click', () => {
                if(typeof generalConfirmCallback === 'function') generalConfirmCallback();
                hideGenericModal();
            });
        });
        
        function updateDynamicButtonLabelsAndInfo() {
            updateDynamicButtonLabels();
            updateStoredTermsInfo(); 
        }


        // --- UI Update Functions ---
        function addChapterInputUI() {
            chapterInputCounter++;
            const container = document.getElementById('chapterInputsContainer');
            const itemDiv = document.createElement('div');
            itemDiv.className = 'chapter-input-group';
            itemDiv.id = `chapterGroup_${chapterInputCounter}`;

            const headerDiv = document.createElement('div');
            headerDiv.className = 'chapter-header';
            const label = document.createElement('span');
            label.className = 'chapter-label';
            label.textContent = `Chapter ${chapterInputCounter} JSON`;
            headerDiv.appendChild(label);

            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'chapter-action-buttons'; // Added for potential styling of the group
            buttonGroup.style.display = 'flex'; // Simple styling for horizontal layout
            buttonGroup.style.gap = '0.5rem'; // Space between buttons

            // Paste button (always added)
            const pasteBtn = document.createElement('button');
            pasteBtn.innerHTML = '<i class="fas fa-paste"></i>';
            pasteBtn.className = 'btn btn-icon btn-outline btn-secondary'; // Using btn-secondary for neutral color
            pasteBtn.title = 'Paste from clipboard';
            pasteBtn.style.padding = '0.3rem 0.5rem'; // Consistent padding

            pasteBtn.onclick = async () => {
                const associatedTextarea = itemDiv.querySelector('textarea');
                if (associatedTextarea) {
                    try {
                        const text = await navigator.clipboard.readText();
                        associatedTextarea.value = text;
                        // Optionally, add a small visual feedback if displayStatus can be targeted
                        // For now, no explicit success message to keep it simple as per instructions for non-error cases
                    } catch (err) {
                        console.error('Failed to read clipboard contents: ', err);
                        alert('Failed to paste from clipboard. Please ensure you have granted clipboard permission to this site and are using a compatible browser (e.g., Chrome, Edge, Firefox). The operation might have been blocked by your browser or an extension.');
                    }
                }
            };
            buttonGroup.appendChild(pasteBtn);

            // Clear button (always added)
            const clearBtn = document.createElement('button');
            clearBtn.innerHTML = '<i class="fas fa-times"></i>'; // Using fa-times as suggested
            clearBtn.className = 'btn btn-icon btn-outline btn-danger btn-clear-chapter'; // Specific class
            clearBtn.title = 'Clear this chapter box';
            clearBtn.style.padding = '0.3rem 0.5rem'; // Matching remove button style
            clearBtn.onclick = () => {
                const associatedTextarea = itemDiv.querySelector('textarea');
                if (associatedTextarea) {
                    associatedTextarea.value = '';
                }
            };
            buttonGroup.appendChild(clearBtn);

            if (chapterInputCounter > 1) { 
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<i class="fas fa-minus-circle"></i>';
                removeBtn.className = 'btn btn-icon btn-outline btn-danger';
                removeBtn.style.padding = '0.3rem 0.5rem'; 
                removeBtn.title = 'Remove this chapter box';
                removeBtn.onclick = () => { itemDiv.remove(); };
                buttonGroup.appendChild(removeBtn); // Add to group
            }
            headerDiv.appendChild(buttonGroup); // Add group to header
            itemDiv.appendChild(headerDiv);

            const textarea = document.createElement('textarea');
            textarea.rows = 4;
            textarea.placeholder = `Paste JSON for Chapter ${chapterInputCounter}...`;
            textarea.id = `chapterJson_${chapterInputCounter}`; 
            itemDiv.appendChild(textarea);
            container.appendChild(itemDiv);
            container.scrollTop = container.scrollHeight;
        }
        window.addChapterInputUI = addChapterInputUI;

        function toggleCustomHeaderInputUI(isChecked) {
            document.getElementById('customHeaderInputArea').style.display = isChecked ? 'block' : 'none';
        }
        window.toggleCustomHeaderInputUI = toggleCustomHeaderInputUI;

        function updateDynamicButtonLabels() {
            const novelName = novelNameInput.value.trim() || "Project";
            const isProjectNamed = novelName !== "Project" && novelNameInput.value.trim();

            document.getElementById('loadStoredBtn').innerHTML = `<i class="fas fa-cloud-download-alt"></i>Load from '${novelName}' Storage`;
            document.getElementById('saveListToStoredBtn').innerHTML = `<i class="fas fa-save"></i>Save List to '${novelName}' Storage`;
            document.getElementById('exportStoredBtn').innerHTML = `<i class="fas fa-file-export"></i>Export List for '${novelName}'`;
            document.getElementById('clearStoredBtn').innerHTML = `<i class="fas fa-trash-alt"></i>Clear '${novelName}' Stored List`;
            
            document.getElementById('loadStoredBtn').disabled = !isProjectNamed;
            document.getElementById('saveListToStoredBtn').disabled = !isProjectNamed;
            document.getElementById('exportStoredBtn').disabled = !isProjectNamed;
            document.getElementById('clearStoredBtn').disabled = !isProjectNamed;

            const importFileInput = document.getElementById('importDedupeFile');
            const importFileDisplayButton = document.getElementById('fileDisplayText_importDedupe');
            
            if (!isProjectNamed) { // Allow import to textbox even without project name, but other project actions disabled
                importFileDisplayButton.innerHTML = `<i class="fas fa-file-import"></i>Import List to Textbox...`;
            } else {
                importFileDisplayButton.innerHTML = `<i class="fas fa-file-import"></i>Import List to Textbox for '${novelName}'...`;
            }
             // Import is always to the textbox, so it's generally enabled.
            importFileInput.disabled = false;
            importFileDisplayButton.style.cursor = "pointer";
            importFileDisplayButton.classList.remove('disabled');


            if (isProjectNamed) {
                localStorage.setItem(LS_NOVEL_NAME_KEY, novelNameInput.value.trim());
            }
        }
        
        function updateStoredTermsInfo() {
            const novelName = novelNameInput.value.trim();
            const storedInfoDiv = document.getElementById('storedTermsInfo');
            if (!novelName || novelName === "Project") {
                storedInfoDiv.style.display = 'none';
                return;
            }
            const key = LS_DEDUPE_PREFIX + novelName;
            const storedLinesArray = JSON.parse(localStorage.getItem(key) || '[]');
            let mainInfo = `<div style="display:flex; align-items:center; gap:0.5rem;"><i class="fas fa-database"></i> ${storedLinesArray.length} lines stored for '${novelName}'.</div>`;
            
            const warningKey = LS_SIZE_WARNING_PREFIX + novelName;
            if (localStorage.getItem(warningKey) === 'true') {
                mainInfo += `<div class="status-message status-warning" style="margin-top:0.5rem; padding:0.5rem 0.75rem; font-size:0.8em;">
                                <i class="fas fa-hdd"></i><strong>Storage Alert:</strong> Project data is large.
                                Please <strong>export regularly</strong> and consider managing list size.
                             </div>`;
                storedInfoDiv.classList.remove('status-info', 'status-success'); 
                storedInfoDiv.classList.add('status-warning'); 
            } else {
                 storedInfoDiv.classList.remove('status-warning');
                 storedInfoDiv.classList.add('status-info'); // Default or if no specific status
            }

            storedInfoDiv.innerHTML = mainInfo;
            storedInfoDiv.style.display = 'flex';
        }


        function displayStatus(elementId, message, type = 'info', icon = null) {
            const el = document.getElementById(elementId);
            if (!el) return;
            let iconHtml = '';
            if (icon) iconHtml = `<i class="fas ${icon}"></i>`;
            else { 
                if(type === 'success') iconHtml = '<i class="fas fa-check-circle"></i>';
                else if(type === 'warning') iconHtml = '<i class="fas fa-exclamation-triangle"></i>';
                else if(type === 'danger') iconHtml = '<i class="fas fa-times-circle"></i>';
                else iconHtml = '<i class="fas fa-info-circle"></i>';
            }
            el.innerHTML = `${iconHtml} ${message}`;
            el.className = `status-message status-${type}`; 
            el.style.display = 'flex';
             // Auto-hide info/success messages after a few seconds
            if (type === 'info' || type === 'success') {
                setTimeout(() => {
                    if (el.innerHTML.includes(message)) { // Check if message is still the same
                        hideStatus(elementId);
                    }
                }, 4000);
            }
        }
        function hideStatus(elementId) { 
            const el = document.getElementById(elementId);
            if (el) el.style.display = 'none'; 
        }

        function updateFileDisplay(input, displayId) {
            const display = document.getElementById(displayId); 
            if (!display) return;
            const novelName = novelNameInput.value.trim() || "Project";

            if (input.files && input.files.length > 0) {
                const baseIcon = 'fa-file-import'; // Only one type of import now
                display.innerHTML = `<i class="fas ${baseIcon}"></i> ${input.files[0].name}`;
                display.classList.add('has-file');
            } else {
                // Text for import button
                if (novelName === "Project" || !novelNameInput.value.trim()) {
                    display.innerHTML = `<i class="fas fa-file-import"></i>Import List to Textbox...`;
                } else {
                    display.innerHTML = `<i class="fas fa-file-import"></i>Import List to Textbox for '${novelName}'...`;
                }
                display.classList.remove('has-file');
            }
        }
        window.updateFileDisplay = updateFileDisplay; 
        
        function addProcessingLogStep(message, type = 'info') {
            const logUl = document.querySelector('#processingLog ul');
            if(!logUl) return;
            document.getElementById('processingLog').style.display = 'flex'; 
            const li = document.createElement('li');
            let iconClass = 'fa-info-circle'; 
            let iconColor = 'var(--neutral-500)';

            if (type === 'success') { iconClass = 'fa-check-circle'; iconColor = 'var(--success-500)';}
            else if (type === 'danger') { iconClass = 'fa-times-circle'; iconColor = 'var(--danger-500)';}
            else if (type === 'warning') { iconClass = 'fa-exclamation-triangle'; iconColor = 'var(--warning-500)';}
            
            li.innerHTML = `<i class="fas ${iconClass}" style="color:${iconColor};"></i> ${message}`;
            logUl.appendChild(li);
            logUl.scrollTop = logUl.scrollHeight;
        }
        function clearProcessingLog() { 
            const logUl = document.querySelector('#processingLog ul');
            if (logUl) logUl.innerHTML = '';
            document.getElementById('processingLog').style.display = 'none';
        }

        // --- LocalStorage Interaction (Stores array of full lines) ---
        function getPersistentDedupeLines(novelName) {
            if (!novelName) return [];
            const key = LS_DEDUPE_PREFIX + novelName;
            return JSON.parse(localStorage.getItem(key) || '[]');
        }

        function savePersistentDedupeLines(novelName, linesArray) {
            if (!novelName || novelName === "Project") {
                displayStatus('dedupeListStatus', "Project Name is required to save the list.", 'danger');
                return false;
            }
            const key = LS_DEDUPE_PREFIX + novelName;
            const dataStr = JSON.stringify(linesArray);
            
            const sizeInBytes = new TextEncoder().encode(dataStr).length;
            const warningKey = LS_SIZE_WARNING_PREFIX + novelName;
            if (sizeInBytes > STORAGE_WARNING_THRESHOLD_BYTES) {
                localStorage.setItem(warningKey, 'true');
            } else {
                localStorage.removeItem(warningKey); 
            }
            localStorage.setItem(key, dataStr);
            updateStoredTermsInfo(); 
            return true;
        }
        
        // Renamed from loadPersistentDedupe
        function loadPersistentDedupeToList() {
            const novelName = novelNameInput.value.trim();
            if (!novelName || novelName === "Project") {
                displayStatus('dedupeListStatus', "Please enter a valid Project Name first.", 'warning');
                return;
            }
            const storedLines = getPersistentDedupeLines(novelName);
            pastedDedupeListTextarea.value = storedLines.join('\n');
            displayStatus('dedupeListStatus', `Loaded ${storedLines.length} lines from '${novelName}' storage into the textbox.`, 'success');
            updateStoredTermsInfo(); 
        }
        window.loadPersistentDedupeToList = loadPersistentDedupeToList;

        function saveDedupeListToPersistentStorage() {
            const novelName = novelNameInput.value.trim();
            if (!novelName || novelName === "Project") {
                displayStatus('dedupeListStatus', "Project Name required to save.", 'danger');
                return;
            }

            const linesToSaveFromTextarea = pastedDedupeListTextarea.value.split('\n').map(line => line.trim()).filter(line => line);
            const isTextareaEmpty = linesToSaveFromTextarea.length === 0;

            const currentlyStoredLines = getPersistentDedupeLines(novelName);
            const isStoredListNonEmpty = currentlyStoredLines.length > 0;

            const performSave = () => {
                // savePersistentDedupeLines handles the actual stringify and setItem, and its own success/failure display for novel name
                // It also calls updateStoredTermsInfo() internally after successful save or if storage size warning changes.
                if (savePersistentDedupeLines(novelName, linesToSaveFromTextarea)) {
                    displayStatus('dedupeListStatus', `Saved ${linesToSaveFromTextarea.length} lines to '${novelName}' project storage.`, 'success');
                }
                // updateStoredTermsInfo() is called by savePersistentDedupeLines, so not strictly needed here again,
                // but calling it ensures UI consistency if savePersistentDedupeLines's internal call is missed or conditional.
                updateStoredTermsInfo();
            };

            if (isTextareaEmpty && isStoredListNonEmpty) {
                showGenericModal(
                    `Overwrite Project List for '${novelName}'?`,
                    `The deduplication list textarea is empty. Saving now will replace the currently stored list for project '<strong>${novelName}</strong>' (which contains <strong>${currentlyStoredLines.length} items</strong>) with an empty list. <br><br>Are you sure you want to proceed and overwrite the stored list?`,
                    () => { // onConfirm
                        performSave();
                    },
                    () => { // onCancel
                        displayStatus('dedupeListStatus', 'Save operation cancelled by user.', 'info');
                    }
                );
            } else {
                // Textarea is not empty, OR (textarea is empty AND storage is also empty). Safe to save directly.
                performSave();
            }
        }
        window.saveDedupeListToPersistentStorage = saveDedupeListToPersistentStorage;
        
        function confirmClearStorage() {
            const novelName = novelNameInput.value.trim();
            if (!novelName || novelName === "Project") {
                 displayStatus('storedTermsInfo', "Please enter a valid Project Name to clear its storage.", 'warning'); 
                return;
            }
            showGenericModal(
                `Clear Stored Dedupe List for '${novelName}'?`,
                `This will permanently delete all <strong>${getPersistentDedupeLines(novelName).length} stored lines</strong> for this project. This action cannot be undone. The content in the textbox will NOT be cleared.`,
                () => { 
                    localStorage.removeItem(LS_DEDUPE_PREFIX + novelName);
                    localStorage.removeItem(LS_SIZE_WARNING_PREFIX + novelName); 
                    displayStatus('storedTermsInfo', `Stored list for '${novelName}' cleared.`, 'success');
                    updateStoredTermsInfo();
                }
            );
        }
        window.confirmClearStorage = confirmClearStorage;

        function exportPersistentDedupe() {
            const novelName = novelNameInput.value.trim();
            if (!novelName || novelName === "Project") {
                displayStatus('storedTermsInfo', "Project Name required to export.", 'warning');
                return;
            }
            const dedupeLines = getPersistentDedupeLines(novelName);
            if (dedupeLines.length === 0) {
                displayStatus('storedTermsInfo', `No lines stored for '${novelName}' to export.`, 'info');
                return;
            }

            const dataStr = JSON.stringify(dedupeLines, null, 2);
            const dataBlob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(dataBlob);
            const exportFileDefaultName = `${novelName.replace(/[^a-z0-9]/gi, '_')}_dedupe_list.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', url);
            linkElement.setAttribute('download', exportFileDefaultName);
            document.body.appendChild(linkElement);
            linkElement.click();
            document.body.removeChild(linkElement);
            URL.revokeObjectURL(url);
            displayStatus('storedTermsInfo', `Exported ${dedupeLines.length} lines for '${novelName}'.`, 'success');
        }
        window.exportPersistentDedupe = exportPersistentDedupe;

        function handleImportDedupeFile(fileInput) {
            // Imports directly into the pastedDedupeListTextarea
            const importDisplayId = 'fileDisplayText_importDedupe';

            if (fileInput.files.length === 0) {
                updateFileDisplay(fileInput, importDisplayId); return;
            }
            const file = fileInput.files[0];
            updateFileDisplay(fileInput, importDisplayId);

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    let importedLines = [];
                    if (file.name.toLowerCase().endsWith('.json')) {
                        const parsedJson = JSON.parse(event.target.result);
                        if (!Array.isArray(parsedJson) || !parsedJson.every(item => typeof item === 'string')) {
                            throw new Error('Invalid JSON file. Expected an array of strings.');
                        }
                        importedLines = parsedJson;
                    } else { // Assume .txt or .csv is line-by-line
                        importedLines = event.target.result.split('\n').map(l => l.trim()).filter(l => l);
                    }

                    const currentText = pastedDedupeListTextarea.value.trim();
                    const currentLines = currentText ? currentText.split('\n') : [];

                    showImportOptionsModalToTextarea(importedLines, currentLines.length, (action) => {
                        if (action === 'replace') {
                            pastedDedupeListTextarea.value = importedLines.join('\n');
                            displayStatus('dedupeListStatus', `Replaced textbox with ${importedLines.length} imported lines. Remember to SAVE to project storage if needed.`, 'info');
                        } else if (action === 'merge') {
                            const newText = (currentText ? currentText + '\n' : '') + importedLines.join('\n');
                            pastedDedupeListTextarea.value = newText;
                             displayStatus('dedupeListStatus', `Appended ${importedLines.length} imported lines to textbox. Remember to SAVE to project storage if needed.`, 'info');
                        }
                        fileInput.value = ''; updateFileDisplay(fileInput, importDisplayId);
                    });

                } catch (e) {
                    displayStatus('dedupeListStatus', `Error processing import file: ${e.message}`, 'danger');
                    fileInput.value = ''; updateFileDisplay(fileInput, importDisplayId);
                }
            };
            reader.onerror = function() {
                displayStatus('dedupeListStatus', 'Error reading import file.', 'danger');
                fileInput.value = ''; updateFileDisplay(fileInput, importDisplayId);
            };
            reader.readAsText(file);
        }
        window.handleImportDedupeFile = handleImportDedupeFile;

        function clearDedupeListTextarea() {
            pastedDedupeListTextarea.value = '';
            hideStatus('dedupeListStatus');
        }
        window.clearDedupeListTextarea = clearDedupeListTextarea;


        // --- Main Extraction Logic ---
        async function processAllData() {
            const extractBtn = document.getElementById('mainExtractBtn');
            extractBtn.classList.add('loading');
            extractBtn.disabled = true;
            clearProcessingLog();
            hideStatus('jsonStatus'); hideStatus('outputSummary');
            // document.getElementById('saveToStorageBtnContainer').innerHTML = ''; // Removed this container
            addProcessingLogStep('Extraction process initiated...', 'info');
            
            lastExtractedPureTerms = []; // This will store new `raw,translation,gender` lines
            const chapterTextareas = document.querySelectorAll('#chapterInputsContainer textarea');
            if (chapterTextareas.length === 0 || Array.from(chapterTextareas).every(ta => !ta.value.trim())) {
                displayStatus('jsonStatus', "No chapter JSON provided.", 'warning');
                addProcessingLogStep('No chapter JSON data. Aborted.', 'danger');
                finalizeExtractionUI(extractBtn); return;
            }
            
            // Build deduplication set for THIS RUN from the pastedDedupeListTextarea
            const currentDedupeListContent = pastedDedupeListTextarea.value;
            const dedupeLinesForRun = currentDedupeListContent.split('\n').map(line => line.trim()).filter(line => line);
            const translationsToDeduplicateThisRun = new Set();
            dedupeLinesForRun.forEach(line => {
                const parts = line.split(',').map(part => part.trim());
                // Use translation part (parts[1]) if available, otherwise the whole line if it's a single term
                const translationKey = (parts.length >= 2 && parts[1]) ? parts[1].toLowerCase() : ((parts.length === 1 && parts[0]) ? parts[0].toLowerCase() : null);
                if (translationKey) {
                    translationsToDeduplicateThisRun.add(translationKey);
                }
            });
            addProcessingLogStep(`Using ${translationsToDeduplicateThisRun.size} unique translations from the Deduplication List for current extraction.`, 'info');

            let allChunks = [];
            let chaptersParsedCount = 0;
            for (let i = 0; i < chapterTextareas.length; i++) {
                const chapterJsonStr = chapterTextareas[i].value;
                const chapterGroup = chapterTextareas[i].closest('.chapter-input-group');
                const boxNumber = chapterGroup ? chapterGroup.id.split('_')[1] : i + 1; 
                
                if (!chapterJsonStr.trim()) { addProcessingLogStep(`Chapter Box ${boxNumber} empty. Skipping.`, 'info'); continue; }
                addProcessingLogStep(`Parsing Chapter from Box ${boxNumber}...`, 'info');
                await new Promise(r => setTimeout(r, 10)); 
                try {
                    const parsedChapter = JSON.parse(chapterJsonStr);
                    // Basic structure validation (can be expanded)
                    if (!Array.isArray(parsedChapter) || (parsedChapter.length > 0 && (typeof parsedChapter[0] !== 'object' || !('terms' in parsedChapter[0]) || !Array.isArray(parsedChapter[0].terms)))) {
                         addProcessingLogStep(`Chapter Box ${boxNumber}: Invalid JSON structure. Expected array of objects with a 'terms' array. Skipped.`, 'warning'); continue;
                    }

                    allChunks.push(...parsedChapter);
                    chaptersParsedCount++;
                    addProcessingLogStep(`Box ${boxNumber}: Parsed ${parsedChapter.length} chunks.`, 'success');
                } catch (e) { 
                    addProcessingLogStep(`Chapter Box ${boxNumber}: Invalid JSON. Error: "${e.message}". Skipped.`, 'danger'); 
                }
            }

            if (chaptersParsedCount === 0) {
                displayStatus('jsonStatus', 'No chapters successfully parsed. Check JSON and Processing Log.', 'danger');
                addProcessingLogStep('Failed to parse any chapter data. Aborted.', 'danger');
                finalizeExtractionUI(extractBtn); return;
            }
            addProcessingLogStep(`${chaptersParsedCount} chapters parsed. Extracting terms...`, 'info');

            const seenThisRunTranslations = new Set(); // To avoid duplicates within the same extraction run output
            allChunks.forEach(chunk => {
                if (chunk && Array.isArray(chunk.terms)) {
                    chunk.terms.forEach(term => {
                        const raw = term.raw, translation = term.translation;
                        if (raw && translation) {
                            const translationKey = String(translation).toLowerCase(); 
                            if (!translationsToDeduplicateThisRun.has(translationKey) && !seenThisRunTranslations.has(translationKey)) {
                                seenThisRunTranslations.add(translationKey);
                                let gender = "Neuter"; 
                                if (term.tags && Array.isArray(term.tags)) {
                                    if (term.tags.includes("#male")) gender = "Male";
                                    else if (term.tags.includes("#female")) gender = "Female";
                                }
                                lastExtractedPureTerms.push(`${raw},${translation},${gender}`); // Store full line
                            }
                        }
                    });
                }
            });

            addProcessingLogStep(`Found ${lastExtractedPureTerms.length} new unique terms for this session.`, 'success');
            
            let finalOutputText = "";
            const includeHeader = document.getElementById('includeCustomHeaderCheckbox').checked;
            const headerText = editablePresetTextarea.value.trim();
            if (includeHeader && headerText) {
                finalOutputText += headerText + "\n\n";
            }
            finalOutputText += lastExtractedPureTerms.join('\n');
            outputTextarea.value = finalOutputText;

            if (lastExtractedPureTerms.length > 0) {
                 displayStatus('outputSummary', `Extraction complete: ${lastExtractedPureTerms.length} new unique terms found. Use 'Move Extracted' to add them to the Dedupe List.`, 'success');
            } else {
                 displayStatus('outputSummary', 'Extraction complete. No new unique terms found based on current Deduplication List.', 'info');
            }
            finalizeExtractionUI(extractBtn);
        }
        window.processAllData = processAllData;

        function finalizeExtractionUI(button) {
            button.classList.remove('loading');
            button.disabled = false;
        }

        // --- Output Handling ---
        function moveExtractedToDedupeList() {
            if (lastExtractedPureTerms.length === 0) {
                showTooltipMessage('moveExtractedTooltip', "No terms to move!");
                return;
            }
            const currentDedupeText = pastedDedupeListTextarea.value.trim();
            const newTermsText = lastExtractedPureTerms.join('\n');
            
            pastedDedupeListTextarea.value = (currentDedupeText ? currentDedupeText + '\n' : '') + newTermsText;
            
            displayStatus('dedupeListStatus', `${lastExtractedPureTerms.length} extracted terms added to the Deduplication List textbox. Remember to SAVE to project storage if desired.`, 'info');
            showTooltipMessage('moveExtractedTooltip', "Moved!");
            lastExtractedPureTerms = []; // Clear after moving
            outputTextarea.value = document.getElementById('includeCustomHeaderCheckbox').checked ? editablePresetTextarea.value.trim() + "\n\n" : ""; // Clear output or reset to header
            hideStatus('outputSummary');
        }
        window.moveExtractedToDedupeList = moveExtractedToDedupeList;

        function copyOutput(mode) { // Only 'withHeader' mode effectively remains for direct copy
            let textToCopy = outputTextarea.value; // This now includes header if checked, and only new terms
            let tooltipId = 'copyHeaderTooltip';
            
            if (!textToCopy.trim()) { 
                 showTooltipMessage(tooltipId, "Nothing to copy!"); return;
            }
            performCopy(textToCopy, tooltipId);
        }
        window.copyOutput = copyOutput;
        
        function copyToClipboard(elementId, tooltipId) { 
            const el = document.getElementById(elementId);
            if (!el.value || !el.value.trim()) {
                showTooltipMessage(tooltipId, "Nothing to copy!"); return;
            }
            performCopy(el.value, tooltipId);
        }
        window.copyToClipboard = copyToClipboard;

        function performCopy(text, tooltipId) {
            navigator.clipboard.writeText(text).then(() => {
                showTooltipMessage(tooltipId, "Copied!");
            }).catch(err => {
                console.error('Clipboard copy failed:', err);
                showTooltipMessage(tooltipId, "Copy Failed!");
            });
        }

        function showTooltipMessage(tooltipId, message) {
            const tooltip = document.getElementById(tooltipId);
            if (!tooltip) return;
            const originalText = tooltip.dataset.originalText || tooltip.textContent; 
            if (!tooltip.dataset.originalText) tooltip.dataset.originalText = originalText;

            tooltip.textContent = message;
            tooltip.style.visibility = 'visible'; 
            tooltip.style.opacity = '1';

            setTimeout(() => { 
                tooltip.textContent = tooltip.dataset.originalText;
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '0';
            }, 1500);
        }

        // --- Modal Logic ---
        function showGenericModal(title, message, onConfirm, onCancel = null) {
            modalTitleEl.textContent = title;
            modalMessageEl.innerHTML = message; 
            
            modalActionsContainer.innerHTML = ''; 

            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'btn btn-danger'; // Default to danger for generic confirm
            confirmBtn.textContent = 'Confirm';
            confirmBtn.onclick = () => { if(onConfirm) onConfirm(); hideGenericModal(); };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn btn-outline';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => { if(onCancel) onCancel(); hideGenericModal(); };

            modalActionsContainer.appendChild(cancelBtn);
            modalActionsContainer.appendChild(confirmBtn);
            
            modalOverlay.classList.add('active');
        }

        function hideGenericModal() {
            modalOverlay.classList.remove('active');
            generalConfirmCallback = null; // Clear them
            generalCancelCallback = null;
        }

        function showImportOptionsModalToTextarea(importedLines, currentLineCountInTextarea, callbackOnAction) {
            modalTitleEl.textContent = `Import Lines to Dedupe List Textbox`;
            const importCount = importedLines.length;
            
            const combinedLines = (pastedDedupeListTextarea.value.trim() ? pastedDedupeListTextarea.value.trim().split('\n') : []).concat(importedLines);
            const uniqueCombinedLines = Array.from(new Set(combinedLines)); // Simple uniqueness for display
            const mergedCount = uniqueCombinedLines.length;
            const newLinesInMerge = mergedCount - currentLineCountInTextarea;


            modalMessageEl.innerHTML = `
                You are importing <strong>${importCount} lines</strong>.
                The textbox currently has <strong>${currentLineCountInTextarea} lines</strong>.
                <br><br>Choose an action for the textbox content:
            `;
            
            modalActionsContainer.innerHTML = ''; 

            const replaceBtn = document.createElement('button');
            replaceBtn.className = 'btn btn-warning'; // Use warning for replace
            replaceBtn.innerHTML = `<i class="fas fa-exchange-alt"></i> Replace Textbox (${importCount} total)`;
            replaceBtn.onclick = () => {
                if(callbackOnAction) callbackOnAction('replace');
                hideGenericModal();
            };

            const mergeBtn = document.createElement('button');
            mergeBtn.className = 'btn btn-primary';
            mergeBtn.innerHTML = `<i class="fas fa- Mearge"></i> Append to Textbox (+${importCount} lines)`;
            mergeBtn.onclick = () => {
                 if(callbackOnAction) callbackOnAction('merge');
                hideGenericModal();
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn btn-outline';
            cancelBtn.textContent = 'Cancel Import';
            cancelBtn.onclick = () => { 
                if(callbackOnAction) callbackOnAction('cancel'); // Allow callback to know it was cancelled
                hideGenericModal(); 
            };
            
            modalActionsContainer.appendChild(cancelBtn);
            modalActionsContainer.appendChild(mergeBtn);
            modalActionsContainer.appendChild(replaceBtn);
            
            modalOverlay.classList.add('active');
        }
        
    })(); // IIFE End
    </script>
</body>
</html>
