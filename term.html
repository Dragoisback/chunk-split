<!DOCTYPE html>
<html lang="en" data-theme="light"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenith Term Processor v6.1</title> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --bg-main: #f0f4f8;
            --bg-panel: #ffffff;
            --bg-input: #ffffff;
            --bg-input-hover: #f9fafb;
             --bg-log: #f3f4f6;
            --primary-500: #3b82f6; --primary-600: #2563eb; --primary-700: #1d4ed8;
            --secondary-500: #8b5cf6; --secondary-600: #7c3aed;
            --success-500: #10b981; --success-600: #059669;
            --danger-500: #ef4444;  --danger-600: #dc2626;
            --warning-500: #f59e0b; --warning-700: #b45309;
            --text-main: #374151; --text-light: #6b7280; --text-heading: #1f2937;
            --border-color: #d1d5db; --border-light: #e5e7eb;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --modal-backdrop: rgba(17, 24, 39, 0.7);
             --status-info-bg: #e0f2fe; --status-info-text: #0369a1; --status-info-border: #7dd3fc;
             --status-success-bg: #d1fae5; --status-success-text: #047857; --status-success-border: #6ee7b7;
             --status-warning-bg: #fef3c7; --status-warning-text: #d97706; --status-warning-border: #fcd34d;
             --status-danger-bg: #fee2e2; --status-danger-text: #b91c1c; --status-danger-border: #fca5a5;
             --active-glow: rgba(59, 130, 246, 0.3);
             --header-gradient: linear-gradient(135deg, var(--primary-600), var(--secondary-600));
             --btn-gradient: linear-gradient(135deg, var(--primary-500), var(--primary-600));
             --btn-gradient-hover: linear-gradient(135deg, var(--primary-600), var(--primary-700));
        }
        
        /* CHANGE: DARK MODE */
         [data-theme="dark"] :root {
            --bg-main: #111827;
            --bg-panel: #1f2937;
            --bg-input: #374151;
            --bg-input-hover: #4b5563;
            --bg-log: #374151;
            --text-main: #d1d5db; --text-light: #9ca3af; --text-heading: #f3f4f6;
            --border-color: #4b5563; --border-light: #374151;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --modal-backdrop: rgba(3, 7, 18, 0.85);
            --status-info-bg: #0c4a6e; --status-info-text: #bae6fd; --status-info-border: #38bdf8;
            --status-success-bg: #064e3b; --status-success-text: #a7f3d0; --status-success-border: #34d399;
            --status-warning-bg: #78350f; --status-warning-text: #fde68a; --status-warning-border: #fbbf24;
            --status-danger-bg: #7f1d1d; --status-danger-text: #fecaca; --status-danger-border: #f87171;
             --active-glow: rgba(99, 102, 241, 0.4); /* Indigo for dark mode */
             --header-gradient: linear-gradient(135deg, #4f46e5, #7c3aed); /* Indigo/Violet */
              --btn-gradient: linear-gradient(135deg, #6366f1, #4f46e5);
             --btn-gradient-hover: linear-gradient(135deg, #4f46e5, #4338ca);
        }

        :root {
           --font-sans: 'Inter', sans-serif;
           --radius-md: 0.375rem; --radius-lg: 0.5rem;
           --shadow-sm: 0 1px 2px 0 var(--shadow-color);
           --shadow-md: 0 4px 6px -1px var(--shadow-color), 0 2px 4px -2px var(--shadow-color);
           --shadow-lg: 0 10px 15px -3px var(--shadow-color), 0 4px 6px -4px var(--shadow-color);
           --transition-base: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: var(--border-color); }
        html { font-family: var(--font-sans); font-size: 15px; line-height: 1.6; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; scroll-behavior: smooth;}
        body { margin: 0; background-color: var(--bg-main); color: var(--text-main); padding: 1rem; transition: background-color 0.3s, color 0.3s; }
        h1,h2,h3,p { margin-top:0; margin-bottom: 0.5rem;}

        .app-container { max-width: 1440px; margin: 1rem auto; position: relative; } /* CHANGE: Added position relative for theme toggle */

         /* CHANGE: Theme Toggle */
        .theme-toggle-btn {
            position: absolute; top: 1rem; right: 1rem; z-index: 10;
             background: rgba(255,255,255,0.2); border: none; color: white; width: 36px; height: 36px; border-radius: 50%;
             display: flex; align-items: center; justify-content: center; cursor: pointer; transition: var(--transition-base);
        }
         .theme-toggle-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }
         [data-theme="dark"] .theme-toggle-btn { background: rgba(255,255,255,0.1); color: var(--text-heading);}
          [data-theme="dark"] .theme-toggle-btn:hover { background: rgba(255,255,255,0.2);}
         .theme-toggle-btn .fa-moon { display: block; }
         .theme-toggle-btn .fa-sun { display: none; }
         [data-theme="dark"] .theme-toggle-btn .fa-moon { display: none; }
         [data-theme="dark"] .theme-toggle-btn .fa-sun { display: block; color: #facc15}


        .app-title-bar {
            margin-bottom: 1.5rem; text-align: center; padding: 1.75rem 1rem;
            background: var(--header-gradient);
            color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
             position: relative; /* CHANGE: for theme toggle */
        }
        .app-title-bar h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: -0.025em;}
        .app-title-bar p { font-size: 0.9rem; opacity: 0.9; margin-top: 0.25rem; }

        .grid-layout { display: grid; gap: 1rem; grid-template-columns: 1fr; } /* CHANGE: Mobile first */
        @media (min-width: 768px) {
           .grid-layout { grid-template-columns: repeat(2, 1fr); gap: 1.25rem;}
           .grid-layout .md-col-span-2 { grid-column: span 2 / span 2; }
        }
         @media (min-width: 1024px) {
            .grid-layout { grid-template-columns: repeat(12, 1fr); gap: 1.5rem;} /* CHANGE: 12-col grid */
            /* CHANGE: Refined Spans */
            .grid-layout .lg-span-3 { grid-column: span 3 / span 3; } /* Project */
            .grid-layout .lg-span-4 { grid-column: span 4 / span 4; } /* Chapter */
            .grid-layout .lg-span-5 { grid-column: span 5 / span 5; } /* Dedupe */
            .grid-layout .lg-span-12 { grid-column: span 12 / span 12; } /* Results */
             .grid-layout .md-col-span-2 { grid-column: auto; } /* Reset medium */
        }

        .panel { background-color: var(--bg-panel); border-radius: var(--radius-lg); box-shadow: var(--shadow-md); padding: 1.25rem; overflow: hidden; transition: background-color 0.3s, box-shadow 0.3s; }
        .panel-title { display: flex; align-items: center; font-size: 1.15rem; font-weight: 600; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-light); color: var(--text-heading); }
        .panel-title i { margin-right: 0.75rem; color: var(--primary-500); font-size:1.2em; }
         .panel.active-list {
             border: 1px solid var(--primary-500);
             box-shadow: 0 0 0 3px var(--active-glow), var(--shadow-md);
         }


        .form-group { margin-bottom: 1rem; }
        .form-label { display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.375rem; color: var(--text-light); }
        .form-label-small { font-size:0.75rem; margin-top: 0.25rem; display: block;} /* CHANGE: replace inline style */

        input[type="text"], textarea, .file-input-wrapper-btn {
            width: 100%; padding: 0.625rem 0.875rem; border-radius: var(--radius-md);
            font-size: 0.875rem; background-color: var(--bg-input); border: 1px solid var(--border-color);
            transition: var(--transition-base); color: var(--text-main); font-family: var(--font-sans);
        }
         textarea[readonly] { background-color: var(--bg-log);}
        input[type="text"]:focus, textarea:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            border-color: var(--primary-500); box-shadow: 0 0 0 3px var(--active-glow);
        }
        textarea { resize: vertical; min-height: 80px; }
        #pastedDedupeList { min-height: 150px; }
        #editablePresetTextarea { min-height: 100px;}
        #outputTextarea { min-height: 180px; }

       /* CHANGE: Refined file input */
        .file-input-container { position: relative; width: 100%;}
        .file-input-container input[type="file"] { position: absolute; inset: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; z-index: 2;}
        .file-input-wrapper-btn { /* This is just a styled div/button */
             position: relative; z-index: 1; text-align: left; justify-content: flex-start; width: 100%;
             background-color: var(--bg-input-hover);
        }
         .file-input-wrapper-btn.has-file { color: var(--text-heading); font-weight: 500; background-color: var(--bg-input); }
         .file-input-wrapper-btn i { color: var(--secondary-500); }


        .btn-group { display: flex; flex-wrap: wrap; gap: 0.6rem; margin-top: 0.75rem; }
        .btn-group-col { flex-direction: column; } /* CHANGE: Column layout */
        .btn-group-fill .btn { flex-grow: 1;} /* CHANGE: Fill space */
        .btn {
            padding: 0.6rem 1.1rem; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500;
            transition: var(--transition-base); display: inline-flex; align-items: center; justify-content: center;
            gap: 0.5rem; cursor: pointer; line-height: 1.25rem; text-decoration: none;
            box-shadow: var(--shadow-sm); border: 1px solid transparent; user-select: none;
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: var(--shadow-md); }
        .btn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px var(--active-glow); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none;}
        .btn i { font-size:0.95em; }
        .btn span { display: inline-block; } /* CHANGE: For textContent */

        .btn-primary { background-color: var(--primary-500); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-600); }
        .btn-secondary { background-color: var(--secondary-500); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: var(--secondary-600); }
        .btn-success { background-color: var(--success-500); color: white; }
        .btn-success:hover:not(:disabled) { background-color: var(--success-600); }
         .btn-warning { background-color: var(--warning-500); color: white; }
         .btn-warning:hover:not(:disabled) { background-color: #d97706;}
        .btn-danger { background-color: var(--danger-500); color: white; }
        .btn-danger:hover:not(:disabled) { background-color: var(--danger-600); }
        .btn-outline { background-color: transparent; border-color: var(--border-color); color: var(--text-light); }
        .btn-outline:hover:not(:disabled) { background-color: var(--bg-input-hover); border-color: var(--text-light); color:var(--text-main); }
        .btn-outline.btn-danger { color: var(--danger-500); border-color: var(--danger-500); }
        .btn-outline.btn-danger:hover:not(:disabled) { background-color: var(--danger-500); color:white; }
        .btn-outline.btn-success { color: var(--success-500); border-color: var(--success-500); }
        .btn-outline.btn-success:hover:not(:disabled) { background-color: var(--success-500); color:white; }


        .btn-icon { padding: 0.5rem; min-width: 2.2rem; aspect-ratio: 1/1;}
        .btn-main-action {
            padding: 0.85rem 2rem; font-size: 1.1rem; font-weight: 600;
            background: var(--btn-gradient); color: white;
        }
        .btn-main-action:hover:not(:disabled) {
             background: var(--btn-gradient-hover);
        }
        .btn-main-action .spinner { display: none; width: 1.125rem; height: 1.125rem; border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; border-top-color: white; animation: spin 0.7s linear infinite; margin-right: 0.5rem;}
        .btn-main-action.loading { cursor: wait;}
        .btn-main-action.loading .spinner { display: inline-block; }
        .btn-main-action.loading i { display: none; } /* Hide icon when loading */

        @keyframes spin { to { transform: rotate(360deg); } }

        /* CHANGE: Scrollbar styles moved here */
         .scrollable {
             scrollbar-width: thin;
             scrollbar-color: var(--border-color) var(--bg-input-hover);
             overflow-y: auto;
             padding-right: 5px;
         }
        .scrollable::-webkit-scrollbar { width: 8px; }
        .scrollable::-webkit-scrollbar-track { background: var(--bg-input-hover); border-radius: 4px;}
        .scrollable::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; border: 2px solid var(--bg-input-hover); }
        .scrollable::-webkit-scrollbar-thumb:hover { background-color: var(--text-light); }
         #chapterInputsContainer { max-height: 450px; }
          #processingLog ul { max-height: 200px; }


        .chapter-input-group { margin-bottom: 0.8rem; padding: 0.8rem; border: 1px dashed var(--border-color); border-radius: var(--radius-md); background-color: var(--bg-input-hover); }
        .chapter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .chapter-label { font-weight: 600; font-size:0.9rem; color: var(--secondary-500);}

        .status-message {
            margin-top: 0.75rem; padding: 0.7rem 1rem; border-radius: var(--radius-md); font-size: 0.875rem;
            display: none; /* CHANGE: Hidden by default */
            align-items: center; gap: 0.6rem; border: 1px solid;
        }
         .status-message.visible { display: flex;} /* CHANGE: Visibility class */
         .status-message-col { flex-direction: column; align-items: flex-start; font-size: 0.8rem;} /* CHANGE: Column variant */

        .status-success { background-color: var(--status-success-bg); color: var(--status-success-text); border-color: var(--status-success-border); }
        .status-warning { background-color: var(--status-warning-bg); color: var(--status-warning-text); border-color: var(--status-warning-border); }
        .status-danger  { background-color: var(--status-danger-bg); color: var(--status-danger-text); border-color: var(--status-danger-border); }
        .status-info    { background-color: var(--status-info-bg); color: var(--status-info-text); border-color: var(--status-info-border); }
        .status-message i { font-size: 1.2em; flex-shrink: 0; }

        .storage-actions-group { margin-top:1rem; padding-top: 1rem; border-top: 1px solid var(--border-light); }
        .storage-actions-group .form-label { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-light); margin-bottom: 0.75rem;}

        /* CHANGE: Log styling */
        #processingLog { border: 1px solid var(--border-light); background-color: var(--bg-log); color: var(--text-main); margin-bottom: 1rem; display: none; flex-direction:column; align-items: flex-start; }
        #processingLog.visible { display: flex; }
        #processingLog strong { color: var(--text-heading); }
        #processingLog ul { list-style: none; padding: 0; margin:0.5rem 0 0 0; font-size: 0.8rem; color:var(--text-light); width: 100%;}
        #processingLog li { padding: 0.3rem 0.2rem; display: flex; align-items: center; gap: 0.5rem;}
        #processingLog li:nth-child(even) { background-color: rgba(0,0,0,0.03); }
         [data-theme="dark"] #processingLog li:nth-child(even) { background-color: rgba(255,255,255,0.04); }
        #processingLog li i { font-size: 0.9em; opacity: 0.9; flex-shrink: 0;}
        #processingLog .log-text { flex-grow: 1; word-break: break-word;} /* CHANGE: for textContent */

        .output-actions { display: flex; flex-wrap: wrap; justify-content: flex-end; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-light);}
        .panel-divider { margin: 1.25rem 0; border-color: var(--border-light); border-top-width: 1px;}

        .modal-overlay { position: fixed; inset: 0; background-color: var(--modal-backdrop); display: none; align-items: center; justify-content: center; z-index: 50; backdrop-filter: blur(4px); padding: 1rem; opacity: 0; transition: opacity 0.2s ease-out; }
        .modal-overlay.active { display: flex; opacity: 1; }
        .modal-content { background-color: var(--bg-panel); padding: 1.75rem; border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); width: 100%; max-width: 550px; text-align: center; transform: translateY(20px); transition: transform 0.2s ease-out;}
         .modal-overlay.active .modal-content { transform: translateY(0); }
        .modal-title { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-heading);}
        .modal-body { font-size: 0.9rem; color: var(--text-light); margin-bottom: 1.5rem; line-height: 1.6; text-align: left;}
         .modal-body strong { color: var(--text-main); }
        .modal-actions { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.75rem; }

        .tooltip { position: relative; display: inline-flex; /* CHANGE: inline-flex */ }
        .tooltip .tooltip-text {
            visibility: hidden; background-color: var(--text-heading); color: var(--bg-panel); text-align: center;
            border-radius: var(--radius-md); padding: 0.3rem 0.7rem; position: absolute; z-index: 10;
            bottom: 120%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.2s, visibility 0.2s, bottom 0.2s;
            font-size: 0.75rem; white-space: nowrap; box-shadow: var(--shadow-md);
        }
         .tooltip .tooltip-text::after { /* Arrow */
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: var(--text-heading) transparent transparent transparent;
         }
        .tooltip:hover .tooltip-text:not(.force-visible) { visibility: visible; opacity: 1; bottom: 125%; } /* CHANGE: allow force-visible */
        .tooltip .tooltip-text.force-visible {visibility: visible; opacity: 1; bottom: 125%; } /* CHANGE: For JS messages */

         /* CHANGE: Checkbox styling */
        .checkbox-group { display:flex; align-items: center; gap: 0.7rem; margin-bottom: 0.5rem;}
        .checkbox-group input[type="checkbox"] { width: 1.1rem; height: 1.1rem; accent-color: var(--primary-500); margin: 0; cursor: pointer;}
         .checkbox-group .form-label { margin-bottom: 0; cursor: pointer; user-select: none;}
         .header-input-area { margin-top: 0.5rem; display: none;}
         .header-input-area.visible { display: block;}

        .footer { text-align:center; padding: 2rem 1rem; color: var(--text-light); font-size: 0.85rem; margin-top:1.5rem;}
        .dedupe-actions-row { justify-content: space-between; align-items: center;}
        .dedupe-actions-row .btn-group { margin-top: 0;}
        .width-full { width: 100%;} /* CHANGE: replace inline style */

    </style>
</head>

<body>
    <div class="app-container">
        <header class="app-title-bar">
             <button id="themeToggleBtn" class="theme-toggle-btn" aria-label="Toggle dark mode">
                 <i class="fas fa-moon"></i>
                 <i class="fas fa-sun"></i>
            </button>
            <h1><i class="fas fa-microchip"></i> Zenith Term Processor v6.1</h1>
            <p>Intelligent Term Extraction with Centralized Project Deduplication</p>
        </header>

        <div class="grid-layout">
            <div class="panel lg-span-3">
                <h2 class="panel-title"><i class="fas fa-folder-tree"></i>Project Control</h2>
                <div class="form-group">
                    <label for="novelNameInput" class="form-label">Novel/Project Name:</label>
                    <input type="text" id="novelNameInput" placeholder="E.g., My Awesome Novel">
                    <small class="form-label form-label-small">Used for loading/saving list & header.</small>
                </div>
                 <div id="storedTermsInfo" class="status-message status-message-col status-info"></div>

                <div class="storage-actions-group">
                    <h3 class="form-label">External Storage Actions</h3>
                     <div class="btn-group btn-group-col width-full">
                        <button id="exportStoredBtn" class="btn btn-outline width-full">
                            <i class="fas fa-file-export"></i><span>Export List for Project</span>
                        </button>
                         <div class="file-input-container">
                             <input type="file" id="importDedupeFile" accept=".json,.txt,.csv" aria-label="Import Deduplication List File">
                              <div class="btn btn-outline file-input-wrapper-btn" id="fileDisplayText_importDedupe" tabindex="-1">
                                   <i class="fas fa-file-import"></i><span>Import List to Textbox...</span>
                              </div>
                        </div>
                        <button id="clearStoredBtn" class="btn btn-outline btn-danger width-full">
                            <i class="fas fa-trash-alt"></i><span>Clear Project's Stored List</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="panel lg-span-4">
                <h2 class="panel-title"><i class="fas fa-book-reader"></i>Chapter JSON Input</h2>
                 <div id="chapterInputsContainer" class="scrollable">
                    </div>
                <div class="btn-group">
                     <button id="addChapterBtn" class="btn btn-secondary">
                        <i class="fas fa-plus"></i><span>Add Chapter Box</span>
                    </button>
                </div>
                 <div id="jsonStatus" class="status-message"></div>
            </div>

            <div class="panel lg-span-5 md-col-span-2 active-list">
                <h2 class="panel-title"><i class="fas fa-filter"></i>Active Deduplication List & Header</h2>
                 <div class="form-group">
                    <label for="pastedDedupeList" class="form-label">Project Deduplication List (Source of Truth):</label>
                     <div class="btn-group btn-group-fill dedupe-actions-row" >
                         <div class="btn-group">
                             <button id="loadStoredBtn" class="btn btn-outline">
                                <i class="fas fa-cloud-download-alt"></i><span>Load</span>
                            </button>
                             <button id="saveListToStoredBtn" class="btn btn-outline btn-success">
                                <i class="fas fa-save"></i><span>Save</span>
                             </button>
                         </div>
                          <div class="btn-group">
                             <button id="cleanListBtn" class="btn btn-outline" title="Sort and remove duplicates based on raw, translation, and gender.">
                                <i class="fas fa-broom"></i><span>Clean List</span>
                            </button>
                            <div class="tooltip">
                                <button id="copyDedupeBtn" class="btn btn-outline btn-icon" aria-label="Copy Deduplication List">
                                     <i class="fas fa-copy"></i>
                                </button>
                                <span class="tooltip-text" id="dedupeTooltip">Copy List</span>
                             </div>
                             <button id="clearDedupeTextBtn" class="btn btn-outline btn-danger btn-icon" aria-label="Clear Textbox">
                                <i class="fas fa-times"></i>
                             </button>
                          </div>
                     </div>
                    <textarea id="pastedDedupeList" rows="7" placeholder="Load, paste or import: term_translation OR raw,term_translation[,gender]... This is the active list used for extraction."></textarea>
                     <div id="dedupeListStatus" class="status-message"></div>
                 </div>

                 <hr class="panel-divider"> <div class="form-group">
                     <div class="checkbox-group">
                        <input type="checkbox" id="includeCustomHeaderCheckbox">
                        <label for="includeCustomHeaderCheckbox" class="form-label">Include Custom Output Header</label>
                    </div>
                     <div id="customHeaderInputArea" class="header-input-area">
                         <label for="editablePresetTextarea" class="form-label form-label-small">Header Text (Saved with Project):</label>
                        <textarea id="editablePresetTextarea" rows="4" placeholder="Enter custom header text..."></textarea>
                    </div>
                </div>
            </div>

            <div class="panel lg-span-12 md-col-span-2">
                <h2 class="panel-title"><i class="fas fa-wand-magic-sparkles"></i>Extraction Actions & Results</h2>
                 <div style="text-align:center; margin-bottom: 1.5rem;">
                     <button id="mainExtractBtn" class="btn btn-primary btn-main-action">
                        <span class="spinner"></span>
                        <i class="fas fa-cogs"></i><span>Extract New Terms</span>
                    </button>
                </div>
                <div id="processingLog" class="status-message status-info">
                    <strong>Processing Log:</strong>
                    <ul class="scrollable"></ul>
                </div>

                <div class="output-actions">
                     <div class="tooltip">
                         <button id="moveAndSaveBtn" class="btn btn-success">
                            <i class="fas fa-file-import"></i><i class="fas fa-save" style="font-size:0.7em; margin-left:-0.2em"></i> <span>Move & Save</span>
                        </button>
                        <span class="tooltip-text" id="moveSaveTooltip">Move to list, Clean, & Save to storage</span>
                    </div>
                    <div class="tooltip">
                         <button id="moveExtractedBtn" class="btn btn-secondary">
                            <i class="fas fa-share-square"></i><span>Move Extracted</span>
                        </button>
                        <span class="tooltip-text" id="moveExtractedTooltip">Add to list & Clean (No Save)</span>
                    </div>
                     <div class="tooltip">
                         <button id="copyOutputBtn" class="btn btn-outline">
                            <i class="fas fa-copy"></i><span>Copy Output</span>
                        </button>
                        <span class="tooltip-text" id="copyHeaderTooltip">Copy output with header (if checked)</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="outputTextarea" class="form-label">Extracted Terms Output (New & Unique for this session):</label>
                    <textarea id="outputTextarea" rows="8" readonly placeholder="Extracted terms will appear here..."></textarea>
                </div>
                 <div id="outputSummary" class="status-message"></div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="confirmationModal">
        <div class="modal-content">
            <h3 class="modal-title" id="modalTitle">Confirm Action</h3>
            <p class="modal-body" id="modalMessageText">Are you sure you want to proceed?</p>
            <div class="modal-actions" id="modalActions">
                  </div>
        </div>
    </div>

    <footer class="footer">
        <p>© 2024 Zenith Term Processor. Elevating Your Lexical Workflow.</p>
    </footer>

    <script>
    (function() { // IIFE Start
        // --- CHANGE: Constants ---
        const CONST = {
             LS_NOVEL_NAME_KEY: 'zenithTermExtractor_lastNovelName',
             LS_DEDUPE_PREFIX: 'zenithTermExtractor_dedupe_',
             LS_HEADER_PREFIX: 'zenithTermExtractor_header_', // CHANGE: Header persistence
             LS_SIZE_WARNING_PREFIX: 'zenithTermExtractor_sizeWarning_',
             LS_THEME_KEY: 'zenithTermExtractor_theme', // CHANGE: Theme
             STORAGE_WARNING_THRESHOLD_BYTES: 3.5 * 1024 * 1024,
             DEFAULT_HEADER_TEXT: `"Before replying YOU must think. From now onwards, in your thinking process/thought process/strategizing instead of YOU doing regular thinking, it is imperative that YOU MUST open and activate "Super-Duper-Hyper Thinking Mode". In this mode, you are obligated to: 1) engage in extreme exceptionally extreme thinking 2) engage in extreme exceptionally extreme extensivity 3) extreme exceptionally extreme extensity analysis."\n Go through the whole chat and check what have you translated these in your translation. add pinyin, where and its description and gender about it too. Mention if the  term is not present or cut in half. compare to my translation and let me know the difference reason.`,
             STATUS: { INFO: 'info', SUCCESS: 'success', WARNING: 'warning', DANGER: 'danger'},
             MODAL: { REPLACE: 'replace', MERGE: 'merge', CANCEL: 'cancel'},
             LOG_TYPE: { INFO: 'info', SUCCESS: 'success', WARNING: 'warning', DANGER: 'danger', START: 'start', END: 'end'},
             VISIBLE_CLASS: 'visible',
        };
        const ICONS = { // CHANGE: Icon map
             [CONST.STATUS.SUCCESS]: 'fa-check-circle', [CONST.STATUS.WARNING]: 'fa-exclamation-triangle',
             [CONST.STATUS.DANGER]: 'fa-times-circle', [CONST.STATUS.INFO]: 'fa-info-circle',
             [CONST.LOG_TYPE.START]: 'fa-play-circle', [CONST.LOG_TYPE.END]: 'fa-flag-checkered',
        };
         const LOG_COLORS = { // CHANGE: Log color map
              [CONST.LOG_TYPE.SUCCESS]: 'var(--success-500)', [CONST.LOG_TYPE.DANGER]: 'var(--danger-500)',
              [CONST.LOG_TYPE.WARNING]: 'var(--warning-500)', [CONST.LOG_TYPE.INFO]: 'var(--text-light)',
              [CONST.LOG_TYPE.START]: 'var(--primary-500)', [CONST.LOG_TYPE.END]: 'var(--secondary-500)',
         };

        // --- State ---
        let chapterInputCounter = 0;
        let lastExtractedPureTerms = [];
        const statusTimeouts = {}; // CHANGE: Store timeout IDs
        const tooltipTimeouts = {}; // CHANGE: Store timeout IDs

        // --- CHANGE: Cache DOM Elements ---
        const EL = {
             novelNameInput: document.getElementById('novelNameInput'),
             editablePresetTextarea: document.getElementById('editablePresetTextarea'),
             includeCustomHeaderCheckbox: document.getElementById('includeCustomHeaderCheckbox'),
             customHeaderInputArea: document.getElementById('customHeaderInputArea'),
             outputTextarea: document.getElementById('outputTextarea'),
             pastedDedupeListTextarea: document.getElementById('pastedDedupeList'),
             modalOverlay: document.getElementById('confirmationModal'),
             modalTitleEl: document.getElementById('modalTitle'),
             modalMessageEl: document.getElementById('modalMessageText'),
             modalActionsContainer: document.getElementById('modalActions'),
             chapterInputsContainer : document.getElementById('chapterInputsContainer'),
             storedTermsInfo: document.getElementById('storedTermsInfo'),
             jsonStatus: document.getElementById('jsonStatus'),
             dedupeListStatus: document.getElementById('dedupeListStatus'),
             outputSummary: document.getElementById('outputSummary'),
             processingLog: document.getElementById('processingLog'),
             logUl: document.querySelector('#processingLog ul'),
             // Buttons
             themeToggleBtn: document.getElementById('themeToggleBtn'),
             exportStoredBtn: document.getElementById('exportStoredBtn'),
             importDedupeFile: document.getElementById('importDedupeFile'),
             fileDisplayText_importDedupe: document.getElementById('fileDisplayText_importDedupe'),
             clearStoredBtn: document.getElementById('clearStoredBtn'),
             addChapterBtn: document.getElementById('addChapterBtn'),
             loadStoredBtn: document.getElementById('loadStoredBtn'),
             saveListToStoredBtn: document.getElementById('saveListToStoredBtn'),
             cleanListBtn: document.getElementById('cleanListBtn'), // New
             copyDedupeBtn: document.getElementById('copyDedupeBtn'), // New
             clearDedupeTextBtn: document.getElementById('clearDedupeTextBtn'),
             mainExtractBtn: document.getElementById('mainExtractBtn'),
             moveExtractedBtn: document.getElementById('moveExtractedBtn'),
             moveAndSaveBtn: document.getElementById('moveAndSaveBtn'), // New
             copyOutputBtn: document.getElementById('copyOutputBtn'),
             // Tooltips
             dedupeTooltip: document.getElementById('dedupeTooltip'),
             moveExtractedTooltip: document.getElementById('moveExtractedTooltip'),
             moveSaveTooltip: document.getElementById('moveSaveTooltip'), // New
             copyHeaderTooltip: document.getElementById('copyHeaderTooltip'),
        };

        // --- Utility Functions ---
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }
        // CHANGE: Safer element content
        function setElementContent(el, iconClass, text) {
             if(!el) return;
             el.innerHTML = ''; // Clear
             if(iconClass) {
                const i = document.createElement('i');
                i.className = `fas ${iconClass}`;
                el.appendChild(i);
             }
             if(text) {
                const span = document.createElement('span'); // use span for button text
                span.textContent = ' ' + text; // Safe
                el.appendChild(span);
             }
        }
         // CHANGE: Create safe element for log / status
         function createIconTextNode(iconClass, text, color = null) {
             const fragment = document.createDocumentFragment();
             const icon = document.createElement('i');
             icon.className = `fas ${iconClass}`;
             if(color) icon.style.color = color;
             fragment.appendChild(icon);
             const textSpan = document.createElement('span');
             textSpan.className = 'log-text';
             textSpan.textContent = text; // SAFE
             fragment.appendChild(textSpan);
             return fragment;
         }
         // CHANGE: Safer Modal Body (allows basic HTML like <strong> but requires care)
         // Basic sanitiser - only use if <strong> etc is essential and source is trusted-ish
          function createSafeHTML(htmlString) {
             const parser = new DOMParser();
             const doc = parser.parseFromString(htmlString, 'text/html');
             // Further sanitisation could be added here (remove scripts, onXXX attributes)
             return doc.body.innerHTML; // Still use with caution
          }


         // --- CHANGE: LocalStorage Wrappers (Robustness) ---
         function safeSetItem(key, value) {
            try { localStorage.setItem(key, value); return true; }
            catch (e) {
               console.error("LocalStorage Set Error:", key, e);
               displayStatus(EL.storedTermsInfo.id, `Storage Error: Could not save data (Quota full or storage disabled?). ${e.name}`, CONST.STATUS.DANGER, null, 10000);
               return false;
            }
         }
          function safeGetItem(key) {
            try { return localStorage.getItem(key); }
            catch (e) { console.error("LocalStorage Get Error:", key, e); return null; }
         }
          function safeRemoveItem(key) {
            try { localStorage.removeItem(key); return true; }
             catch (e) { console.error("LocalStorage Remove Error:", key, e); return false; }
         }

        // --- Initialization & Event Listeners ---
        document.addEventListener('DOMContentLoaded', init);

        function init() {
             // Theme
             const savedTheme = safeGetItem(CONST.LS_THEME_KEY) || 'light';
             applyTheme(savedTheme);
             EL.themeToggleBtn.addEventListener('click', toggleTheme);

            addChapterInputUI();
            const lastNovel = safeGetItem(CONST.LS_NOVEL_NAME_KEY);
            if (lastNovel) {
                EL.novelNameInput.value = lastNovel;
            }
            // Load header state *after* novel name is set
            loadProjectHeaderState(EL.novelNameInput.value.trim());
            updateDynamicButtonLabelsAndInfo();

            // CHANGE: Debounce and Save Header
            const debouncedUpdate = debounce( () => {
                 updateDynamicButtonLabelsAndInfo();
                 loadProjectHeaderState(EL.novelNameInput.value.trim()); // Reload header when name changes
            }, 400);
            const debouncedSaveHeader = debounce( () => {
                 saveProjectHeaderState(EL.novelNameInput.value.trim());
            }, 500);

            EL.novelNameInput.addEventListener('keyup', debouncedUpdate);
            EL.editablePresetTextarea.addEventListener('keyup', debouncedSaveHeader);
            EL.includeCustomHeaderCheckbox.addEventListener('change', (event) => {
                 toggleCustomHeaderInputUI(event.target.checked)
                 debouncedSaveHeader(); // Save checkbox state change immediately
            });
             // CHANGE: Add all Event Listeners
             EL.addChapterBtn.addEventListener('click', addChapterInputUI);
             EL.exportStoredBtn.addEventListener('click', exportPersistentDedupe);
             EL.importDedupeFile.addEventListener('change', (e) => handleImportDedupeFile(e.target));
             EL.clearStoredBtn.addEventListener('click', confirmClearStorage);
             EL.loadStoredBtn.addEventListener('click', loadPersistentDedupeToList);
             EL.saveListToStoredBtn.addEventListener('click', saveDedupeListToPersistentStorage);
             EL.cleanListBtn.addEventListener('click', cleanDedupeListTextarea); // New
             EL.clearDedupeTextBtn.addEventListener('click', clearDedupeListTextarea);
             EL.mainExtractBtn.addEventListener('click', processAllData);
             EL.moveExtractedBtn.addEventListener('click', () => moveExtractedToDedupeList(false)); // Pass save flag
             EL.moveAndSaveBtn.addEventListener('click', () => moveExtractedToDedupeList(true)); // New: Pass save flag
             EL.copyOutputBtn.addEventListener('click', () => copyOutput());
             EL.copyDedupeBtn.addEventListener('click', () => copyToClipboard(EL.pastedDedupeListTextarea, EL.dedupeTooltip.id));
             // Allow clicking the button label to trigger file input
             EL.fileDisplayText_importDedupe.addEventListener('click', () => EL.importDedupeFile.click());
             // Close modal on backdrop click
             EL.modalOverlay.addEventListener('click', (e) => {
                 if(e.target === EL.modalOverlay) hideGenericModal();
             });
        }

         // CHANGE: Theme Management
         function applyTheme(theme) { document.documentElement.setAttribute('data-theme', theme); }
         function toggleTheme() {
             const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
             const newTheme = currentTheme === 'light' ? 'dark' : 'light';
             applyTheme(newTheme);
             safeSetItem(CONST.LS_THEME_KEY, newTheme);
         }


        function updateDynamicButtonLabelsAndInfo() {
            updateDynamicButtonLabels();
            updateStoredTermsInfo();
        }

        // --- UI Update Functions ---
         // CHANGE: Chapter re-indexing and button creation
        function addChapterInputUI() {
            chapterInputCounter++;
            const itemDiv = document.createElement('div');
            itemDiv.className = 'chapter-input-group';
            // itemDiv.id = `chapterGroup_${chapterInputCounter}`; // ID not strictly needed now

            const headerDiv = document.createElement('div');
            headerDiv.className = 'chapter-header';
            const label = document.createElement('span');
            label.className = 'chapter-label';
             // label.textContent = `Chapter ${chapterInputCounter} JSON`; // Set in reindex
            headerDiv.appendChild(label);

             // Always create remove button, reindex controls visibility
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-icon btn-outline btn-danger remove-chapter-btn';
            removeBtn.setAttribute('aria-label', 'Remove this chapter box'); // A11y
            const icon = document.createElement('i'); icon.className = 'fas fa-minus-circle';
            removeBtn.appendChild(icon);
            removeBtn.addEventListener('click', () => { // CHANGE: Use addEventListener
                 itemDiv.remove();
                 reindexChapterLabels(); // CHANGE: Reindex on remove
            });
            headerDiv.appendChild(removeBtn);

            itemDiv.appendChild(headerDiv);
            const textarea = document.createElement('textarea');
            textarea.rows = 3;
            // textarea.placeholder = `Paste JSON for Chapter ${chapterInputCounter}...`; // Set in reindex
            textarea.id = `chapterJson_${chapterInputCounter}`; // Keep ID just in case
            itemDiv.appendChild(textarea);
            EL.chapterInputsContainer.appendChild(itemDiv);
            EL.chapterInputsContainer.scrollTop = EL.chapterInputsContainer.scrollHeight;
             reindexChapterLabels(); // CHANGE: Reindex on add
        }

         // CHANGE: New function to re-number chapter boxes
         function reindexChapterLabels() {
             const groups = EL.chapterInputsContainer.querySelectorAll('.chapter-input-group');
              groups.forEach((group, index) => {
                  const label = group.querySelector('.chapter-label');
                  const textarea = group.querySelector('textarea');
                  const removeBtn = group.querySelector('.remove-chapter-btn');
                  const newIndex = index + 1;
                  if(label) label.textContent = `Chapter ${newIndex} JSON`;
                  if(textarea) textarea.placeholder = `Paste JSON for Chapter ${newIndex}...`;
                   if(removeBtn) {
                       // Hide remove button if only one box exists
                      removeBtn.style.display = groups.length > 1 ? 'inline-flex': 'none';
                   }
              });
         }

        function toggleCustomHeaderInputUI(isChecked) {
             // CHANGE: Use class for visibility
            EL.customHeaderInputArea.classList.toggle(CONST.VISIBLE_CLASS, isChecked);
        }

         // CHANGE: Use textContent for safety (XSS)
        function updateDynamicButtonLabels() {
            const novelName = EL.novelNameInput.value.trim();
            const displayName = novelName || "Project";
            const isProjectNamed = !!novelName; // Boolean check

            setElementContent(EL.loadStoredBtn, 'fa-cloud-download-alt', `Load from '${displayName}'`);
            setElementContent(EL.saveListToStoredBtn, 'fa-save', `Save to '${displayName}'`);
            setElementContent(EL.exportStoredBtn, 'fa-file-export',`Export List for '${displayName}'`);
            setElementContent(EL.clearStoredBtn, 'fa-trash-alt', `Clear '${displayName}' Stored List`);

            EL.loadStoredBtn.disabled = !isProjectNamed;
            EL.saveListToStoredBtn.disabled = !isProjectNamed;
            EL.exportStoredBtn.disabled = !isProjectNamed;
            EL.clearStoredBtn.disabled = !isProjectNamed;
            EL.moveAndSaveBtn.disabled = !isProjectNamed; // New button

            updateFileDisplay(EL.importDedupeFile, EL.fileDisplayText_importDedupe.id); // Update import text

            if (isProjectNamed) {
                safeSetItem(CONST.LS_NOVEL_NAME_KEY, novelName);
            } else {
                 safeRemoveItem(CONST.LS_NOVEL_NAME_KEY); // Clear if name is empty
            }
        }

         // CHANGE: Use textContent / element creation (XSS)
        function updateStoredTermsInfo() {
            const novelName = EL.novelNameInput.value.trim();
            EL.storedTermsInfo.innerHTML = ''; // Clear safely
            if (!novelName) {
                EL.storedTermsInfo.classList.remove(CONST.VISIBLE_CLASS);
                return;
            }
            const key = CONST.LS_DEDUPE_PREFIX + novelName;
            const storedData = safeGetItem(key);
            const storedLinesArray = JSON.parse(storedData || '[]');
            let count = storedLinesArray.length;

            const mainInfo = document.createElement('div');
            mainInfo.style.cssText = "display:flex; align-items:center; gap:0.5rem;";
            mainInfo.appendChild(createIconTextNode('fa-database', `${count} lines stored for '${novelName}'.`));
            EL.storedTermsInfo.appendChild(mainInfo);

            const warningKey = CONST.LS_SIZE_WARNING_PREFIX + novelName;
             EL.storedTermsInfo.classList.remove('status-warning', 'status-info'); // Reset
            if (safeGetItem(warningKey) === 'true') {
                 const warnDiv = document.createElement('div');
                 warnDiv.className = "status-message status-warning visible"; // Add visible
                 warnDiv.style.cssText ="margin-top:0.5rem; padding:0.5rem 0.75rem; font-size:0.9em;";
                 const strong = document.createElement('strong'); strong.textContent = " Storage Alert:";
                 warnDiv.appendChild(createIconTextNode('fa-hard-drive',''));
                 warnDiv.appendChild(strong);
                 warnDiv.appendChild(document.createTextNode(' Project data is large. Export regularly and manage list size.'));
                 EL.storedTermsInfo.appendChild(warnDiv);
                 EL.storedTermsInfo.classList.add('status-warning');
            } else {
                 EL.storedTermsInfo.classList.add('status-info');
            }
            EL.storedTermsInfo.classList.add(CONST.VISIBLE_CLASS);
        }

        // CHANGE: Timeout clearing, element creation, class toggle
        function displayStatus(elementId, message, type = CONST.STATUS.INFO, icon = null, timeoutMs = 4000) {
            const el = document.getElementById(elementId);
            if (!el) return;

             // Clear previous timeout for this element
            if(statusTimeouts[elementId]) {
                 clearTimeout(statusTimeouts[elementId]);
                 delete statusTimeouts[elementId];
            }

            const iconClass = icon || ICONS[type] || ICONS[CONST.STATUS.INFO];
            el.innerHTML = ''; // Clear safely
            el.appendChild(createIconTextNode(iconClass, message));
            el.className = `status-message status-${type} ${CONST.VISIBLE_CLASS}`; // Set class + visible

            if ((type === CONST.STATUS.INFO || type === CONST.STATUS.SUCCESS) && timeoutMs > 0 ) {
               statusTimeouts[elementId] = setTimeout(() => {
                     // Check if message content is still the same before hiding
                    const textSpan = el.querySelector('.log-text');
                    if (el.classList.contains(CONST.VISIBLE_CLASS) && textSpan && textSpan.textContent === message) {
                       hideStatus(elementId);
                    }
                     delete statusTimeouts[elementId]; // clean up
                }, timeoutMs);
            }
        }
        function hideStatus(elementId) {
            const el = document.getElementById(elementId);
            if (el) {
                 el.classList.remove(CONST.VISIBLE_CLASS);
                  if(statusTimeouts[elementId]) { // Also clear timeout if hidden manually
                    clearTimeout(statusTimeouts[elementId]);
                    delete statusTimeouts[elementId];
                 }
             }
        }

         // CHANGE: Use textContent
        function updateFileDisplay(input, displayId) {
            const display = document.getElementById(displayId);
            if (!display) return;
            const novelName = EL.novelNameInput.value.trim() || "Project";

            if (input.files && input.files.length > 0) {
                setElementContent(display, 'fa-file-import', input.files[0].name); // SAFE
                display.classList.add('has-file');
            } else {
                const text = !EL.novelNameInput.value.trim()
                     ? `Import List to Textbox...`
                     : `Import List to Textbox for '${novelName}'...`;
                 setElementContent(display, 'fa-file-import', text); // SAFE
                display.classList.remove('has-file');
            }
        }

        // CHANGE: Use element creation (XSS)
        function addProcessingLogStep(message, type = CONST.LOG_TYPE.INFO) {
            if(!EL.logUl) return;
            EL.processingLog.classList.add(CONST.VISIBLE_CLASS);
            const li = document.createElement('li');
            const iconClass = ICONS[type] || 'fa-info-circle';
            const iconColor = LOG_COLORS[type] || LOG_COLORS[CONST.LOG_TYPE.INFO];
            li.appendChild(createIconTextNode(iconClass, message, iconColor));
            EL.logUl.appendChild(li);
            EL.logUl.scrollTop = EL.logUl.scrollHeight; // Scroll to bottom
        }
        function clearProcessingLog() {
            if (EL.logUl) EL.logUl.innerHTML = '';
            EL.processingLog.classList.remove(CONST.VISIBLE_CLASS);
        }

        // --- LocalStorage Interaction ---
         // CHANGE: QoL - Header Persistence
         function saveProjectHeaderState(novelName) {
             if (!novelName) return;
             const headerData = {
                 enabled: EL.includeCustomHeaderCheckbox.checked,
                 text: EL.editablePresetTextarea.value
             };
              safeSetItem(CONST.LS_HEADER_PREFIX + novelName, JSON.stringify(headerData));
         }

        // MODIFIED FUNCTION: Makes header active by default for new projects
        function loadProjectHeaderState(novelName) {
            let headerData = null;
            if(novelName) {
               const stored = safeGetItem(CONST.LS_HEADER_PREFIX + novelName);
               if(stored) {
                   try { headerData = JSON.parse(stored); } catch(e) { console.error("Could not parse header data", e); }
                }
            }
            // Apply state or defaults
            // If headerData is null OR headerData.enabled is not defined, default to true. Otherwise, use saved value.
            EL.includeCustomHeaderCheckbox.checked = headerData?.enabled ?? true;
            EL.editablePresetTextarea.value = (headerData && headerData.text) ? headerData.text : CONST.DEFAULT_HEADER_TEXT;
            toggleCustomHeaderInputUI(EL.includeCustomHeaderCheckbox.checked);
       }


        function getPersistentDedupeLines(novelName) {
            if (!novelName) return [];
            const key = CONST.LS_DEDUPE_PREFIX + novelName;
            const data = safeGetItem(key);
            try {
                 return JSON.parse(data || '[]');
            } catch(e) {
                 displayStatus(EL.storedTermsInfo.id, `Error reading stored data for ${novelName}. Data might be corrupt.`, CONST.STATUS.DANGER);
                 return [];
            }
        }

        function savePersistentDedupeLines(novelName, linesArray) {
            if (!novelName) {
                displayStatus(EL.dedupeListStatus.id, "Project Name is required to save the list.", CONST.STATUS.DANGER);
                return false;
            }
            const key = CONST.LS_DEDUPE_PREFIX + novelName;
            const dataStr = JSON.stringify(linesArray);

            const sizeInBytes = new Blob([dataStr]).size; // More accurate than TextEncoder for LS
            const warningKey = CONST.LS_SIZE_WARNING_PREFIX + novelName;
            if (sizeInBytes > CONST.STORAGE_WARNING_THRESHOLD_BYTES) {
                safeSetItem(warningKey, 'true');
            } else {
                safeRemoveItem(warningKey);
            }
            // CHANGE: Use safeSetItem
            if(safeSetItem(key, dataStr)){
                 updateStoredTermsInfo();
                 return true;
            }
             // safeSetItem shows its own error, but we update info anyway in case warning key changed
             updateStoredTermsInfo();
            return false;
        }

        function loadPersistentDedupeToList() {
            const novelName = EL.novelNameInput.value.trim();
            if (!novelName) {
                displayStatus(EL.dedupeListStatus.id, "Please enter a valid Project Name first.", CONST.STATUS.WARNING);
                return;
            }
            const storedLines = getPersistentDedupeLines(novelName);
            EL.pastedDedupeListTextarea.value = storedLines.join('\n');
             // CHANGE: Clean after load
             cleanDedupeListTextarea(false); // Clean but don't show status
            displayStatus(EL.dedupeListStatus.id, `Loaded ${storedLines.length} lines from '${novelName}' into the textbox.`, CONST.STATUS.SUCCESS);
            updateStoredTermsInfo();
        }

        function saveDedupeListToPersistentStorage() {
            const novelName = EL.novelNameInput.value.trim();
             if (!novelName) {
                displayStatus(EL.dedupeListStatus.id, "Project Name required to save.", CONST.STATUS.DANGER);
                return false; // Return state
            }
             // CHANGE: Clean before saving
             cleanDedupeListTextarea(false); // Clean list first, no status
            const linesToSave = EL.pastedDedupeListTextarea.value.split('\n').map(line => line.trim()).filter(line => line);
            if (savePersistentDedupeLines(novelName, linesToSave)) {
                displayStatus(EL.dedupeListStatus.id, `Saved ${linesToSave.length} lines to '${novelName}' storage.`, CONST.STATUS.SUCCESS);
                 return true; // Return state
            }
             return false;
        }

        function confirmClearStorage() {
            const novelName = EL.novelNameInput.value.trim();
             if (!novelName) {
                 displayStatus(EL.storedTermsInfo.id, "Please enter a valid Project Name to clear.", CONST.STATUS.WARNING);
                return;
            }
             // CHANGE: Use safe HTML for modal message
            const lineCount = getPersistentDedupeLines(novelName).length;
            const msgHtml = `This will permanently delete all <strong>${lineCount} stored lines</strong> AND the custom header for this project. This action cannot be undone. The content in the active textbox will NOT be cleared.`;

            showGenericModal(
                `Clear Stored Data for '${novelName}'?`,
                msgHtml,
                 {
                     label: 'Delete',
                     className: 'btn-danger',
                     action: () => {
                        safeRemoveItem(CONST.LS_DEDUPE_PREFIX + novelName);
                        safeRemoveItem(CONST.LS_SIZE_WARNING_PREFIX + novelName);
                        safeRemoveItem(CONST.LS_HEADER_PREFIX + novelName); // CHANGE: Clear header too
                        displayStatus(EL.storedTermsInfo.id, `Stored data for '${novelName}' cleared.`, CONST.STATUS.SUCCESS);
                        loadProjectHeaderState(''); // Reset header to default
                        updateStoredTermsInfo();
                    }
                 }
            );
        }

        function exportPersistentDedupe() {
            const novelName = EL.novelNameInput.value.trim();
             if (!novelName) {
                displayStatus(EL.storedTermsInfo.id, "Project Name required to export.", CONST.STATUS.WARNING);
                return;
            }
            const dedupeLines = getPersistentDedupeLines(novelName);
            if (dedupeLines.length === 0) {
                displayStatus(EL.storedTermsInfo.id, `No lines stored for '${novelName}' to export.`, CONST.STATUS.INFO);
                return;
            }
            // Simple export: just the lines
            const dataStr = JSON.stringify(dedupeLines, null, 2);
            // Advanced export: include header
            /* const exportObject = {
                 projectName: novelName,
                 headerEnabled: EL.includeCustomHeaderCheckbox.checked,
                 headerText: EL.editablePresetTextarea.value,
                 dedupeLines: dedupeLines
             }
             const dataStr = JSON.stringify(exportObject, null, 2);
            */
            const dataBlob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(dataBlob);
            // Sanitize filename
            const exportFileDefaultName = `${novelName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_dedupe.json`;

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', url);
            linkElement.setAttribute('download', exportFileDefaultName);
            document.body.appendChild(linkElement);
            linkElement.click();
            document.body.removeChild(linkElement);
            URL.revokeObjectURL(url); // Clean up
            displayStatus(EL.storedTermsInfo.id, `Exported ${dedupeLines.length} lines for '${novelName}'.`, CONST.STATUS.SUCCESS);
        }

        function handleImportDedupeFile(fileInput) {
            const importDisplayId = EL.fileDisplayText_importDedupe.id;
            if (!fileInput.files || fileInput.files.length === 0) {
                updateFileDisplay(fileInput, importDisplayId); return;
            }
            const file = fileInput.files[0];
            updateFileDisplay(fileInput, importDisplayId); // Show filename immediately

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    let importedLines = [];
                    // Basic check if it might be the "advanced" export format
                    let parsedData;
                     try { parsedData = JSON.parse(event.target.result); } catch(e) { parsedData = null; }

                    if (file.name.toLowerCase().endsWith('.json') && parsedData) {
                         // Handle advanced export format: if(Array.isArray(parsedData.dedupeLines)) { ... }
                         if (!Array.isArray(parsedData) || !parsedData.every(item => typeof item === 'string')) {
                             // Allow simple text file saved as .json
                              importedLines = event.target.result.split(/[\r\n]+/).map(l => l.trim()).filter(l => l);
                              console.warn("JSON file not array of strings, treating as text.");
                         } else {
                            importedLines = parsedData;
                         }
                    } else { // Assume .txt or .csv is line-by-line
                        importedLines = event.target.result.split(/[\r\n]+/).map(l => l.trim()).filter(l => l); // handle \r\n and \n
                    }

                     if(importedLines.length === 0) throw new Error("File is empty or format not recognised.");

                    const currentText = EL.pastedDedupeListTextarea.value.trim();
                    const currentLines = currentText ? currentText.split('\n') : [];

                    showImportOptionsModalToTextarea(importedLines, currentLines, (action) => {
                        if (action === CONST.MODAL.REPLACE) {
                            EL.pastedDedupeListTextarea.value = importedLines.join('\n');
                             cleanDedupeListTextarea(false); // Clean
                            displayStatus(EL.dedupeListStatus.id, `Replaced list with ${importedLines.length} imported lines. Cleaned. Remember to SAVE.`, CONST.STATUS.INFO, null, 6000);
                        } else if (action === CONST.MODAL.MERGE) {
                             // CHANGE: Append then Clean for true merge
                            const newText = (currentText ? currentText + '\n' : '') + importedLines.join('\n');
                            EL.pastedDedupeListTextarea.value = newText;
                             const finalCount = cleanDedupeListTextarea(false); // Clean list, get count
                             displayStatus(EL.dedupeListStatus.id, `Merged ${importedLines.length} lines. List cleaned (Total: ${finalCount}). Remember to SAVE.`, CONST.STATUS.INFO, null, 6000);
                        }
                        fileInput.value = ''; // Reset input
                        updateFileDisplay(fileInput, importDisplayId);
                    });

                } catch (e) {
                    displayStatus(EL.dedupeListStatus.id, `Error processing import file: ${e.message}`, CONST.STATUS.DANGER);
                    fileInput.value = ''; updateFileDisplay(fileInput, importDisplayId);
                }
            };
            reader.onerror = function() {
                displayStatus(EL.dedupeListStatus.id, 'Error reading import file.', CONST.STATUS.DANGER);
                fileInput.value = ''; updateFileDisplay(fileInput, importDisplayId);
            };
            reader.readAsText(file);
        }

        function clearDedupeListTextarea() {
            EL.pastedDedupeListTextarea.value = '';
            hideStatus(EL.dedupeListStatus.id);
        }

        // MODIFIED FUNCTION: Intelligent deduplication based on raw, translation, and gender
        function cleanDedupeListTextarea(showStatus = true) {
            const currentText = EL.pastedDedupeListTextarea.value;
            if(!currentText.trim()) return 0;

            const lines = currentText.split(/[\r\n]+/).map(l => l.trim()).filter(l => l);
            const uniqueLines = new Map(); // Use a Map to store unique lines based on a key

            lines.forEach(line => {
                const parts = line.split(',').map(p => p.trim());
                // Gracefully handle lines with fewer than 3 parts
                const raw = parts[0] || '';
                const translation = parts[1] || '';
                const gender = parts[2] || ''; // Use empty string if no gender, it's still part of the key

                // Create a composite key from the first 3 parts to identify duplicates
                const key = `${raw.toLowerCase()},${translation.toLowerCase()},${gender.toLowerCase()}`;

                if (!uniqueLines.has(key)) {
                    uniqueLines.set(key, line); // Store the original line if the key is new
                }
            });

            const uniqueSortedLines = Array.from(uniqueLines.values()).sort((a, b) => a.localeCompare(b));
            EL.pastedDedupeListTextarea.value = uniqueSortedLines.join('\n');

            if(showStatus) {
                const removedCount = lines.length - uniqueSortedLines.length;
                const message = removedCount > 0
                    ? `List cleaned: ${removedCount} duplicates removed, sorted. (Total: ${uniqueSortedLines.length})`
                    : `List cleaned and sorted. No duplicates found. (Total: ${uniqueSortedLines.length})`;
                displayStatus(EL.dedupeListStatus.id, message, CONST.STATUS.SUCCESS, null, 5000);
            }

            return uniqueSortedLines.length; // return final count
        }


        // --- Main Extraction Logic ---
        async function processAllData() {
            EL.mainExtractBtn.classList.add('loading');
            EL.mainExtractBtn.disabled = true;
            clearProcessingLog();
            hideStatus(EL.jsonStatus.id); hideStatus(EL.outputSummary.id);
             addProcessingLogStep('Extraction process initiated...', CONST.LOG_TYPE.START);

            lastExtractedPureTerms = [];
            const chapterTextareas = EL.chapterInputsContainer.querySelectorAll('textarea');
            if (chapterTextareas.length === 0 || Array.from(chapterTextareas).every(ta => !ta.value.trim())) {
                displayStatus(EL.jsonStatus.id, "No chapter JSON provided.", CONST.STATUS.WARNING);
                addProcessingLogStep('No chapter JSON data. Aborted.', CONST.LOG_TYPE.DANGER);
                finalizeExtractionUI(EL.mainExtractBtn); return;
            }

            // Build deduplication set for THIS RUN
             // CHANGE: Ensure list is clean before processing
             cleanDedupeListTextarea(false);
            const currentDedupeListContent = EL.pastedDedupeListTextarea.value;
            const dedupeLinesForRun = currentDedupeListContent.split('\n').map(line => line.trim()).filter(line => line);
            const translationsToDeduplicateThisRun = new Set();
            dedupeLinesForRun.forEach(line => {
                const parts = line.split(',').map(part => part.trim());
                // Use translation part (parts[1]) if available, otherwise the whole line if it's a single term
                const translationKey = (parts.length >= 2 && parts[1]) ? parts[1].toLowerCase() : ((parts.length === 1 && parts[0]) ? parts[0].toLowerCase() : null);
                if (translationKey) {
                    translationsToDeduplicateThisRun.add(translationKey);
                }
            });
            addProcessingLogStep(`Active list has ${translationsToDeduplicateThisRun.size} unique translations for deduplication.`, CONST.LOG_TYPE.INFO);

            let allChunks = [];
            let chaptersParsedCount = 0;
             // CHANGE: Use querySelectorAll and index for label
             const chapterGroups = EL.chapterInputsContainer.querySelectorAll('.chapter-input-group');
            for (let i = 0; i < chapterGroups.length; i++) {
                const chapterGroup = chapterGroups[i];
                const textarea = chapterGroup.querySelector('textarea');
                 const boxNumber = i + 1; // Use index for logging
                 if(!textarea) continue;
                 const chapterJsonStr = textarea.value;

                if (!chapterJsonStr.trim()) { addProcessingLogStep(`Chapter Box ${boxNumber} empty. Skipping.`, CONST.LOG_TYPE.INFO); continue; }
                addProcessingLogStep(`Parsing Chapter from Box ${boxNumber}...`, CONST.LOG_TYPE.INFO);
                await new Promise(r => setTimeout(r, 15)); // UI breathing room
                try {
                    const parsedChapter = JSON.parse(chapterJsonStr);
                    if (!Array.isArray(parsedChapter) || (parsedChapter.length > 0 && (typeof parsedChapter[0] !== 'object' || !parsedChapter[0] || !('terms' in parsedChapter[0]) || !Array.isArray(parsedChapter[0].terms)))) {
                         addProcessingLogStep(`Box ${boxNumber}: Invalid JSON structure. Expected array of objects with 'terms' array. Skipped.`, CONST.LOG_TYPE.WARNING); continue;
                    }
                    allChunks.push(...parsedChapter);
                    chaptersParsedCount++;
                    addProcessingLogStep(`Box ${boxNumber}: Parsed ${parsedChapter.length} chunks.`, CONST.LOG_TYPE.SUCCESS);
                } catch (e) {
                     // CHANGE: Log message safely
                    addProcessingLogStep(`Box ${boxNumber}: Invalid JSON. Error: "${e.message}". Skipped.`, CONST.LOG_TYPE.DANGER);
                }
            }

            if (chaptersParsedCount === 0 && allChunks.length === 0) { // Check chunks too
                displayStatus(EL.jsonStatus.id, 'No chapters successfully parsed. Check JSON and Log.', CONST.STATUS.DANGER);
                addProcessingLogStep('Failed to parse any chapter data. Aborted.', CONST.LOG_TYPE.DANGER);
                finalizeExtractionUI(EL.mainExtractBtn); return;
            }
            addProcessingLogStep(`${chaptersParsedCount} chapters parsed. Extracting terms...`, CONST.LOG_TYPE.INFO);
             await new Promise(r => setTimeout(r, 15)); // UI breathing room

            const seenThisRunTranslations = new Set(); // To avoid duplicates within the same extraction run output
            allChunks.forEach(chunk => {
                if (chunk && Array.isArray(chunk.terms)) {
                    chunk.terms.forEach(term => {
                        // Ensure raw/translation exist and are not just whitespace
                        const raw = term.raw ? String(term.raw).trim() : null;
                        const translation = term.translation ? String(term.translation).trim() : null;
                        if (raw && translation) {
                            const translationKey = translation.toLowerCase();
                            if (!translationsToDeduplicateThisRun.has(translationKey) && !seenThisRunTranslations.has(translationKey)) {
                                seenThisRunTranslations.add(translationKey);
                                let gender = "Neuter";
                                if (term.tags && Array.isArray(term.tags)) {
                                    if (term.tags.includes("#male")) gender = "Male";
                                    else if (term.tags.includes("#female")) gender = "Female";
                                }
                                // Ensure no commas within raw/translation break the format
                                 const safeRaw = raw.replace(/,/g, ';');
                                 const safeTranslation = translation.replace(/,/g, ';');
                                lastExtractedPureTerms.push(`${safeRaw},${safeTranslation},${gender}`);
                            }
                        }
                    });
                }
            });
             // CHANGE: Sort extracted terms
             lastExtractedPureTerms.sort((a,b) => a.localeCompare(b));

            addProcessingLogStep(`Found ${lastExtractedPureTerms.length} new unique terms.`, CONST.LOG_TYPE.END);

            let finalOutputText = "";
            const includeHeader = EL.includeCustomHeaderCheckbox.checked;
            const headerText = EL.editablePresetTextarea.value.trim();
            if (includeHeader && headerText) {
                finalOutputText += headerText + "\n\n";
            }
            finalOutputText += lastExtractedPureTerms.join('\n');
            EL.outputTextarea.value = finalOutputText;

            if (lastExtractedPureTerms.length > 0) {
                 displayStatus(EL.outputSummary.id, `Complete: ${lastExtractedPureTerms.length} new unique terms found.`, CONST.STATUS.SUCCESS, null, 8000);
            } else {
                 displayStatus(EL.outputSummary.id, 'Complete. No new unique terms found.', CONST.STATUS.INFO, null, 8000);
            }
            finalizeExtractionUI(EL.mainExtractBtn);
        }

        function finalizeExtractionUI(button) {
            button.classList.remove('loading');
            button.disabled = false;
        }

        // --- Output Handling ---
         // CHANGE: Added save option
        function moveExtractedToDedupeList(saveAfterMove = false) {
             const tooltipId = saveAfterMove ? EL.moveSaveTooltip.id : EL.moveExtractedTooltip.id;
            if (lastExtractedPureTerms.length === 0) {
                showTooltipMessage(tooltipId, "No new terms to move!");
                return;
            }
            const currentDedupeText = EL.pastedDedupeListTextarea.value.trim();
            const newTermsText = lastExtractedPureTerms.join('\n');
            EL.pastedDedupeListTextarea.value = (currentDedupeText ? currentDedupeText + '\n' : '') + newTermsText;

             // CHANGE: Clean after moving
             const finalCount = cleanDedupeListTextarea(false); // Clean the list!

            let statusMsg = `Moved ${lastExtractedPureTerms.length} terms. List cleaned (Total: ${finalCount}). `;
            let tooltipMsg = "Moved & Cleaned!";
             let statusType = CONST.STATUS.INFO;

             if(saveAfterMove) {
                 if(saveDedupeListToPersistentStorage()) { // Call save function
                     statusMsg += " List SAVED to storage.";
                     tooltipMsg = "Moved, Cleaned & Saved!";
                     statusType = CONST.STATUS.SUCCESS;
                 } else {
                     statusMsg += " SAVE FAILED (check project name/storage).";
                     tooltipMsg = "Move OK, Save Failed!";
                      statusType = CONST.STATUS.WARNING;
                 }
             } else {
                 statusMsg += " Remember to SAVE to storage.";
             }

            displayStatus(EL.dedupeListStatus.id, statusMsg, statusType, null, 7000);
            showTooltipMessage(tooltipId, tooltipMsg);

            lastExtractedPureTerms = []; // Clear after moving
             // Clear output text area, but keep header if checked
            EL.outputTextarea.value = EL.includeCustomHeaderCheckbox.checked ? EL.editablePresetTextarea.value.trim() + "\n\n" : "";
            hideStatus(EL.outputSummary.id);
        }

        function copyOutput() {
            performCopy(EL.outputTextarea.value, EL.copyHeaderTooltip.id);
        }

        function copyToClipboard(element, tooltipId) {
            performCopy(element.value, tooltipId);
        }

        function performCopy(text, tooltipId) {
             if (!text || !text.trim()) {
                showTooltipMessage(tooltipId, "Nothing to copy!"); return;
            }
            navigator.clipboard.writeText(text).then(() => {
                showTooltipMessage(tooltipId, "Copied!");
            }).catch(err => {
                console.error('Clipboard copy failed:', err);
                showTooltipMessage(tooltipId, "Copy Failed!");
            });
        }

         // CHANGE: Timeout clearing
        function showTooltipMessage(tooltipId, message) {
            const tooltip = document.getElementById(tooltipId);
            if (!tooltip) return;
             // Clear previous timeout
             if(tooltipTimeouts[tooltipId]) {
                clearTimeout(tooltipTimeouts[tooltipId]);
                 // Restore original text immediately if interrupted
                 tooltip.textContent = tooltip.dataset.originalText || tooltip.textContent;
                delete tooltipTimeouts[tooltipId];
             }

            const originalText = tooltip.dataset.originalText || tooltip.textContent;
            if (!tooltip.dataset.originalText) tooltip.dataset.originalText = originalText;

            tooltip.textContent = message;
             tooltip.classList.add('force-visible'); // Use class

           tooltipTimeouts[tooltipId] = setTimeout(() => {
                tooltip.textContent = tooltip.dataset.originalText;
                tooltip.classList.remove('force-visible');
                delete tooltipTimeouts[tooltipId]; // clean up
            }, 1800);
        }

        // --- Modal Logic ---
         // CHANGE: More flexible buttons, use textContent
        function showGenericModal(title, messageHTML, confirmButtonOpts = null, cancelButtonOpts = null) {
            EL.modalTitleEl.textContent = title; // SAFE
            EL.modalMessageEl.innerHTML = messageHTML; // CAUTION: Relies on caller providing safe HTML
            EL.modalActionsContainer.innerHTML = ''; // Clear

            const cancelBtn = document.createElement('button');
            cancelBtn.className = `btn ${cancelButtonOpts?.className || 'btn-outline'}`;
            cancelBtn.textContent = cancelButtonOpts?.label || 'Cancel';
            cancelBtn.onclick = () => {
                 if(cancelButtonOpts && typeof cancelButtonOpts.action === 'function') cancelButtonOpts.action();
                 hideGenericModal();
            };
             EL.modalActionsContainer.appendChild(cancelBtn);

            if(confirmButtonOpts) {
                 const confirmBtn = document.createElement('button');
                 confirmBtn.className = `btn ${confirmButtonOpts.className || 'btn-primary'}`;
                 confirmBtn.textContent = confirmButtonOpts.label || 'Confirm';
                 confirmBtn.onclick = () => {
                     if(typeof confirmButtonOpts.action === 'function') confirmButtonOpts.action();
                     hideGenericModal();
                  };
                 EL.modalActionsContainer.appendChild(confirmBtn);
            }
             EL.modalOverlay.classList.add('active');
             cancelBtn.focus(); // A11y
        }

        function hideGenericModal() { EL.modalOverlay.classList.remove('active'); }

         // CHANGE: Use generic modal structure, Merge logic
        function showImportOptionsModalToTextarea(importedLines, currentLines, callbackOnAction) {
            const importCount = importedLines.length;
            const currentLineCount = currentLines.length;

            // CHANGE: Calculate merge count accurately
            const mergedSet = new Set([...currentLines, ...importedLines]);
            const mergedCount = mergedSet.size;

            const msgHTML = `
                You are importing <strong>${importCount} lines</strong>.<br>
                The textbox currently has <strong>${currentLineCount} lines</strong>.
                <br><br>Choose an action for the textbox content:<br>
                 - <b>Merge:</b> Add new lines, remove all duplicates, sort (Total: ${mergedCount} lines).<br>
                 - <b>Replace:</b> Discard current lines (Total: ${importCount} lines).
            `;
             EL.modalTitleEl.textContent = `Import Options`;
             EL.modalMessageEl.innerHTML = msgHTML;
             EL.modalActionsContainer.innerHTML = ''; // Clear

             const createBtn = (label, icon, className, actionType) => {
                 const btn = document.createElement('button');
                 btn.className = `btn ${className}`;
                 setElementContent(btn, icon, label);
                  btn.onclick = () => {
                    if(callbackOnAction) callbackOnAction(actionType);
                    hideGenericModal();
                 };
                 return btn;
             }
             EL.modalActionsContainer.appendChild(createBtn('Cancel', 'fa-times', 'btn-outline', CONST.MODAL.CANCEL));
             EL.modalActionsContainer.appendChild(createBtn(`Merge & Clean (${mergedCount})`, 'fa-object-group', 'btn-primary', CONST.MODAL.MERGE));
             EL.modalActionsContainer.appendChild(createBtn(`Replace (${importCount})`, 'fa-exchange-alt', 'btn-warning', CONST.MODAL.REPLACE));

             EL.modalOverlay.classList.add('active');
        }

    })(); // IIFE End
    </script>
</body>
</html>
