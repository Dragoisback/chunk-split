<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenith Term Processor v5.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        :root {
            --bg-main: #eef2f5;
            --bg-panel: #ffffff;
            --primary-500: #3b82f6; /* Blue 500 */
            --primary-600: #2563eb; /* Blue 600 */
            --secondary-500: #8b5cf6; /* Violet 500 */
            --secondary-600: #7c3aed; /* Violet 600 */
            --success-500: #10b981; /* Emerald 500 */
            --danger-500: #ef4444;  /* Red 500 */
            --warning-500: #f59e0b; /* Amber 500 */
            --neutral-700: #374151; /* Gray 700 for text */
            --neutral-500: #6b7280; /* Gray 500 for secondary text */
            --neutral-300: #d1d5db; /* Gray 300 for borders */
            --neutral-100: #f3f4f6; /* Gray 100 for light backgrounds */
            --font-sans: 'Inter', sans-serif;
            --radius-md: 0.375rem; /* 6px */
            --radius-lg: 0.5rem;   /* 8px */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --transition-base: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: var(--neutral-300); }
        html { font-family: var(--font-sans); font-size: 16px; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;}
        body { margin: 0; background-color: var(--bg-main); color: var(--neutral-700); padding: 1.5rem; }

        .app-container { max-width: 1400px; margin-left: auto; margin-right: auto; }

        .app-title-bar {
            margin-bottom: 2rem; text-align: center; padding: 1.5rem;
            background: linear-gradient(145deg, var(--primary-500), var(--secondary-500));
            color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-md);
        }
        .app-title-bar h1 { font-size: 1.875rem; font-weight: 700; letter-spacing: -0.025em;}
        .app-title-bar p { font-size: 0.875rem; opacity: 0.9; margin-top: 0.25rem; }

        .grid-layout { display: grid; gap: 1.5rem; }
        @media (min-width: 1024px) {
            .grid-layout { grid-template-columns: repeat(3, 1fr); }
            .grid-layout .col-span-1 { grid-column: span 1 / span 1; }
            .grid-layout .col-span-2 { grid-column: span 2 / span 2; }
            .grid-layout .col-span-3 { grid-column: span 3 / span 3; }
        }
         @media (min-width: 768px) and (max-width: 1023px) {
            .grid-layout { grid-template-columns: repeat(2, 1fr); }
            .grid-layout .col-span-1-md { grid-column: span 1 / span 1; }
            .grid-layout .col-span-2-md { grid-column: span 2 / span 2; }
        }


        .panel { background-color: var(--bg-panel); border-radius: var(--radius-lg); box-shadow: var(--shadow-md); padding: 1.5rem; }
        .panel-title { display: flex; align-items: center; font-size: 1.125rem; font-weight: 600; margin-bottom: 1.25rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--neutral-100); }
        .panel-title i { margin-right: 0.625rem; color: var(--primary-500); font-size:1.2em; }
        
        .form-group { margin-bottom: 1.25rem; }
        .form-label { display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.375rem; color: var(--neutral-500); }
        
        input[type="text"], textarea, .file-input-wrapper {
            width: 100%; padding: 0.625rem 0.875rem; border-radius: var(--radius-md);
            font-size: 0.875rem; background-color: white; border: 1px solid var(--neutral-300);
            transition: var(--transition-base); color: var(--neutral-700);
        }
        input[type="text"]:focus, textarea:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            border-color: var(--primary-500); box-shadow: 0 0 0 2px var(--primary-500_alpha, rgba(59,130,246,0.3));
        }
        textarea { resize: vertical; min-height: 80px; }

        .file-input-wrapper { position: relative; display: block; }
        .file-input-wrapper input[type="file"] { position: absolute; inset: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .file-input-wrapper .file-display-text { color: var(--neutral-500); }
        .file-input-wrapper .file-display-text.has-file { color: var(--neutral-700); font-weight: 500; }
        .file-input-wrapper i { color: var(--secondary-500); margin-right: 0.5rem; }
        
        .btn-group { display: flex; flex-wrap: wrap; gap: 0.625rem; margin-top: 0.75rem; }
        .btn {
            padding: 0.5rem 1rem; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500;
            transition: var(--transition-base); display: inline-flex; align-items: center; justify-content: center;
            gap: 0.375rem; cursor: pointer; line-height: 1.25rem; text-decoration: none;
            box-shadow: var(--shadow-sm); border: 1px solid transparent;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
        .btn:focus { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px var(--primary-500_alpha, rgba(59,130,246,0.4)); }
        .btn i { font-size:0.9em; }

        .btn-primary { background-color: var(--primary-500); color: white; }
        .btn-primary:hover { background-color: var(--primary-600); }
        .btn-secondary { background-color: var(--secondary-500); color: white; }
        .btn-secondary:hover { background-color: var(--secondary-600); }
        .btn-danger { background-color: var(--danger-500); color: white; }
        .btn-danger:hover { background-color: #d03030; } /* Slightly darker red */
        .btn-outline { background-color: transparent; border-color: var(--neutral-300); color: var(--neutral-500); }
        .btn-outline:hover { background-color: var(--neutral-100); border-color: var(--neutral-500); color:var(--neutral-700); }

        .btn-icon { padding: 0.5rem; }
        .btn-main-action { padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 600; }
        .btn-main-action .spinner { display: none; width: 1.125rem; height: 1.125rem; border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; border-top-color: white; animation: spin 0.7s linear infinite; margin-right: 0.5rem;}
        .btn-main-action.loading .spinner { display: inline-block; }

        @keyframes spin { to { transform: rotate(360deg); } }

        .chapter-input-group { margin-bottom: 1rem; padding: 1rem; border: 1px dashed var(--neutral-300); border-radius: var(--radius-md); background-color: var(--neutral-100_alpha, rgba(243,244,246,0.5));}
        .chapter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .chapter-label { font-weight: 500; font-size:0.9rem; color: var(--secondary-500);}

        .status-message {
            margin-top: 0.75rem; padding: 0.75rem 1rem; border-radius: var(--radius-md); font-size: 0.875rem;
            display: flex; align-items: center; gap: 0.5rem; border: 1px solid;
        }
        .status-message i { font-size: 1.1em; }
        .status-success { background-color: #d1fae5; color: #065f46; border-color: #6ee7b7; }
        .status-warning { background-color: #fef3c7; color: #92400e; border-color: #fcd34d; }
        .status-danger  { background-color: #fee2e2; color: #991b1b; border-color: #fca5a5; }
        .status-info    { background-color: #dbeafe; color: #1e40af; border-color: #93c5fd; }

        #processingLog ul { list-style: none; padding: 0; max-height: 120px; overflow-y: auto; font-size: 0.8rem; color:var(--neutral-500);}
        #processingLog li { padding: 0.25rem 0; border-bottom: 1px dotted var(--neutral-100);}
        #processingLog li:last-child { border-bottom: none;}

        .output-actions { display: flex; justify-content: flex-end; gap: 0.75rem; margin-bottom: 0.75rem; }

        /* Modal Styles */
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.6); display: none; align-items: center; justify-content: center; z-index: 50; backdrop-filter: blur(4px); }
        .modal-overlay.active { display: flex; }
        .modal-content { background-color: var(--bg-panel); padding: 1.5rem; border-radius: var(--radius-lg); box-shadow: var(--shadow-md); width: 90%; max-width: 450px; text-align: center; }
        .modal-title { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--neutral-700);}
        .modal-body { font-size: 0.875rem; color: var(--neutral-500); margin-bottom: 1.5rem; }
        .modal-actions { display: flex; justify-content: center; gap: 0.75rem; }

        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltip-text {
            visibility: hidden; background-color: var(--neutral-700); color: white; text-align: center;
            border-radius: var(--radius-md); padding: 0.375rem 0.75rem; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.2s;
            font-size: 0.75rem; white-space: nowrap; box-shadow: var(--shadow-sm);
        }
        .tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }

    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-title-bar">
            <h1><i class="fas fa-meteor"></i> Zenith Term Processor v5.0</h1>
            <p>Intelligent Term Extraction with Persistent Project Deduplication</p>
        </header>

        <div class="grid-layout">
            <!-- Project Setup Panel -->
            <div class="panel col-span-1 col-span-1-md">
                <h2 class="panel-title"><i class="fas fa-folder-tree"></i>Project Setup & Storage</h2>
                <div class="form-group">
                    <label for="novelNameInput" class="form-label">Novel/Project Name:</label>
                    <input type="text" id="novelNameInput" placeholder="E.g., My Awesome Novel" onkeyup="updateDynamicButtonLabels()">
                    <small class="form-label" style="margin-top:4px;font-size:0.75rem;">This name is used for storing deduplication data.</small>
                </div>
                <div id="storedTermsInfo" class="status-message status-info" style="display:none; font-size:0.8rem;"></div>
                <div class="btn-group" style="flex-direction: column; gap: 0.5rem;">
                    <button id="loadStoredBtn" onclick="loadPersistentDedupe()" class="btn btn-outline" style="width:100%;">
                        <i class="fas fa-cloud-download-alt"></i>Load Stored for Project
                    </button>
                    <button id="clearStoredBtn" onclick="confirmClearStorage()" class="btn btn-outline btn-danger" style="width:100%;">
                        <i class="fas fa-trash-alt"></i>Clear Storage for Project
                    </button>
                </div>
            </div>

            <!-- Chapter Input Panel -->
            <div class="panel col-span-2 col-span-1-md">
                <h2 class="panel-title"><i class="fas fa-book-reader"></i>Chapter JSON Input</h2>
                <div id="chapterInputsContainer" style="max-height: 350px; overflow-y: auto; padding-right: 5px;">
                    <!-- Chapter input boxes dynamically added here -->
                </div>
                <div class="btn-group" style="margin-top:1rem;">
                    <button onclick="addChapterInput()" class="btn btn-primary">
                        <i class="fas fa-plus"></i>Add Chapter Box
                    </button>
                </div>
                <div id="jsonStatus" class="status-message" style="display:none; margin-top: 1rem;"></div>
            </div>

            <!-- Current Session Dedupe & Header Panel -->
            <div class="panel col-span-3 col-span-2-md">
                <h2 class="panel-title"><i class="fas fa-filter"></i>Session Configuration</h2>
                <div class="grid-layout" style="gap: 1rem;"> <!-- Nested grid for side-by-side -->
                    <div class="col-span-1">
                        <div class="form-group">
                            <label class="form-label">Current Session Deduplication List:</label>
                             <div class="file-input-wrapper">
                                <input type="file" id="csvFile" accept=".csv" onchange="updateFileDisplay(this, 'fileDisplayText_csv')">
                                <div class="file-display-text" id="fileDisplayText_csv"><i class="fas fa-file-csv"></i>Upload .csv file...</div>
                            </div>
                            <textarea id="pastedCsv" rows="3" placeholder="Or paste: raw,translation[,gender]"></textarea>
                            <div class="btn-group">
                                <button onclick="loadSessionDedupeList()" class="btn btn-secondary">
                                    <i class="fas fa-list-ul"></i>Load to Session
                                </button>
                                <div class="tooltip">
                                    <button onclick="copyToClipboard('pastedCsv', 'dedupeTooltip')" class="btn btn-outline btn-icon">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                    <span class="tooltip-text" id="dedupeTooltip">Copy List</span>
                                </div>
                                 <button onclick="clearSessionDedupeVisuals()" class="btn btn-outline btn-danger"><i class="fas fa-times"></i>Clear Inputs</button>
                            </div>
                            <div id="sessionDedupeStatus" class="status-message" style="display:none; margin-top: 0.5rem;"></div>
                        </div>
                    </div>
                    <div class="col-span-1">
                        <div class="form-group">
                            <div style="display:flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <input type="checkbox" id="includeCustomHeaderCheckbox" onchange="toggleCustomHeaderInputUI(this.checked)" style="width:auto; height:auto; accent-color: var(--primary-500);">
                                <label for="includeCustomHeaderCheckbox" class="form-label" style="margin-bottom:0;">Include Custom Output Header</label>
                            </div>
                            <div id="customHeaderInputArea" style="display:none;">
                                <textarea id="editablePresetTextarea" rows="5" placeholder="Enter custom header text..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Extraction Actions & Results Panel -->
            <div class="panel col-span-3">
                <h2 class="panel-title"><i class="fas fa-magic-wand-sparkles"></i>Extraction Actions & Results</h2>
                <div style="text-align:center; margin-bottom: 1.5rem;">
                    <button id="mainExtractBtn" onclick="processAllData()" class="btn btn-primary btn-main-action">
                        <span class="spinner"></span>
                        <i class="fas fa-cogs"></i>Extract Terms
                    </button>
                </div>
                <div id="processingLog" class="status-message status-info" style="display:none; margin-bottom:1rem;">
                    <strong>Processing Log:</strong>
                    <ul style="width:100%;"></ul>
                </div>

                <hr style="margin: 1.5rem 0; border-color: var(--neutral-100);">
                
                <div class="output-actions">
                    <div class="tooltip">
                        <button onclick="copyOutput('termsOnly')" class="btn btn-outline">
                            <i class="fas fa-clipboard-list"></i>Copy Terms Only
                        </button>
                        <span class="tooltip-text" id="copyTermsTooltip">Copy terms</span>
                    </div>
                    <div class="tooltip">
                         <button onclick="copyOutput('withHeader')" class="btn btn-outline">
                            <i class="fas fa-file-alt"></i>Copy with Header
                        </button>
                        <span class="tooltip-text" id="copyHeaderTooltip">Copy with header</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="outputTextarea" class="form-label">Extracted Terms:</label>
                    <textarea id="outputTextarea" rows="10" readonly placeholder="Extracted terms will appear here..."></textarea>
                </div>
                <div id="outputSummary" class="status-message" style="display:none;"></div>
                <div id="saveToStorageBtnContainer" style="margin-top: 1rem; text-align: right;">
                    <!-- "Save to [Novel Name] Storage" button will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="confirmationModal">
        <div class="modal-content">
            <h3 class="modal-title" id="modalTitle">Confirm Action</h3>
            <p class="modal-body" id="modalMessageText">Are you sure you want to proceed?</p>
            <div class="modal-actions">
                <button class="btn btn-outline" id="modalCancelBtn">Cancel</button>
                <button class="btn btn-danger" id="modalConfirmBtn">Confirm</button>
            </div>
        </div>
    </div>

    <footer style="text-align:center; padding: 2rem; color: var(--neutral-500); font-size: 0.875rem; margin-top:1.5rem;">
        <p>© 2024 Zenith Term Processor. Elevating Your Lexical Workflow.</p>
    </footer>

    <script>
        // --- Global State & Constants ---
        let currentSessionDedupeTranslations = new Set(); // For terms from file/paste in this session
        let persistentDedupeTranslations = new Set(); // For terms loaded from localStorage
        let chapterInputCounter = 0;
        let lastExtractedPureTerms = []; // Only "raw, translation, gender"
        const LS_NOVEL_NAME_KEY = 'zenithTermExtractor_lastNovelName';
        const LS_DEDUPE_PREFIX = 'zenithTermExtractor_dedupe_';

        const DEFAULT_HEADER_TEXT = `"Before replying YOU must think. From now onwards, in your thinking process/thought process/strategizing instead of YOU doing regular thinking, it is imperative that YOU MUST open and activate "Super-Duper-Hyper Thinking Mode". In this mode, you are obligated to: 1) engage in extreme exceptionally extreme thinking 2) engage in extreme exceptionally extreme extensivity 3) extreme exceptionally extreme extensity analysis."\n Go through the whole chat and check what have you translated these in your translation. add pinyin, where and its description and gender about it too. Mention if the  term is not present or cut in half. compare to my translation and let me know the difference reason.`;

        // --- DOM Elements (Cache if used frequently) ---
        const novelNameInput = document.getElementById('novelNameInput');
        const editablePresetTextarea = document.getElementById('editablePresetTextarea');
        const outputTextarea = document.getElementById('outputTextarea');

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            addChapterInputUI(); // Add initial chapter box
            editablePresetTextarea.value = DEFAULT_HEADER_TEXT;
            const lastNovel = localStorage.getItem(LS_NOVEL_NAME_KEY);
            if (lastNovel) {
                novelNameInput.value = lastNovel;
            }
            updateDynamicButtonLabels();
            updateStoredTermsInfo();
        });

        // --- UI Update Functions ---
        function addChapterInputUI() {
            chapterInputCounter++;
            const container = document.getElementById('chapterInputsContainer');
            const itemDiv = document.createElement('div');
            itemDiv.className = 'chapter-input-group';
            itemDiv.id = `chapterGroup_${chapterInputCounter}`;

            const headerDiv = document.createElement('div');
            headerDiv.className = 'chapter-header';
            const label = document.createElement('span');
            label.className = 'chapter-label';
            label.textContent = `Chapter ${chapterInputCounter} JSON`;
            headerDiv.appendChild(label);

            if (chapterInputCounter > 1) {
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<i class="fas fa-minus-circle"></i>';
                removeBtn.className = 'btn btn-icon btn-outline btn-danger';
                removeBtn.onclick = () => itemDiv.remove();
                headerDiv.appendChild(removeBtn);
            }
            itemDiv.appendChild(headerDiv);

            const textarea = document.createElement('textarea');
            textarea.rows = 4;
            textarea.placeholder = `Paste JSON for Chapter ${chapterInputCounter}...`;
            textarea.id = `chapterJson_${chapterInputCounter}`;
            itemDiv.appendChild(textarea);
            container.appendChild(itemDiv);
        }

        function toggleCustomHeaderInputUI(isChecked) {
            document.getElementById('customHeaderInputArea').style.display = isChecked ? 'block' : 'none';
        }

        function updateDynamicButtonLabels() {
            const novelName = novelNameInput.value.trim() || "Project";
            document.getElementById('loadStoredBtn').innerHTML = `<i class="fas fa-cloud-download-alt"></i>Load Stored for '${novelName}'`;
            document.getElementById('clearStoredBtn').innerHTML = `<i class="fas fa-trash-alt"></i>Clear Storage for '${novelName}'`;
            if (novelName !== "Project") {
                localStorage.setItem(LS_NOVEL_NAME_KEY, novelName);
            }
            updateStoredTermsInfo();
        }
        
        function updateStoredTermsInfo() {
            const novelName = novelNameInput.value.trim();
            const storedInfoDiv = document.getElementById('storedTermsInfo');
            if (!novelName) {
                storedInfoDiv.style.display = 'none';
                return;
            }
            const key = LS_DEDUPE_PREFIX + novelName;
            const storedData = JSON.parse(localStorage.getItem(key) || '[]');
            storedInfoDiv.innerHTML = `<i class="fas fa-database"></i> ${storedData.length} terms stored for '${novelName}'.`;
            storedInfoDiv.style.display = storedData.length > 0 ? 'flex' : 'none';
        }


        function displayStatus(elementId, message, type = 'info', icon = null) {
            const el = document.getElementById(elementId);
            let iconHtml = '';
            if (icon) iconHtml = `<i class="fas ${icon}"></i>`;
            else { // Default icons based on type
                if(type === 'success') iconHtml = '<i class="fas fa-check-circle"></i>';
                else if(type === 'warning') iconHtml = '<i class="fas fa-exclamation-triangle"></i>';
                else if(type === 'danger') iconHtml = '<i class="fas fa-times-circle"></i>';
                else iconHtml = '<i class="fas fa-info-circle"></i>';
            }
            el.innerHTML = `${iconHtml} ${message}`;
            el.className = `status-message status-${type}`; // Reset class list and add new
            el.style.display = 'flex';
        }
        function hideStatus(elementId) { document.getElementById(elementId).style.display = 'none'; }

        function updateFileDisplay(input, displayId) {
            const display = document.getElementById(displayId);
            if (input.files.length > 0) {
                display.innerHTML = `<i class="fas fa-file-csv"></i> ${input.files[0].name}`;
                display.classList.add('has-file');
            } else {
                display.innerHTML = `<i class="fas fa-file-csv"></i> Upload .csv file...`;
                display.classList.remove('has-file');
            }
        }
        
        function addProcessingLogStep(message, type = 'info') {
            const logUl = document.querySelector('#processingLog ul');
            if(!logUl) return;
            document.getElementById('processingLog').style.display = 'block';
            const li = document.createElement('li');
            let iconClass = 'fa-info-circle';
            if (type === 'success') iconClass = 'fa-check-circle text-green-500';
            else if (type === 'danger') iconClass = 'fa-times-circle text-red-500';
            else if (type === 'warning') iconClass = 'fa-exclamation-triangle text-yellow-500';
            li.innerHTML = `<i class="fas ${iconClass}" style="margin-right:0.5rem;"></i> ${message}`;
            logUl.appendChild(li);
            logUl.scrollTop = logUl.scrollHeight;
        }
        function clearProcessingLog() { 
            const logUl = document.querySelector('#processingLog ul');
            if (logUl) logUl.innerHTML = '';
            hideStatus('processingLog');
        }

        // --- LocalStorage Interaction ---
        function getPersistentDedupeSet(novelName) {
            if (!novelName) return new Set();
            const key = LS_DEDUPE_PREFIX + novelName;
            const storedArray = JSON.parse(localStorage.getItem(key) || '[]');
            return new Set(storedArray.map(term => term.toLowerCase()));
        }

        function savePersistentDedupeSet(novelName, translationsSet) {
            if (!novelName) {
                displayStatus('outputSummary', "Novel name is required to save to storage.", 'danger');
                return false;
            }
            const key = LS_DEDUPE_PREFIX + novelName;
            localStorage.setItem(key, JSON.stringify(Array.from(translationsSet)));
            updateStoredTermsInfo();
            return true;
        }
        
        function loadPersistentDedupe() {
            const novelName = novelNameInput.value.trim();
            if (!novelName) {
                displayStatus('sessionDedupeStatus', "Please enter a Novel/Project Name first.", 'warning');
                return;
            }
            persistentDedupeTranslations = getPersistentDedupeSet(novelName);
            displayStatus('sessionDedupeStatus', `${persistentDedupeTranslations.size} terms loaded from '${novelName}' storage. Will be used for next extraction.`, 'success');
        }
        
        function confirmClearStorage() {
            const novelName = novelNameInput.value.trim();
            if (!novelName) {
                 displayStatus('outputSummary', "Please enter a Novel/Project Name to clear its storage.", 'warning'); // Or general status
                return;
            }
            showModal(
                `Clear Storage for '${novelName}'?`,
                `This will permanently delete all ${getPersistentDedupeSet(novelName).size} stored deduplication terms for this project. This action cannot be undone.`,
                () => {
                    localStorage.removeItem(LS_DEDUPE_PREFIX + novelName);
                    persistentDedupeTranslations.clear(); // Clear in-memory copy too
                    displayStatus('outputSummary', `Storage for '${novelName}' cleared successfully.`, 'success');
                    updateStoredTermsInfo();
                }
            );
        }

        // --- Session Dedupe Management ---
        function loadSessionDedupeList() {
            const fileInput = document.getElementById('csvFile');
            const pastedCsv = document.getElementById('pastedCsv').value;
            let localTermsLoaded = 0;
            currentSessionDedupeTranslations.clear(); // Reset for this specific load operation

            const processContent = (content) => {
                content.split('\n').forEach(line => {
                    const parts = line.split(',').map(part => part.trim());
                    if (parts.length >= 2 && parts[1]) {
                        currentSessionDedupeTranslations.add(parts[1].toLowerCase());
                        localTermsLoaded++;
                    }
                });
            };

            if (fileInput.files.length > 0) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    processContent(e.target.result);
                    displayStatus('sessionDedupeStatus', `Loaded ${localTermsLoaded} terms to current session from file.`, 'success');
                };
                reader.onerror = () => displayStatus('sessionDedupeStatus', 'Error reading file.', 'danger');
                reader.readAsText(fileInput.files[0]);
            } else if (pastedCsv.trim()) {
                processContent(pastedCsv);
                displayStatus('sessionDedupeStatus', `Loaded ${localTermsLoaded} terms to current session from pasted text.`, 'success');
            } else {
                displayStatus('sessionDedupeStatus', 'No session dedupe data provided.', 'info');
            }
        }
        
        function clearSessionDedupeVisuals() {
            document.getElementById('csvFile').value = '';
            updateFileDisplay(document.getElementById('csvFile'), 'fileDisplayText_csv');
            document.getElementById('pastedCsv').value = '';
            currentSessionDedupeTranslations.clear(); // Clear the set
            hideStatus('sessionDedupeStatus');
        }

        // --- Main Extraction Logic ---
        async function processAllData() {
            const extractBtn = document.getElementById('mainExtractBtn');
            extractBtn.classList.add('loading');
            extractBtn.disabled = true;
            clearProcessingLog();
            hideStatus('jsonStatus'); hideStatus('outputSummary');
            document.getElementById('saveToStorageBtnContainer').innerHTML = ''; // Clear previous save button
            addProcessingLogStep('Extraction process initiated...', 'info');
            
            lastExtractedPureTerms = [];
            const chapterTextareas = document.querySelectorAll('#chapterInputsContainer textarea');
            if (chapterTextareas.length === 0 || Array.from(chapterTextareas).every(ta => !ta.value.trim())) {
                displayStatus('jsonStatus', "No chapter JSON provided.", 'warning');
                addProcessingLogStep('No chapter JSON data. Aborted.', 'danger');
                finalizeExtractionUI(extractBtn); return;
            }

            // Combine persistent and session dedupe lists for THIS extraction run
            const combinedDedupeForRun = new Set([...persistentDedupeTranslations, ...currentSessionDedupeTranslations]);
            addProcessingLogStep(`Using ${combinedDedupeForRun.size} terms for deduplication (from storage & session).`, 'info');

            let allChunks = [];
            let chaptersParsedCount = 0;
            for (let i = 0; i < chapterTextareas.length; i++) {
                const chapterJsonStr = chapterTextareas[i].value;
                if (!chapterJsonStr.trim()) { addProcessingLogStep(`Chapter Box ${i + 1} empty. Skipping.`, 'info'); continue; }
                addProcessingLogStep(`Parsing Chapter from Box ${i + 1}...`, 'info');
                await new Promise(r => setTimeout(r, 10)); // UI update tick
                try {
                    const parsedChapter = JSON.parse(chapterJsonStr);
                    if (!Array.isArray(parsedChapter) || (parsedChapter.length > 0 && (typeof parsedChapter[0] !== 'object' || !parsedChapter[0].terms))) {
                         addProcessingLogStep(`Box ${i+1}: Invalid JSON structure or missing terms. Skipped.`, 'warning'); continue;
                    }
                    allChunks.push(...parsedChapter);
                    chaptersParsedCount++;
                    addProcessingLogStep(`Box ${i + 1}: Parsed ${parsedChapter.length} chunks.`, 'success');
                } catch (e) { addProcessingLogStep(`Box ${i + 1}: JSON Parse Error - ${e.message}. Skipped.`, 'danger'); }
            }

            if (chaptersParsedCount === 0) {
                displayStatus('jsonStatus', 'No chapters successfully parsed. Check JSON.', 'danger');
                addProcessingLogStep('Failed to parse any chapter data. Aborted.', 'danger');
                finalizeExtractionUI(extractBtn); return;
            }
            addProcessingLogStep(`${chaptersParsedCount} chapters parsed. Extracting terms...`, 'info');

            const seenThisRunTranslations = new Set();
            allChunks.forEach(chunk => {
                if (chunk && Array.isArray(chunk.terms)) {
                    chunk.terms.forEach(term => {
                        const raw = term.raw, translation = term.translation;
                        if (raw && translation) {
                            const translationKey = translation.toLowerCase();
                            if (!combinedDedupeForRun.has(translationKey) && !seenThisRunTranslations.has(translationKey)) {
                                seenThisRunTranslations.add(translationKey);
                                let gender = "Neuter";
                                if (term.tags && term.tags.includes("#male")) gender = "Male";
                                else if (term.tags && term.tags.includes("#female")) gender = "Female";
                                lastExtractedPureTerms.push(`${raw}, ${translation}, ${gender}`);
                            }
                        }
                    });
                }
            });

            addProcessingLogStep(`Found ${lastExtractedPureTerms.length} new unique terms.`, 'success');
            
            let finalOutputText = "";
            const includeHeader = document.getElementById('includeCustomHeaderCheckbox').checked;
            const headerText = editablePresetTextarea.value.trim();
            if (includeHeader && headerText) {
                finalOutputText += headerText + "\n\n";
            }
            finalOutputText += lastExtractedPureTerms.join('\n');
            outputTextarea.value = finalOutputText;

            if (lastExtractedPureTerms.length > 0) {
                 displayStatus('outputSummary', `Extraction complete: ${lastExtractedPureTerms.length} new unique terms found.`, 'success');
                 createSaveToStorageButton();
            } else {
                 displayStatus('outputSummary', 'Extraction complete. No new unique terms found based on current deduplication lists.', 'info');
            }
            finalizeExtractionUI(extractBtn);
        }

        function createSaveToStorageButton() {
            const novelName = novelNameInput.value.trim();
            const container = document.getElementById('saveToStorageBtnContainer');
            container.innerHTML = ''; // Clear previous
            if (lastExtractedPureTerms.length > 0 && novelName) {
                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary';
                btn.innerHTML = `<i class="fas fa-save"></i> Save ${lastExtractedPureTerms.length} New Terms to '${novelName}' Storage`;
                btn.onclick = saveNewTermsToPersistentStorage;
                container.appendChild(btn);
            } else if (!novelName && lastExtractedPureTerms.length > 0) {
                 const p = document.createElement('p');
                 p.className = 'status-message status-warning';
                 p.innerHTML = `<i class="fas fa-exclamation-circle"></i> Enter a Novel Name to enable saving new terms to persistent storage.`;
                 container.appendChild(p);
            }
        }
        
        function saveNewTermsToPersistentStorage() {
            const novelName = novelNameInput.value.trim();
            if (!novelName) {
                displayStatus('outputSummary', 'Novel Name is required to save.', 'danger');
                return;
            }
            if (lastExtractedPureTerms.length === 0) {
                displayStatus('outputSummary', 'No new terms to save.', 'info');
                return;
            }

            const currentPersistentSet = getPersistentDedupeSet(novelName);
            let addedCount = 0;
            lastExtractedPureTerms.forEach(termLine => {
                const translationKey = termLine.split(',')[1]?.trim().toLowerCase();
                if (translationKey && !currentPersistentSet.has(translationKey)) {
                    currentPersistentSet.add(translationKey);
                    addedCount++;
                }
            });

            if (savePersistentDedupeSet(novelName, currentPersistentSet)) {
                displayStatus('outputSummary', `Successfully saved ${addedCount} new term translations to '${novelName}' storage. Total stored: ${currentPersistentSet.size}.`, 'success');
                // Optionally, clear lastExtractedPureTerms or disable button after saving
                 document.getElementById('saveToStorageBtnContainer').innerHTML = '<p class="status-message status-success"><i class="fas fa-check-circle"></i> New terms saved to storage!</p>';

            } else {
                displayStatus('outputSummary', `Failed to save new terms to '${novelName}' storage.`, 'danger');
            }
        }

        function finalizeExtractionUI(button) {
            button.classList.remove('loading');
            button.disabled = false;
        }

        // --- Copy to Clipboard ---
        function copyOutput(mode) {
            let textToCopy = "";
            let tooltipId = "";

            if (mode === 'termsOnly') {
                textToCopy = lastExtractedPureTerms.join('\n');
                tooltipId = 'copyTermsTooltip';
            } else if (mode === 'withHeader') {
                textToCopy = lastExtractedPureTerms.join('\n');
                if (document.getElementById('includeCustomHeaderCheckbox').checked) {
                    const header = editablePresetTextarea.value.trim();
                    if (header) textToCopy = header + "\n\n" + textToCopy;
                }
                 tooltipId = 'copyHeaderTooltip';
            }
            
            if (!textToCopy && mode === 'termsOnly') {
                 showTooltipMessage(tooltipId, "Nothing to copy!"); return;
            }
            if (!textToCopy && mode === 'withHeader' && 
                !(document.getElementById('includeCustomHeaderCheckbox').checked && editablePresetTextarea.value.trim())) {
                 showTooltipMessage(tooltipId, "No terms or header selected!"); return;
            }

            performCopy(textToCopy, tooltipId);
        }
        
        function copyToClipboard(elementId, tooltipId) { // General purpose
            const el = document.getElementById(elementId);
            if (!el.value || !el.value.trim()) {
                showTooltipMessage(tooltipId, "Nothing to copy!"); return;
            }
            performCopy(el.value, tooltipId);
        }

        function performCopy(text, tooltipId) {
            navigator.clipboard.writeText(text).then(() => {
                showTooltipMessage(tooltipId, "Copied!");
            }).catch(err => {
                console.error('Clipboard copy failed:', err);
                showTooltipMessage(tooltipId, "Copy Failed!");
            });
        }
        function showTooltipMessage(tooltipId, message) {
            const tooltip = document.getElementById(tooltipId);
            if (!tooltip) return;
            const originalText = tooltip.textContent;
            tooltip.textContent = message;
            setTimeout(() => { tooltip.textContent = originalText; }, 1500);
        }

        // --- Modal Logic ---
        let confirmCallback = null;
        const modalOverlay = document.getElementById('confirmationModal');
        const modalTitleEl = document.getElementById('modalTitle');
        const modalMessageEl = document.getElementById('modalMessageText');
        
        document.getElementById('modalCancelBtn').addEventListener('click', () => modalOverlay.classList.remove('active'));
        document.getElementById('modalConfirmBtn').addEventListener('click', () => {
            if(typeof confirmCallback === 'function') confirmCallback();
            modalOverlay.classList.remove('active');
        });

        function showModal(title, message, onConfirm) {
            modalTitleEl.textContent = title;
            modalMessageEl.textContent = message;
            confirmCallback = onConfirm;
            modalOverlay.classList.add('active');
        }

    </script>
</body>
</html>
